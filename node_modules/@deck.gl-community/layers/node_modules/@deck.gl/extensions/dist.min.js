(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var yt=Object.create;var m=Object.defineProperty;var bt=Object.getOwnPropertyDescriptor;var Ht=Object.getOwnPropertyNames;var Vt=Object.getPrototypeOf,Xt=Object.prototype.hasOwnProperty;var Ue=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),ge=(e,t)=>{for(var _ in t)m(e,_,{get:t[_],enumerable:!0})},$=(e,t,_,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Ht(t))!Xt.call(e,i)&&i!==_&&m(e,i,{get:()=>t[i],enumerable:!(r=bt(t,i))||r.enumerable});return e},M=(e,t,_)=>($(e,t,"default"),_&&$(_,t,"default")),E=(e,t,_)=>(_=e!=null?yt(Vt(e)):{},$(t||!e||!e.__esModule?m(_,"default",{value:e,enumerable:!0}):_,e)),ut=e=>$(m({},"__esModule",{value:!0}),e);var p=Ue((Nr,xe)=>{xe.exports=globalThis.deck});var je=Ue((hr,Ye)=>{Ye.exports=globalThis.luma});var Q={};ge(Q,{BrushingExtension:()=>v,ClipExtension:()=>W,CollisionFilterExtension:()=>Y,DataFilterExtension:()=>U,FillStyleExtension:()=>u,Fp64Extension:()=>b,MaskExtension:()=>j,PathStyleExtension:()=>V,_TerrainExtension:()=>q,project64:()=>oe});var d={},ye=E(p(),1);M(d,E(p(),1));if(!ye.Layer)throw new Error("@deck.gl/core is not found");M(Q,d);var Ve=E(p(),1);var be=E(p(),1),Wt=`
  uniform bool brushing_enabled;
  uniform int brushing_target;
  uniform vec2 brushing_mousePos;
  uniform float brushing_radius;

  #ifdef NON_INSTANCED_MODEL
  in vec2 brushingTargets;
  #else
  in vec2 instanceBrushingTargets;
  #endif

  out float brushing_isVisible;

  bool brushing_isPointInRange(vec2 position) {
    if (!brushing_enabled) {
      return true;
    }
    vec2 source_commonspace = project_position(position);
    vec2 target_commonspace = project_position(brushing_mousePos);
    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);

    return distance <= brushing_radius;
  }

  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
  }

  void brushing_setVisible(bool visible) {
    brushing_isVisible = float(visible);
  }
`,kt=`
  uniform bool brushing_enabled;
  in float brushing_isVisible;
`,wt={source:0,target:1,custom:2,source_target:3},Kt={"vs:DECKGL_FILTER_GL_POSITION":`
    vec2 brushingTarget;
    vec2 brushingSource;
    if (brushing_target == 3) {
      brushingTarget = geometry.worldPositionAlt.xy;
      brushingSource = geometry.worldPosition.xy;
    } else if (brushing_target == 0) {
      brushingTarget = geometry.worldPosition.xy;
    } else if (brushing_target == 1) {
      brushingTarget = geometry.worldPositionAlt.xy;
    } else {
      #ifdef NON_INSTANCED_MODEL
      brushingTarget = brushingTargets;
      #else
      brushingTarget = instanceBrushingTargets;
      #endif
    }
    bool visible;
    if (brushing_target == 3) {
      visible = brushing_arePointsInRange(brushingSource, brushingTarget);
    } else {
      visible = brushing_isPointInRange(brushingTarget);
    }
    brushing_setVisible(visible);
  `,"fs:DECKGL_FILTER_COLOR":`
    if (brushing_enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `},He={name:"brushing",dependencies:[be.project],vs:Wt,fs:kt,inject:Kt,getUniforms:e=>{if(!e||!("viewport"in e))return{};let{brushingEnabled:t=!0,brushingRadius:_=1e4,brushingTarget:r="source",mousePosition:i,viewport:s}=e;return{brushing_enabled:Boolean(t&&i&&s.containsPixel(i)),brushing_radius:_,brushing_target:wt[r]||0,brushing_mousePos:i?s.unproject([i.x-s.x,i.y-s.y]):[0,0]}}};var Yt={getBrushingTarget:{type:"accessor",value:[0,0]},brushingTarget:"source",brushingEnabled:!0,brushingRadius:1e4},L=class extends Ve.LayerExtension{getShaders(){return{modules:[He]}}initializeState(t,_){let r=this.getAttributeManager();r&&r.add({brushingTargets:{size:2,accessor:"getBrushingTarget",shaderAttributes:{brushingTargets:{divisor:0},instanceBrushingTargets:{divisor:1}}}});let i=()=>{this.getCurrentLayer()?.setNeedsRedraw()};this.state.onMouseMove=i,t.deck&&t.deck.eventManager.on({pointermove:i,pointerleave:i})}finalizeState(t,_){if(t.deck){let r=this.state.onMouseMove;t.deck.eventManager.off({pointermove:r,pointerleave:r})}}},v=L;(()=>{L.defaultProps=Yt})(),(()=>{L.extensionName="BrushingExtension"})();var n=function(e){return e[e.DEPTH_BUFFER_BIT=256]="DEPTH_BUFFER_BIT",e[e.STENCIL_BUFFER_BIT=1024]="STENCIL_BUFFER_BIT",e[e.COLOR_BUFFER_BIT=16384]="COLOR_BUFFER_BIT",e[e.POINTS=0]="POINTS",e[e.LINES=1]="LINES",e[e.LINE_LOOP=2]="LINE_LOOP",e[e.LINE_STRIP=3]="LINE_STRIP",e[e.TRIANGLES=4]="TRIANGLES",e[e.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",e[e.TRIANGLE_FAN=6]="TRIANGLE_FAN",e[e.ZERO=0]="ZERO",e[e.ONE=1]="ONE",e[e.SRC_COLOR=768]="SRC_COLOR",e[e.ONE_MINUS_SRC_COLOR=769]="ONE_MINUS_SRC_COLOR",e[e.SRC_ALPHA=770]="SRC_ALPHA",e[e.ONE_MINUS_SRC_ALPHA=771]="ONE_MINUS_SRC_ALPHA",e[e.DST_ALPHA=772]="DST_ALPHA",e[e.ONE_MINUS_DST_ALPHA=773]="ONE_MINUS_DST_ALPHA",e[e.DST_COLOR=774]="DST_COLOR",e[e.ONE_MINUS_DST_COLOR=775]="ONE_MINUS_DST_COLOR",e[e.SRC_ALPHA_SATURATE=776]="SRC_ALPHA_SATURATE",e[e.CONSTANT_COLOR=32769]="CONSTANT_COLOR",e[e.ONE_MINUS_CONSTANT_COLOR=32770]="ONE_MINUS_CONSTANT_COLOR",e[e.CONSTANT_ALPHA=32771]="CONSTANT_ALPHA",e[e.ONE_MINUS_CONSTANT_ALPHA=32772]="ONE_MINUS_CONSTANT_ALPHA",e[e.FUNC_ADD=32774]="FUNC_ADD",e[e.FUNC_SUBTRACT=32778]="FUNC_SUBTRACT",e[e.FUNC_REVERSE_SUBTRACT=32779]="FUNC_REVERSE_SUBTRACT",e[e.BLEND_EQUATION=32777]="BLEND_EQUATION",e[e.BLEND_EQUATION_RGB=32777]="BLEND_EQUATION_RGB",e[e.BLEND_EQUATION_ALPHA=34877]="BLEND_EQUATION_ALPHA",e[e.BLEND_DST_RGB=32968]="BLEND_DST_RGB",e[e.BLEND_SRC_RGB=32969]="BLEND_SRC_RGB",e[e.BLEND_DST_ALPHA=32970]="BLEND_DST_ALPHA",e[e.BLEND_SRC_ALPHA=32971]="BLEND_SRC_ALPHA",e[e.BLEND_COLOR=32773]="BLEND_COLOR",e[e.ARRAY_BUFFER_BINDING=34964]="ARRAY_BUFFER_BINDING",e[e.ELEMENT_ARRAY_BUFFER_BINDING=34965]="ELEMENT_ARRAY_BUFFER_BINDING",e[e.LINE_WIDTH=2849]="LINE_WIDTH",e[e.ALIASED_POINT_SIZE_RANGE=33901]="ALIASED_POINT_SIZE_RANGE",e[e.ALIASED_LINE_WIDTH_RANGE=33902]="ALIASED_LINE_WIDTH_RANGE",e[e.CULL_FACE_MODE=2885]="CULL_FACE_MODE",e[e.FRONT_FACE=2886]="FRONT_FACE",e[e.DEPTH_RANGE=2928]="DEPTH_RANGE",e[e.DEPTH_WRITEMASK=2930]="DEPTH_WRITEMASK",e[e.DEPTH_CLEAR_VALUE=2931]="DEPTH_CLEAR_VALUE",e[e.DEPTH_FUNC=2932]="DEPTH_FUNC",e[e.STENCIL_CLEAR_VALUE=2961]="STENCIL_CLEAR_VALUE",e[e.STENCIL_FUNC=2962]="STENCIL_FUNC",e[e.STENCIL_FAIL=2964]="STENCIL_FAIL",e[e.STENCIL_PASS_DEPTH_FAIL=2965]="STENCIL_PASS_DEPTH_FAIL",e[e.STENCIL_PASS_DEPTH_PASS=2966]="STENCIL_PASS_DEPTH_PASS",e[e.STENCIL_REF=2967]="STENCIL_REF",e[e.STENCIL_VALUE_MASK=2963]="STENCIL_VALUE_MASK",e[e.STENCIL_WRITEMASK=2968]="STENCIL_WRITEMASK",e[e.STENCIL_BACK_FUNC=34816]="STENCIL_BACK_FUNC",e[e.STENCIL_BACK_FAIL=34817]="STENCIL_BACK_FAIL",e[e.STENCIL_BACK_PASS_DEPTH_FAIL=34818]="STENCIL_BACK_PASS_DEPTH_FAIL",e[e.STENCIL_BACK_PASS_DEPTH_PASS=34819]="STENCIL_BACK_PASS_DEPTH_PASS",e[e.STENCIL_BACK_REF=36003]="STENCIL_BACK_REF",e[e.STENCIL_BACK_VALUE_MASK=36004]="STENCIL_BACK_VALUE_MASK",e[e.STENCIL_BACK_WRITEMASK=36005]="STENCIL_BACK_WRITEMASK",e[e.VIEWPORT=2978]="VIEWPORT",e[e.SCISSOR_BOX=3088]="SCISSOR_BOX",e[e.COLOR_CLEAR_VALUE=3106]="COLOR_CLEAR_VALUE",e[e.COLOR_WRITEMASK=3107]="COLOR_WRITEMASK",e[e.UNPACK_ALIGNMENT=3317]="UNPACK_ALIGNMENT",e[e.PACK_ALIGNMENT=3333]="PACK_ALIGNMENT",e[e.MAX_TEXTURE_SIZE=3379]="MAX_TEXTURE_SIZE",e[e.MAX_VIEWPORT_DIMS=3386]="MAX_VIEWPORT_DIMS",e[e.SUBPIXEL_BITS=3408]="SUBPIXEL_BITS",e[e.RED_BITS=3410]="RED_BITS",e[e.GREEN_BITS=3411]="GREEN_BITS",e[e.BLUE_BITS=3412]="BLUE_BITS",e[e.ALPHA_BITS=3413]="ALPHA_BITS",e[e.DEPTH_BITS=3414]="DEPTH_BITS",e[e.STENCIL_BITS=3415]="STENCIL_BITS",e[e.POLYGON_OFFSET_UNITS=10752]="POLYGON_OFFSET_UNITS",e[e.POLYGON_OFFSET_FACTOR=32824]="POLYGON_OFFSET_FACTOR",e[e.TEXTURE_BINDING_2D=32873]="TEXTURE_BINDING_2D",e[e.SAMPLE_BUFFERS=32936]="SAMPLE_BUFFERS",e[e.SAMPLES=32937]="SAMPLES",e[e.SAMPLE_COVERAGE_VALUE=32938]="SAMPLE_COVERAGE_VALUE",e[e.SAMPLE_COVERAGE_INVERT=32939]="SAMPLE_COVERAGE_INVERT",e[e.COMPRESSED_TEXTURE_FORMATS=34467]="COMPRESSED_TEXTURE_FORMATS",e[e.VENDOR=7936]="VENDOR",e[e.RENDERER=7937]="RENDERER",e[e.VERSION=7938]="VERSION",e[e.IMPLEMENTATION_COLOR_READ_TYPE=35738]="IMPLEMENTATION_COLOR_READ_TYPE",e[e.IMPLEMENTATION_COLOR_READ_FORMAT=35739]="IMPLEMENTATION_COLOR_READ_FORMAT",e[e.BROWSER_DEFAULT_WEBGL=37444]="BROWSER_DEFAULT_WEBGL",e[e.STATIC_DRAW=35044]="STATIC_DRAW",e[e.STREAM_DRAW=35040]="STREAM_DRAW",e[e.DYNAMIC_DRAW=35048]="DYNAMIC_DRAW",e[e.ARRAY_BUFFER=34962]="ARRAY_BUFFER",e[e.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",e[e.BUFFER_SIZE=34660]="BUFFER_SIZE",e[e.BUFFER_USAGE=34661]="BUFFER_USAGE",e[e.CURRENT_VERTEX_ATTRIB=34342]="CURRENT_VERTEX_ATTRIB",e[e.VERTEX_ATTRIB_ARRAY_ENABLED=34338]="VERTEX_ATTRIB_ARRAY_ENABLED",e[e.VERTEX_ATTRIB_ARRAY_SIZE=34339]="VERTEX_ATTRIB_ARRAY_SIZE",e[e.VERTEX_ATTRIB_ARRAY_STRIDE=34340]="VERTEX_ATTRIB_ARRAY_STRIDE",e[e.VERTEX_ATTRIB_ARRAY_TYPE=34341]="VERTEX_ATTRIB_ARRAY_TYPE",e[e.VERTEX_ATTRIB_ARRAY_NORMALIZED=34922]="VERTEX_ATTRIB_ARRAY_NORMALIZED",e[e.VERTEX_ATTRIB_ARRAY_POINTER=34373]="VERTEX_ATTRIB_ARRAY_POINTER",e[e.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING=34975]="VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",e[e.CULL_FACE=2884]="CULL_FACE",e[e.FRONT=1028]="FRONT",e[e.BACK=1029]="BACK",e[e.FRONT_AND_BACK=1032]="FRONT_AND_BACK",e[e.BLEND=3042]="BLEND",e[e.DEPTH_TEST=2929]="DEPTH_TEST",e[e.DITHER=3024]="DITHER",e[e.POLYGON_OFFSET_FILL=32823]="POLYGON_OFFSET_FILL",e[e.SAMPLE_ALPHA_TO_COVERAGE=32926]="SAMPLE_ALPHA_TO_COVERAGE",e[e.SAMPLE_COVERAGE=32928]="SAMPLE_COVERAGE",e[e.SCISSOR_TEST=3089]="SCISSOR_TEST",e[e.STENCIL_TEST=2960]="STENCIL_TEST",e[e.NO_ERROR=0]="NO_ERROR",e[e.INVALID_ENUM=1280]="INVALID_ENUM",e[e.INVALID_VALUE=1281]="INVALID_VALUE",e[e.INVALID_OPERATION=1282]="INVALID_OPERATION",e[e.OUT_OF_MEMORY=1285]="OUT_OF_MEMORY",e[e.CONTEXT_LOST_WEBGL=37442]="CONTEXT_LOST_WEBGL",e[e.CW=2304]="CW",e[e.CCW=2305]="CCW",e[e.DONT_CARE=4352]="DONT_CARE",e[e.FASTEST=4353]="FASTEST",e[e.NICEST=4354]="NICEST",e[e.GENERATE_MIPMAP_HINT=33170]="GENERATE_MIPMAP_HINT",e[e.BYTE=5120]="BYTE",e[e.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",e[e.SHORT=5122]="SHORT",e[e.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",e[e.INT=5124]="INT",e[e.UNSIGNED_INT=5125]="UNSIGNED_INT",e[e.FLOAT=5126]="FLOAT",e[e.DOUBLE=5130]="DOUBLE",e[e.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",e[e.ALPHA=6406]="ALPHA",e[e.RGB=6407]="RGB",e[e.RGBA=6408]="RGBA",e[e.LUMINANCE=6409]="LUMINANCE",e[e.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",e[e.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",e[e.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",e[e.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",e[e.FRAGMENT_SHADER=35632]="FRAGMENT_SHADER",e[e.VERTEX_SHADER=35633]="VERTEX_SHADER",e[e.COMPILE_STATUS=35713]="COMPILE_STATUS",e[e.DELETE_STATUS=35712]="DELETE_STATUS",e[e.LINK_STATUS=35714]="LINK_STATUS",e[e.VALIDATE_STATUS=35715]="VALIDATE_STATUS",e[e.ATTACHED_SHADERS=35717]="ATTACHED_SHADERS",e[e.ACTIVE_ATTRIBUTES=35721]="ACTIVE_ATTRIBUTES",e[e.ACTIVE_UNIFORMS=35718]="ACTIVE_UNIFORMS",e[e.MAX_VERTEX_ATTRIBS=34921]="MAX_VERTEX_ATTRIBS",e[e.MAX_VERTEX_UNIFORM_VECTORS=36347]="MAX_VERTEX_UNIFORM_VECTORS",e[e.MAX_VARYING_VECTORS=36348]="MAX_VARYING_VECTORS",e[e.MAX_COMBINED_TEXTURE_IMAGE_UNITS=35661]="MAX_COMBINED_TEXTURE_IMAGE_UNITS",e[e.MAX_VERTEX_TEXTURE_IMAGE_UNITS=35660]="MAX_VERTEX_TEXTURE_IMAGE_UNITS",e[e.MAX_TEXTURE_IMAGE_UNITS=34930]="MAX_TEXTURE_IMAGE_UNITS",e[e.MAX_FRAGMENT_UNIFORM_VECTORS=36349]="MAX_FRAGMENT_UNIFORM_VECTORS",e[e.SHADER_TYPE=35663]="SHADER_TYPE",e[e.SHADING_LANGUAGE_VERSION=35724]="SHADING_LANGUAGE_VERSION",e[e.CURRENT_PROGRAM=35725]="CURRENT_PROGRAM",e[e.NEVER=512]="NEVER",e[e.LESS=513]="LESS",e[e.EQUAL=514]="EQUAL",e[e.LEQUAL=515]="LEQUAL",e[e.GREATER=516]="GREATER",e[e.NOTEQUAL=517]="NOTEQUAL",e[e.GEQUAL=518]="GEQUAL",e[e.ALWAYS=519]="ALWAYS",e[e.KEEP=7680]="KEEP",e[e.REPLACE=7681]="REPLACE",e[e.INCR=7682]="INCR",e[e.DECR=7683]="DECR",e[e.INVERT=5386]="INVERT",e[e.INCR_WRAP=34055]="INCR_WRAP",e[e.DECR_WRAP=34056]="DECR_WRAP",e[e.NEAREST=9728]="NEAREST",e[e.LINEAR=9729]="LINEAR",e[e.NEAREST_MIPMAP_NEAREST=9984]="NEAREST_MIPMAP_NEAREST",e[e.LINEAR_MIPMAP_NEAREST=9985]="LINEAR_MIPMAP_NEAREST",e[e.NEAREST_MIPMAP_LINEAR=9986]="NEAREST_MIPMAP_LINEAR",e[e.LINEAR_MIPMAP_LINEAR=9987]="LINEAR_MIPMAP_LINEAR",e[e.TEXTURE_MAG_FILTER=10240]="TEXTURE_MAG_FILTER",e[e.TEXTURE_MIN_FILTER=10241]="TEXTURE_MIN_FILTER",e[e.TEXTURE_WRAP_S=10242]="TEXTURE_WRAP_S",e[e.TEXTURE_WRAP_T=10243]="TEXTURE_WRAP_T",e[e.TEXTURE_2D=3553]="TEXTURE_2D",e[e.TEXTURE=5890]="TEXTURE",e[e.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",e[e.TEXTURE_BINDING_CUBE_MAP=34068]="TEXTURE_BINDING_CUBE_MAP",e[e.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",e[e.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",e[e.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",e[e.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",e[e.MAX_CUBE_MAP_TEXTURE_SIZE=34076]="MAX_CUBE_MAP_TEXTURE_SIZE",e[e.TEXTURE0=33984]="TEXTURE0",e[e.ACTIVE_TEXTURE=34016]="ACTIVE_TEXTURE",e[e.REPEAT=10497]="REPEAT",e[e.CLAMP_TO_EDGE=33071]="CLAMP_TO_EDGE",e[e.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",e[e.TEXTURE_WIDTH=4096]="TEXTURE_WIDTH",e[e.TEXTURE_HEIGHT=4097]="TEXTURE_HEIGHT",e[e.FLOAT_VEC2=35664]="FLOAT_VEC2",e[e.FLOAT_VEC3=35665]="FLOAT_VEC3",e[e.FLOAT_VEC4=35666]="FLOAT_VEC4",e[e.INT_VEC2=35667]="INT_VEC2",e[e.INT_VEC3=35668]="INT_VEC3",e[e.INT_VEC4=35669]="INT_VEC4",e[e.BOOL=35670]="BOOL",e[e.BOOL_VEC2=35671]="BOOL_VEC2",e[e.BOOL_VEC3=35672]="BOOL_VEC3",e[e.BOOL_VEC4=35673]="BOOL_VEC4",e[e.FLOAT_MAT2=35674]="FLOAT_MAT2",e[e.FLOAT_MAT3=35675]="FLOAT_MAT3",e[e.FLOAT_MAT4=35676]="FLOAT_MAT4",e[e.SAMPLER_2D=35678]="SAMPLER_2D",e[e.SAMPLER_CUBE=35680]="SAMPLER_CUBE",e[e.LOW_FLOAT=36336]="LOW_FLOAT",e[e.MEDIUM_FLOAT=36337]="MEDIUM_FLOAT",e[e.HIGH_FLOAT=36338]="HIGH_FLOAT",e[e.LOW_INT=36339]="LOW_INT",e[e.MEDIUM_INT=36340]="MEDIUM_INT",e[e.HIGH_INT=36341]="HIGH_INT",e[e.FRAMEBUFFER=36160]="FRAMEBUFFER",e[e.RENDERBUFFER=36161]="RENDERBUFFER",e[e.RGBA4=32854]="RGBA4",e[e.RGB5_A1=32855]="RGB5_A1",e[e.RGB565=36194]="RGB565",e[e.DEPTH_COMPONENT16=33189]="DEPTH_COMPONENT16",e[e.STENCIL_INDEX=6401]="STENCIL_INDEX",e[e.STENCIL_INDEX8=36168]="STENCIL_INDEX8",e[e.DEPTH_STENCIL=34041]="DEPTH_STENCIL",e[e.RENDERBUFFER_WIDTH=36162]="RENDERBUFFER_WIDTH",e[e.RENDERBUFFER_HEIGHT=36163]="RENDERBUFFER_HEIGHT",e[e.RENDERBUFFER_INTERNAL_FORMAT=36164]="RENDERBUFFER_INTERNAL_FORMAT",e[e.RENDERBUFFER_RED_SIZE=36176]="RENDERBUFFER_RED_SIZE",e[e.RENDERBUFFER_GREEN_SIZE=36177]="RENDERBUFFER_GREEN_SIZE",e[e.RENDERBUFFER_BLUE_SIZE=36178]="RENDERBUFFER_BLUE_SIZE",e[e.RENDERBUFFER_ALPHA_SIZE=36179]="RENDERBUFFER_ALPHA_SIZE",e[e.RENDERBUFFER_DEPTH_SIZE=36180]="RENDERBUFFER_DEPTH_SIZE",e[e.RENDERBUFFER_STENCIL_SIZE=36181]="RENDERBUFFER_STENCIL_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE=36048]="FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME=36049]="FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL=36050]="FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE=36051]="FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",e[e.COLOR_ATTACHMENT0=36064]="COLOR_ATTACHMENT0",e[e.DEPTH_ATTACHMENT=36096]="DEPTH_ATTACHMENT",e[e.STENCIL_ATTACHMENT=36128]="STENCIL_ATTACHMENT",e[e.DEPTH_STENCIL_ATTACHMENT=33306]="DEPTH_STENCIL_ATTACHMENT",e[e.NONE=0]="NONE",e[e.FRAMEBUFFER_COMPLETE=36053]="FRAMEBUFFER_COMPLETE",e[e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT=36054]="FRAMEBUFFER_INCOMPLETE_ATTACHMENT",e[e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT=36055]="FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",e[e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS=36057]="FRAMEBUFFER_INCOMPLETE_DIMENSIONS",e[e.FRAMEBUFFER_UNSUPPORTED=36061]="FRAMEBUFFER_UNSUPPORTED",e[e.FRAMEBUFFER_BINDING=36006]="FRAMEBUFFER_BINDING",e[e.RENDERBUFFER_BINDING=36007]="RENDERBUFFER_BINDING",e[e.READ_FRAMEBUFFER=36008]="READ_FRAMEBUFFER",e[e.DRAW_FRAMEBUFFER=36009]="DRAW_FRAMEBUFFER",e[e.MAX_RENDERBUFFER_SIZE=34024]="MAX_RENDERBUFFER_SIZE",e[e.INVALID_FRAMEBUFFER_OPERATION=1286]="INVALID_FRAMEBUFFER_OPERATION",e[e.UNPACK_FLIP_Y_WEBGL=37440]="UNPACK_FLIP_Y_WEBGL",e[e.UNPACK_PREMULTIPLY_ALPHA_WEBGL=37441]="UNPACK_PREMULTIPLY_ALPHA_WEBGL",e[e.UNPACK_COLORSPACE_CONVERSION_WEBGL=37443]="UNPACK_COLORSPACE_CONVERSION_WEBGL",e[e.READ_BUFFER=3074]="READ_BUFFER",e[e.UNPACK_ROW_LENGTH=3314]="UNPACK_ROW_LENGTH",e[e.UNPACK_SKIP_ROWS=3315]="UNPACK_SKIP_ROWS",e[e.UNPACK_SKIP_PIXELS=3316]="UNPACK_SKIP_PIXELS",e[e.PACK_ROW_LENGTH=3330]="PACK_ROW_LENGTH",e[e.PACK_SKIP_ROWS=3331]="PACK_SKIP_ROWS",e[e.PACK_SKIP_PIXELS=3332]="PACK_SKIP_PIXELS",e[e.TEXTURE_BINDING_3D=32874]="TEXTURE_BINDING_3D",e[e.UNPACK_SKIP_IMAGES=32877]="UNPACK_SKIP_IMAGES",e[e.UNPACK_IMAGE_HEIGHT=32878]="UNPACK_IMAGE_HEIGHT",e[e.MAX_3D_TEXTURE_SIZE=32883]="MAX_3D_TEXTURE_SIZE",e[e.MAX_ELEMENTS_VERTICES=33e3]="MAX_ELEMENTS_VERTICES",e[e.MAX_ELEMENTS_INDICES=33001]="MAX_ELEMENTS_INDICES",e[e.MAX_TEXTURE_LOD_BIAS=34045]="MAX_TEXTURE_LOD_BIAS",e[e.MAX_FRAGMENT_UNIFORM_COMPONENTS=35657]="MAX_FRAGMENT_UNIFORM_COMPONENTS",e[e.MAX_VERTEX_UNIFORM_COMPONENTS=35658]="MAX_VERTEX_UNIFORM_COMPONENTS",e[e.MAX_ARRAY_TEXTURE_LAYERS=35071]="MAX_ARRAY_TEXTURE_LAYERS",e[e.MIN_PROGRAM_TEXEL_OFFSET=35076]="MIN_PROGRAM_TEXEL_OFFSET",e[e.MAX_PROGRAM_TEXEL_OFFSET=35077]="MAX_PROGRAM_TEXEL_OFFSET",e[e.MAX_VARYING_COMPONENTS=35659]="MAX_VARYING_COMPONENTS",e[e.FRAGMENT_SHADER_DERIVATIVE_HINT=35723]="FRAGMENT_SHADER_DERIVATIVE_HINT",e[e.RASTERIZER_DISCARD=35977]="RASTERIZER_DISCARD",e[e.VERTEX_ARRAY_BINDING=34229]="VERTEX_ARRAY_BINDING",e[e.MAX_VERTEX_OUTPUT_COMPONENTS=37154]="MAX_VERTEX_OUTPUT_COMPONENTS",e[e.MAX_FRAGMENT_INPUT_COMPONENTS=37157]="MAX_FRAGMENT_INPUT_COMPONENTS",e[e.MAX_SERVER_WAIT_TIMEOUT=37137]="MAX_SERVER_WAIT_TIMEOUT",e[e.MAX_ELEMENT_INDEX=36203]="MAX_ELEMENT_INDEX",e[e.RED=6403]="RED",e[e.RGB8=32849]="RGB8",e[e.RGBA8=32856]="RGBA8",e[e.RGB10_A2=32857]="RGB10_A2",e[e.TEXTURE_3D=32879]="TEXTURE_3D",e[e.TEXTURE_WRAP_R=32882]="TEXTURE_WRAP_R",e[e.TEXTURE_MIN_LOD=33082]="TEXTURE_MIN_LOD",e[e.TEXTURE_MAX_LOD=33083]="TEXTURE_MAX_LOD",e[e.TEXTURE_BASE_LEVEL=33084]="TEXTURE_BASE_LEVEL",e[e.TEXTURE_MAX_LEVEL=33085]="TEXTURE_MAX_LEVEL",e[e.TEXTURE_COMPARE_MODE=34892]="TEXTURE_COMPARE_MODE",e[e.TEXTURE_COMPARE_FUNC=34893]="TEXTURE_COMPARE_FUNC",e[e.SRGB=35904]="SRGB",e[e.SRGB8=35905]="SRGB8",e[e.SRGB8_ALPHA8=35907]="SRGB8_ALPHA8",e[e.COMPARE_REF_TO_TEXTURE=34894]="COMPARE_REF_TO_TEXTURE",e[e.RGBA32F=34836]="RGBA32F",e[e.RGB32F=34837]="RGB32F",e[e.RGBA16F=34842]="RGBA16F",e[e.RGB16F=34843]="RGB16F",e[e.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",e[e.TEXTURE_BINDING_2D_ARRAY=35869]="TEXTURE_BINDING_2D_ARRAY",e[e.R11F_G11F_B10F=35898]="R11F_G11F_B10F",e[e.RGB9_E5=35901]="RGB9_E5",e[e.RGBA32UI=36208]="RGBA32UI",e[e.RGB32UI=36209]="RGB32UI",e[e.RGBA16UI=36214]="RGBA16UI",e[e.RGB16UI=36215]="RGB16UI",e[e.RGBA8UI=36220]="RGBA8UI",e[e.RGB8UI=36221]="RGB8UI",e[e.RGBA32I=36226]="RGBA32I",e[e.RGB32I=36227]="RGB32I",e[e.RGBA16I=36232]="RGBA16I",e[e.RGB16I=36233]="RGB16I",e[e.RGBA8I=36238]="RGBA8I",e[e.RGB8I=36239]="RGB8I",e[e.RED_INTEGER=36244]="RED_INTEGER",e[e.RGB_INTEGER=36248]="RGB_INTEGER",e[e.RGBA_INTEGER=36249]="RGBA_INTEGER",e[e.R8=33321]="R8",e[e.RG8=33323]="RG8",e[e.R16F=33325]="R16F",e[e.R32F=33326]="R32F",e[e.RG16F=33327]="RG16F",e[e.RG32F=33328]="RG32F",e[e.R8I=33329]="R8I",e[e.R8UI=33330]="R8UI",e[e.R16I=33331]="R16I",e[e.R16UI=33332]="R16UI",e[e.R32I=33333]="R32I",e[e.R32UI=33334]="R32UI",e[e.RG8I=33335]="RG8I",e[e.RG8UI=33336]="RG8UI",e[e.RG16I=33337]="RG16I",e[e.RG16UI=33338]="RG16UI",e[e.RG32I=33339]="RG32I",e[e.RG32UI=33340]="RG32UI",e[e.R8_SNORM=36756]="R8_SNORM",e[e.RG8_SNORM=36757]="RG8_SNORM",e[e.RGB8_SNORM=36758]="RGB8_SNORM",e[e.RGBA8_SNORM=36759]="RGBA8_SNORM",e[e.RGB10_A2UI=36975]="RGB10_A2UI",e[e.TEXTURE_IMMUTABLE_FORMAT=37167]="TEXTURE_IMMUTABLE_FORMAT",e[e.TEXTURE_IMMUTABLE_LEVELS=33503]="TEXTURE_IMMUTABLE_LEVELS",e[e.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",e[e.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",e[e.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",e[e.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",e[e.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",e[e.HALF_FLOAT=5131]="HALF_FLOAT",e[e.RG=33319]="RG",e[e.RG_INTEGER=33320]="RG_INTEGER",e[e.INT_2_10_10_10_REV=36255]="INT_2_10_10_10_REV",e[e.CURRENT_QUERY=34917]="CURRENT_QUERY",e[e.QUERY_RESULT=34918]="QUERY_RESULT",e[e.QUERY_RESULT_AVAILABLE=34919]="QUERY_RESULT_AVAILABLE",e[e.ANY_SAMPLES_PASSED=35887]="ANY_SAMPLES_PASSED",e[e.ANY_SAMPLES_PASSED_CONSERVATIVE=36202]="ANY_SAMPLES_PASSED_CONSERVATIVE",e[e.MAX_DRAW_BUFFERS=34852]="MAX_DRAW_BUFFERS",e[e.DRAW_BUFFER0=34853]="DRAW_BUFFER0",e[e.DRAW_BUFFER1=34854]="DRAW_BUFFER1",e[e.DRAW_BUFFER2=34855]="DRAW_BUFFER2",e[e.DRAW_BUFFER3=34856]="DRAW_BUFFER3",e[e.DRAW_BUFFER4=34857]="DRAW_BUFFER4",e[e.DRAW_BUFFER5=34858]="DRAW_BUFFER5",e[e.DRAW_BUFFER6=34859]="DRAW_BUFFER6",e[e.DRAW_BUFFER7=34860]="DRAW_BUFFER7",e[e.DRAW_BUFFER8=34861]="DRAW_BUFFER8",e[e.DRAW_BUFFER9=34862]="DRAW_BUFFER9",e[e.DRAW_BUFFER10=34863]="DRAW_BUFFER10",e[e.DRAW_BUFFER11=34864]="DRAW_BUFFER11",e[e.DRAW_BUFFER12=34865]="DRAW_BUFFER12",e[e.DRAW_BUFFER13=34866]="DRAW_BUFFER13",e[e.DRAW_BUFFER14=34867]="DRAW_BUFFER14",e[e.DRAW_BUFFER15=34868]="DRAW_BUFFER15",e[e.MAX_COLOR_ATTACHMENTS=36063]="MAX_COLOR_ATTACHMENTS",e[e.COLOR_ATTACHMENT1=36065]="COLOR_ATTACHMENT1",e[e.COLOR_ATTACHMENT2=36066]="COLOR_ATTACHMENT2",e[e.COLOR_ATTACHMENT3=36067]="COLOR_ATTACHMENT3",e[e.COLOR_ATTACHMENT4=36068]="COLOR_ATTACHMENT4",e[e.COLOR_ATTACHMENT5=36069]="COLOR_ATTACHMENT5",e[e.COLOR_ATTACHMENT6=36070]="COLOR_ATTACHMENT6",e[e.COLOR_ATTACHMENT7=36071]="COLOR_ATTACHMENT7",e[e.COLOR_ATTACHMENT8=36072]="COLOR_ATTACHMENT8",e[e.COLOR_ATTACHMENT9=36073]="COLOR_ATTACHMENT9",e[e.COLOR_ATTACHMENT10=36074]="COLOR_ATTACHMENT10",e[e.COLOR_ATTACHMENT11=36075]="COLOR_ATTACHMENT11",e[e.COLOR_ATTACHMENT12=36076]="COLOR_ATTACHMENT12",e[e.COLOR_ATTACHMENT13=36077]="COLOR_ATTACHMENT13",e[e.COLOR_ATTACHMENT14=36078]="COLOR_ATTACHMENT14",e[e.COLOR_ATTACHMENT15=36079]="COLOR_ATTACHMENT15",e[e.SAMPLER_3D=35679]="SAMPLER_3D",e[e.SAMPLER_2D_SHADOW=35682]="SAMPLER_2D_SHADOW",e[e.SAMPLER_2D_ARRAY=36289]="SAMPLER_2D_ARRAY",e[e.SAMPLER_2D_ARRAY_SHADOW=36292]="SAMPLER_2D_ARRAY_SHADOW",e[e.SAMPLER_CUBE_SHADOW=36293]="SAMPLER_CUBE_SHADOW",e[e.INT_SAMPLER_2D=36298]="INT_SAMPLER_2D",e[e.INT_SAMPLER_3D=36299]="INT_SAMPLER_3D",e[e.INT_SAMPLER_CUBE=36300]="INT_SAMPLER_CUBE",e[e.INT_SAMPLER_2D_ARRAY=36303]="INT_SAMPLER_2D_ARRAY",e[e.UNSIGNED_INT_SAMPLER_2D=36306]="UNSIGNED_INT_SAMPLER_2D",e[e.UNSIGNED_INT_SAMPLER_3D=36307]="UNSIGNED_INT_SAMPLER_3D",e[e.UNSIGNED_INT_SAMPLER_CUBE=36308]="UNSIGNED_INT_SAMPLER_CUBE",e[e.UNSIGNED_INT_SAMPLER_2D_ARRAY=36311]="UNSIGNED_INT_SAMPLER_2D_ARRAY",e[e.MAX_SAMPLES=36183]="MAX_SAMPLES",e[e.SAMPLER_BINDING=35097]="SAMPLER_BINDING",e[e.PIXEL_PACK_BUFFER=35051]="PIXEL_PACK_BUFFER",e[e.PIXEL_UNPACK_BUFFER=35052]="PIXEL_UNPACK_BUFFER",e[e.PIXEL_PACK_BUFFER_BINDING=35053]="PIXEL_PACK_BUFFER_BINDING",e[e.PIXEL_UNPACK_BUFFER_BINDING=35055]="PIXEL_UNPACK_BUFFER_BINDING",e[e.COPY_READ_BUFFER=36662]="COPY_READ_BUFFER",e[e.COPY_WRITE_BUFFER=36663]="COPY_WRITE_BUFFER",e[e.COPY_READ_BUFFER_BINDING=36662]="COPY_READ_BUFFER_BINDING",e[e.COPY_WRITE_BUFFER_BINDING=36663]="COPY_WRITE_BUFFER_BINDING",e[e.FLOAT_MAT2x3=35685]="FLOAT_MAT2x3",e[e.FLOAT_MAT2x4=35686]="FLOAT_MAT2x4",e[e.FLOAT_MAT3x2=35687]="FLOAT_MAT3x2",e[e.FLOAT_MAT3x4=35688]="FLOAT_MAT3x4",e[e.FLOAT_MAT4x2=35689]="FLOAT_MAT4x2",e[e.FLOAT_MAT4x3=35690]="FLOAT_MAT4x3",e[e.UNSIGNED_INT_VEC2=36294]="UNSIGNED_INT_VEC2",e[e.UNSIGNED_INT_VEC3=36295]="UNSIGNED_INT_VEC3",e[e.UNSIGNED_INT_VEC4=36296]="UNSIGNED_INT_VEC4",e[e.UNSIGNED_NORMALIZED=35863]="UNSIGNED_NORMALIZED",e[e.SIGNED_NORMALIZED=36764]="SIGNED_NORMALIZED",e[e.VERTEX_ATTRIB_ARRAY_INTEGER=35069]="VERTEX_ATTRIB_ARRAY_INTEGER",e[e.VERTEX_ATTRIB_ARRAY_DIVISOR=35070]="VERTEX_ATTRIB_ARRAY_DIVISOR",e[e.TRANSFORM_FEEDBACK_BUFFER_MODE=35967]="TRANSFORM_FEEDBACK_BUFFER_MODE",e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS=35968]="MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",e[e.TRANSFORM_FEEDBACK_VARYINGS=35971]="TRANSFORM_FEEDBACK_VARYINGS",e[e.TRANSFORM_FEEDBACK_BUFFER_START=35972]="TRANSFORM_FEEDBACK_BUFFER_START",e[e.TRANSFORM_FEEDBACK_BUFFER_SIZE=35973]="TRANSFORM_FEEDBACK_BUFFER_SIZE",e[e.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN=35976]="TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",e[e.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS=35978]="MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS=35979]="MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",e[e.INTERLEAVED_ATTRIBS=35980]="INTERLEAVED_ATTRIBS",e[e.SEPARATE_ATTRIBS=35981]="SEPARATE_ATTRIBS",e[e.TRANSFORM_FEEDBACK_BUFFER=35982]="TRANSFORM_FEEDBACK_BUFFER",e[e.TRANSFORM_FEEDBACK_BUFFER_BINDING=35983]="TRANSFORM_FEEDBACK_BUFFER_BINDING",e[e.TRANSFORM_FEEDBACK=36386]="TRANSFORM_FEEDBACK",e[e.TRANSFORM_FEEDBACK_PAUSED=36387]="TRANSFORM_FEEDBACK_PAUSED",e[e.TRANSFORM_FEEDBACK_ACTIVE=36388]="TRANSFORM_FEEDBACK_ACTIVE",e[e.TRANSFORM_FEEDBACK_BINDING=36389]="TRANSFORM_FEEDBACK_BINDING",e[e.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING=33296]="FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",e[e.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE=33297]="FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",e[e.FRAMEBUFFER_ATTACHMENT_RED_SIZE=33298]="FRAMEBUFFER_ATTACHMENT_RED_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE=33299]="FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE=33300]="FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE=33301]="FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE=33302]="FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE=33303]="FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",e[e.FRAMEBUFFER_DEFAULT=33304]="FRAMEBUFFER_DEFAULT",e[e.DEPTH24_STENCIL8=35056]="DEPTH24_STENCIL8",e[e.DRAW_FRAMEBUFFER_BINDING=36006]="DRAW_FRAMEBUFFER_BINDING",e[e.READ_FRAMEBUFFER_BINDING=36010]="READ_FRAMEBUFFER_BINDING",e[e.RENDERBUFFER_SAMPLES=36011]="RENDERBUFFER_SAMPLES",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER=36052]="FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",e[e.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE=36182]="FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",e[e.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",e[e.UNIFORM_BUFFER_BINDING=35368]="UNIFORM_BUFFER_BINDING",e[e.UNIFORM_BUFFER_START=35369]="UNIFORM_BUFFER_START",e[e.UNIFORM_BUFFER_SIZE=35370]="UNIFORM_BUFFER_SIZE",e[e.MAX_VERTEX_UNIFORM_BLOCKS=35371]="MAX_VERTEX_UNIFORM_BLOCKS",e[e.MAX_FRAGMENT_UNIFORM_BLOCKS=35373]="MAX_FRAGMENT_UNIFORM_BLOCKS",e[e.MAX_COMBINED_UNIFORM_BLOCKS=35374]="MAX_COMBINED_UNIFORM_BLOCKS",e[e.MAX_UNIFORM_BUFFER_BINDINGS=35375]="MAX_UNIFORM_BUFFER_BINDINGS",e[e.MAX_UNIFORM_BLOCK_SIZE=35376]="MAX_UNIFORM_BLOCK_SIZE",e[e.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS=35377]="MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",e[e.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS=35379]="MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",e[e.UNIFORM_BUFFER_OFFSET_ALIGNMENT=35380]="UNIFORM_BUFFER_OFFSET_ALIGNMENT",e[e.ACTIVE_UNIFORM_BLOCKS=35382]="ACTIVE_UNIFORM_BLOCKS",e[e.UNIFORM_TYPE=35383]="UNIFORM_TYPE",e[e.UNIFORM_SIZE=35384]="UNIFORM_SIZE",e[e.UNIFORM_BLOCK_INDEX=35386]="UNIFORM_BLOCK_INDEX",e[e.UNIFORM_OFFSET=35387]="UNIFORM_OFFSET",e[e.UNIFORM_ARRAY_STRIDE=35388]="UNIFORM_ARRAY_STRIDE",e[e.UNIFORM_MATRIX_STRIDE=35389]="UNIFORM_MATRIX_STRIDE",e[e.UNIFORM_IS_ROW_MAJOR=35390]="UNIFORM_IS_ROW_MAJOR",e[e.UNIFORM_BLOCK_BINDING=35391]="UNIFORM_BLOCK_BINDING",e[e.UNIFORM_BLOCK_DATA_SIZE=35392]="UNIFORM_BLOCK_DATA_SIZE",e[e.UNIFORM_BLOCK_ACTIVE_UNIFORMS=35394]="UNIFORM_BLOCK_ACTIVE_UNIFORMS",e[e.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES=35395]="UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",e[e.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER=35396]="UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",e[e.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER=35398]="UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",e[e.OBJECT_TYPE=37138]="OBJECT_TYPE",e[e.SYNC_CONDITION=37139]="SYNC_CONDITION",e[e.SYNC_STATUS=37140]="SYNC_STATUS",e[e.SYNC_FLAGS=37141]="SYNC_FLAGS",e[e.SYNC_FENCE=37142]="SYNC_FENCE",e[e.SYNC_GPU_COMMANDS_COMPLETE=37143]="SYNC_GPU_COMMANDS_COMPLETE",e[e.UNSIGNALED=37144]="UNSIGNALED",e[e.SIGNALED=37145]="SIGNALED",e[e.ALREADY_SIGNALED=37146]="ALREADY_SIGNALED",e[e.TIMEOUT_EXPIRED=37147]="TIMEOUT_EXPIRED",e[e.CONDITION_SATISFIED=37148]="CONDITION_SATISFIED",e[e.WAIT_FAILED=37149]="WAIT_FAILED",e[e.SYNC_FLUSH_COMMANDS_BIT=1]="SYNC_FLUSH_COMMANDS_BIT",e[e.COLOR=6144]="COLOR",e[e.DEPTH=6145]="DEPTH",e[e.STENCIL=6146]="STENCIL",e[e.MIN=32775]="MIN",e[e.MAX=32776]="MAX",e[e.DEPTH_COMPONENT24=33190]="DEPTH_COMPONENT24",e[e.STREAM_READ=35041]="STREAM_READ",e[e.STREAM_COPY=35042]="STREAM_COPY",e[e.STATIC_READ=35045]="STATIC_READ",e[e.STATIC_COPY=35046]="STATIC_COPY",e[e.DYNAMIC_READ=35049]="DYNAMIC_READ",e[e.DYNAMIC_COPY=35050]="DYNAMIC_COPY",e[e.DEPTH_COMPONENT32F=36012]="DEPTH_COMPONENT32F",e[e.DEPTH32F_STENCIL8=36013]="DEPTH32F_STENCIL8",e[e.INVALID_INDEX=4294967295]="INVALID_INDEX",e[e.TIMEOUT_IGNORED=-1]="TIMEOUT_IGNORED",e[e.MAX_CLIENT_WAIT_TIMEOUT_WEBGL=37447]="MAX_CLIENT_WAIT_TIMEOUT_WEBGL",e[e.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE=35070]="VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",e[e.UNMASKED_VENDOR_WEBGL=37445]="UNMASKED_VENDOR_WEBGL",e[e.UNMASKED_RENDERER_WEBGL=37446]="UNMASKED_RENDERER_WEBGL",e[e.MAX_TEXTURE_MAX_ANISOTROPY_EXT=34047]="MAX_TEXTURE_MAX_ANISOTROPY_EXT",e[e.TEXTURE_MAX_ANISOTROPY_EXT=34046]="TEXTURE_MAX_ANISOTROPY_EXT",e[e.SRGB_EXT=35904]="SRGB_EXT",e[e.SRGB_ALPHA_EXT=35906]="SRGB_ALPHA_EXT",e[e.SRGB8_ALPHA8_EXT=35907]="SRGB8_ALPHA8_EXT",e[e.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT=33296]="FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT",e[e.R16_EXT=33322]="R16_EXT",e[e.RG16_EXT=33324]="RG16_EXT",e[e.RGB16_EXT=32852]="RGB16_EXT",e[e.RGBA16_EXT=32859]="RGBA16_EXT",e[e.R16_SNORM_EXT=36760]="R16_SNORM_EXT",e[e.RG16_SNORM_EXT=36761]="RG16_SNORM_EXT",e[e.RGB16_SNORM_EXT=36762]="RGB16_SNORM_EXT",e[e.RGBA16_SNORM_EXT=36763]="RGBA16_SNORM_EXT",e[e.COMPRESSED_RGB_S3TC_DXT1_EXT=33776]="COMPRESSED_RGB_S3TC_DXT1_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT=33777]="COMPRESSED_RGBA_S3TC_DXT1_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT=33778]="COMPRESSED_RGBA_S3TC_DXT3_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT=33779]="COMPRESSED_RGBA_S3TC_DXT5_EXT",e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT=35916]="COMPRESSED_SRGB_S3TC_DXT1_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=35917]="COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT=35918]="COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=35919]="COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",e[e.COMPRESSED_RED_RGTC1_EXT=36283]="COMPRESSED_RED_RGTC1_EXT",e[e.COMPRESSED_SIGNED_RED_RGTC1_EXT=36284]="COMPRESSED_SIGNED_RED_RGTC1_EXT",e[e.COMPRESSED_RED_GREEN_RGTC2_EXT=36285]="COMPRESSED_RED_GREEN_RGTC2_EXT",e[e.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT=36286]="COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT",e[e.COMPRESSED_RGBA_BPTC_UNORM_EXT=36492]="COMPRESSED_RGBA_BPTC_UNORM_EXT",e[e.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT=36493]="COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT",e[e.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT=36494]="COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT",e[e.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT=36495]="COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT",e[e.COMPRESSED_R11_EAC=37488]="COMPRESSED_R11_EAC",e[e.COMPRESSED_SIGNED_R11_EAC=37489]="COMPRESSED_SIGNED_R11_EAC",e[e.COMPRESSED_RG11_EAC=37490]="COMPRESSED_RG11_EAC",e[e.COMPRESSED_SIGNED_RG11_EAC=37491]="COMPRESSED_SIGNED_RG11_EAC",e[e.COMPRESSED_RGB8_ETC2=37492]="COMPRESSED_RGB8_ETC2",e[e.COMPRESSED_RGBA8_ETC2_EAC=37493]="COMPRESSED_RGBA8_ETC2_EAC",e[e.COMPRESSED_SRGB8_ETC2=37494]="COMPRESSED_SRGB8_ETC2",e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=37495]="COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2=37496]="COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2=37497]="COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG=35840]="COMPRESSED_RGB_PVRTC_4BPPV1_IMG",e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG=35842]="COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG=35841]="COMPRESSED_RGB_PVRTC_2BPPV1_IMG",e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG=35843]="COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",e[e.COMPRESSED_RGB_ETC1_WEBGL=36196]="COMPRESSED_RGB_ETC1_WEBGL",e[e.COMPRESSED_RGB_ATC_WEBGL=35986]="COMPRESSED_RGB_ATC_WEBGL",e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL=35986]="COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL=34798]="COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",e[e.COMPRESSED_RGBA_ASTC_4x4_KHR=37808]="COMPRESSED_RGBA_ASTC_4x4_KHR",e[e.COMPRESSED_RGBA_ASTC_5x4_KHR=37809]="COMPRESSED_RGBA_ASTC_5x4_KHR",e[e.COMPRESSED_RGBA_ASTC_5x5_KHR=37810]="COMPRESSED_RGBA_ASTC_5x5_KHR",e[e.COMPRESSED_RGBA_ASTC_6x5_KHR=37811]="COMPRESSED_RGBA_ASTC_6x5_KHR",e[e.COMPRESSED_RGBA_ASTC_6x6_KHR=37812]="COMPRESSED_RGBA_ASTC_6x6_KHR",e[e.COMPRESSED_RGBA_ASTC_8x5_KHR=37813]="COMPRESSED_RGBA_ASTC_8x5_KHR",e[e.COMPRESSED_RGBA_ASTC_8x6_KHR=37814]="COMPRESSED_RGBA_ASTC_8x6_KHR",e[e.COMPRESSED_RGBA_ASTC_8x8_KHR=37815]="COMPRESSED_RGBA_ASTC_8x8_KHR",e[e.COMPRESSED_RGBA_ASTC_10x5_KHR=37816]="COMPRESSED_RGBA_ASTC_10x5_KHR",e[e.COMPRESSED_RGBA_ASTC_10x6_KHR=37817]="COMPRESSED_RGBA_ASTC_10x6_KHR",e[e.COMPRESSED_RGBA_ASTC_10x8_KHR=37818]="COMPRESSED_RGBA_ASTC_10x8_KHR",e[e.COMPRESSED_RGBA_ASTC_10x10_KHR=37819]="COMPRESSED_RGBA_ASTC_10x10_KHR",e[e.COMPRESSED_RGBA_ASTC_12x10_KHR=37820]="COMPRESSED_RGBA_ASTC_12x10_KHR",e[e.COMPRESSED_RGBA_ASTC_12x12_KHR=37821]="COMPRESSED_RGBA_ASTC_12x12_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=37840]="COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR=37841]="COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR=37842]="COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR=37843]="COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR=37844]="COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR=37845]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR=37846]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR=37847]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR=37848]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR=37849]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR=37850]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR=37851]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR=37852]="COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR=37853]="COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",e[e.UNSIGNED_INT_24_8_WEBGL=34042]="UNSIGNED_INT_24_8_WEBGL",e[e.HALF_FLOAT_OES=36193]="HALF_FLOAT_OES",e[e.RGBA32F_EXT=34836]="RGBA32F_EXT",e[e.RGB32F_EXT=34837]="RGB32F_EXT",e[e.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT=33297]="FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT",e[e.UNSIGNED_NORMALIZED_EXT=35863]="UNSIGNED_NORMALIZED_EXT",e[e.MIN_EXT=32775]="MIN_EXT",e[e.MAX_EXT=32776]="MAX_EXT",e[e.FRAGMENT_SHADER_DERIVATIVE_HINT_OES=35723]="FRAGMENT_SHADER_DERIVATIVE_HINT_OES",e[e.COLOR_ATTACHMENT0_WEBGL=36064]="COLOR_ATTACHMENT0_WEBGL",e[e.COLOR_ATTACHMENT1_WEBGL=36065]="COLOR_ATTACHMENT1_WEBGL",e[e.COLOR_ATTACHMENT2_WEBGL=36066]="COLOR_ATTACHMENT2_WEBGL",e[e.COLOR_ATTACHMENT3_WEBGL=36067]="COLOR_ATTACHMENT3_WEBGL",e[e.COLOR_ATTACHMENT4_WEBGL=36068]="COLOR_ATTACHMENT4_WEBGL",e[e.COLOR_ATTACHMENT5_WEBGL=36069]="COLOR_ATTACHMENT5_WEBGL",e[e.COLOR_ATTACHMENT6_WEBGL=36070]="COLOR_ATTACHMENT6_WEBGL",e[e.COLOR_ATTACHMENT7_WEBGL=36071]="COLOR_ATTACHMENT7_WEBGL",e[e.COLOR_ATTACHMENT8_WEBGL=36072]="COLOR_ATTACHMENT8_WEBGL",e[e.COLOR_ATTACHMENT9_WEBGL=36073]="COLOR_ATTACHMENT9_WEBGL",e[e.COLOR_ATTACHMENT10_WEBGL=36074]="COLOR_ATTACHMENT10_WEBGL",e[e.COLOR_ATTACHMENT11_WEBGL=36075]="COLOR_ATTACHMENT11_WEBGL",e[e.COLOR_ATTACHMENT12_WEBGL=36076]="COLOR_ATTACHMENT12_WEBGL",e[e.COLOR_ATTACHMENT13_WEBGL=36077]="COLOR_ATTACHMENT13_WEBGL",e[e.COLOR_ATTACHMENT14_WEBGL=36078]="COLOR_ATTACHMENT14_WEBGL",e[e.COLOR_ATTACHMENT15_WEBGL=36079]="COLOR_ATTACHMENT15_WEBGL",e[e.DRAW_BUFFER0_WEBGL=34853]="DRAW_BUFFER0_WEBGL",e[e.DRAW_BUFFER1_WEBGL=34854]="DRAW_BUFFER1_WEBGL",e[e.DRAW_BUFFER2_WEBGL=34855]="DRAW_BUFFER2_WEBGL",e[e.DRAW_BUFFER3_WEBGL=34856]="DRAW_BUFFER3_WEBGL",e[e.DRAW_BUFFER4_WEBGL=34857]="DRAW_BUFFER4_WEBGL",e[e.DRAW_BUFFER5_WEBGL=34858]="DRAW_BUFFER5_WEBGL",e[e.DRAW_BUFFER6_WEBGL=34859]="DRAW_BUFFER6_WEBGL",e[e.DRAW_BUFFER7_WEBGL=34860]="DRAW_BUFFER7_WEBGL",e[e.DRAW_BUFFER8_WEBGL=34861]="DRAW_BUFFER8_WEBGL",e[e.DRAW_BUFFER9_WEBGL=34862]="DRAW_BUFFER9_WEBGL",e[e.DRAW_BUFFER10_WEBGL=34863]="DRAW_BUFFER10_WEBGL",e[e.DRAW_BUFFER11_WEBGL=34864]="DRAW_BUFFER11_WEBGL",e[e.DRAW_BUFFER12_WEBGL=34865]="DRAW_BUFFER12_WEBGL",e[e.DRAW_BUFFER13_WEBGL=34866]="DRAW_BUFFER13_WEBGL",e[e.DRAW_BUFFER14_WEBGL=34867]="DRAW_BUFFER14_WEBGL",e[e.DRAW_BUFFER15_WEBGL=34868]="DRAW_BUFFER15_WEBGL",e[e.MAX_COLOR_ATTACHMENTS_WEBGL=36063]="MAX_COLOR_ATTACHMENTS_WEBGL",e[e.MAX_DRAW_BUFFERS_WEBGL=34852]="MAX_DRAW_BUFFERS_WEBGL",e[e.VERTEX_ARRAY_BINDING_OES=34229]="VERTEX_ARRAY_BINDING_OES",e[e.QUERY_COUNTER_BITS_EXT=34916]="QUERY_COUNTER_BITS_EXT",e[e.CURRENT_QUERY_EXT=34917]="CURRENT_QUERY_EXT",e[e.QUERY_RESULT_EXT=34918]="QUERY_RESULT_EXT",e[e.QUERY_RESULT_AVAILABLE_EXT=34919]="QUERY_RESULT_AVAILABLE_EXT",e[e.TIME_ELAPSED_EXT=35007]="TIME_ELAPSED_EXT",e[e.TIMESTAMP_EXT=36392]="TIMESTAMP_EXT",e[e.GPU_DISJOINT_EXT=36795]="GPU_DISJOINT_EXT",e}(n||{});var F=E(p(),1);var Xe=`
uniform DATAFILTER_TYPE filter_min;
uniform DATAFILTER_TYPE filter_softMin;
uniform DATAFILTER_TYPE filter_softMax;
uniform DATAFILTER_TYPE filter_max;
uniform bool filter_useSoftMargin;
uniform bool filter_enabled;
uniform bool filter_transformSize;
uniform ivec4 filter_categoryBitMask;

#ifdef NON_INSTANCED_MODEL
  #define DATAFILTER_ATTRIB filterValues
  #define DATAFILTER_ATTRIB_64LOW filterValues64Low
  #define DATACATEGORY_ATTRIB filterCategoryValues
#else
  #define DATAFILTER_ATTRIB instanceFilterValues
  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low
  #define DATACATEGORY_ATTRIB instanceFilterCategoryValues
#endif

in DATAFILTER_TYPE DATAFILTER_ATTRIB;
#ifdef DATAFILTER_DOUBLE
  in DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;

  uniform DATAFILTER_TYPE filter_min64High;
  uniform DATAFILTER_TYPE filter_max64High;
#endif
in DATACATEGORY_TYPE DATACATEGORY_ATTRIB;

out float dataFilter_value;

float dataFilter_reduceValue(float value) {
  return value;
}
float dataFilter_reduceValue(vec2 value) {
  return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
  return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
  return min(min(value.x, value.y), min(value.z, value.w));
}
void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax, DATACATEGORY_TYPE category) {
  if (filter_enabled) {
    if (filter_useSoftMargin) {
      dataFilter_value = dataFilter_reduceValue(
        smoothstep(filter_min, filter_softMin, valueFromMin) *
        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))
      );
    } else {
      dataFilter_value = dataFilter_reduceValue(
        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)
      );
    }

    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask
      int dataFilter_masks = filter_categoryBitMask[int(category / 32.0)];
    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks
      ivec2 dataFilter_masks = ivec2(
        filter_categoryBitMask[int(category.x / 32.0)],
        filter_categoryBitMask[int(category.y / 32.0) + 2]
      );
    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks
      ivec3 dataFilter_masks = filter_categoryBitMask.xyz;
    #else // Four 32-bit masks
      ivec4 dataFilter_masks = filter_categoryBitMask;
    #endif

    // Shift mask and extract relevant bits
    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) / pow(DATACATEGORY_TYPE(2.0), mod(category, 32.0));
    dataFilter_bits = mod(floor(dataFilter_bits), 2.0);

    #if DATACATEGORY_CHANNELS == 1
      if(dataFilter_bits == 0.0) dataFilter_value = 0.0;
    #else
    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0.0)))) dataFilter_value = 0.0;
    #endif
  } else {
    dataFilter_value = 1.0;
  }
}
`,ue=`
uniform bool filter_transformColor;
in float dataFilter_value;
`;function We(e){if(!e||!("extensions"in e))return{};let{filterRange:t=[-1,1],filterEnabled:_=!0,filterTransformSize:r=!0,filterTransformColor:i=!0}=e,s=e.filterSoftRange||t;return{...Number.isFinite(t[0])?{filter_min:t[0],filter_softMin:s[0],filter_softMax:s[1],filter_max:t[1]}:{filter_min:t.map(o=>o[0]),filter_softMin:s.map(o=>o[0]),filter_softMax:s.map(o=>o[1]),filter_max:t.map(o=>o[1])},filter_enabled:_,filter_useSoftMargin:Boolean(e.filterSoftRange),filter_transformSize:_&&r,filter_transformColor:_&&i}}function jt(e){if(!e||!("extensions"in e))return{};let t=We(e);if(Number.isFinite(t.filter_min)){let _=Math.fround(t.filter_min);t.filter_min-=_,t.filter_softMin-=_,t.filter_min64High=_;let r=Math.fround(t.filter_max);t.filter_max-=r,t.filter_softMax-=r,t.filter_max64High=r}else{let _=t.filter_min.map(Math.fround);t.filter_min=t.filter_min.map((i,s)=>i-_[s]),t.filter_softMin=t.filter_softMin.map((i,s)=>i-_[s]),t.filter_min64High=_;let r=t.filter_max.map(Math.fround);t.filter_max=t.filter_max.map((i,s)=>i-r[s]),t.filter_softMax=t.filter_softMax.map((i,s)=>i-r[s]),t.filter_max64High=r}return t}var ke={"vs:#main-start":`
    #ifdef DATAFILTER_DOUBLE
      dataFilter_setValue(
        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,
        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW,
        DATACATEGORY_ATTRIB
      );
    #else
      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB, DATACATEGORY_ATTRIB);
    #endif
  `,"vs:#main-end":`
    if (dataFilter_value == 0.0) {
      gl_Position = vec4(0.);
    }
  `,"vs:DECKGL_FILTER_SIZE":`
    if (filter_transformSize) {
      size = size * dataFilter_value;
    }
  `,"fs:DECKGL_FILTER_COLOR":`
    if (dataFilter_value == 0.0) discard;
    if (filter_transformColor) {
      color.a *= dataFilter_value;
    }
  `},we={name:"data-filter",vs:Xe,fs:ue,inject:ke,getUniforms:We},Ke={name:"data-filter-fp64",vs:Xe,fs:ue,inject:ke,getUniforms:jt};var ze=E(je(),1);var zt=`#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`,Zt=`#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`;function Ze(e){let t=e.gl;return Boolean(t.getExtension("EXT_float_blend")&&(t.getExtension("EXT_color_buffer_float")||t.getExtension("WEBGL_color_buffer_float")))}function qe(e,t){return t?e.createFramebuffer({width:1,height:1,colorAttachments:[e.createTexture({format:e.info.type==="webgl2"?"rgba32float":"rgba8unorm",type:n.FLOAT,mipmaps:!1})]}):e.createFramebuffer({width:256,height:64,colorAttachments:[e.createTexture({format:"rgba8unorm",type:n.FLOAT,mipmaps:!1})]})}function Qe(e,t,_){return t.defines.NON_INSTANCED_MODEL=1,_&&(t.defines.FLOAT_TARGET=1),new ze.Model(e,{id:"data-filter-aggregation-model",vertexCount:1,isInstanced:!1,drawMode:n.POINTS,vs:zt,fs:Zt,...t})}var Je={blend:!0,blendFunc:[n.ONE,n.ONE,n.ONE,n.ONE],blendEquation:[n.FUNC_ADD,n.FUNC_ADD],depthTest:!1};var Qt={getFilterValue:{type:"accessor",value:0},getFilterCategory:{type:"accessor",value:0},onFilteredItemsChange:{type:"function",value:null,optional:!0},filterEnabled:!0,filterRange:[-1,1],filterSoftRange:null,filterCategories:[0],filterTransformSize:!0,filterTransformColor:!0},Jt={categorySize:1,filterSize:1,fp64:!1,countItems:!1},$e={1:"float",2:"vec2",3:"vec3",4:"vec4"},G=class extends F.LayerExtension{constructor(t){super({...Jt,...t})}getShaders(t){let{categorySize:_,filterSize:r,fp64:i}=t.opts;return{modules:[i?Ke:we],defines:{DATACATEGORY_TYPE:$e[_],DATACATEGORY_CHANNELS:_,DATAFILTER_TYPE:$e[r],DATAFILTER_DOUBLE:Boolean(i)}}}initializeState(t,_){let r=this.getAttributeManager(),{categorySize:i,filterSize:s,fp64:o}=_.opts;r&&r.add({filterValues:{size:s,type:o?n.DOUBLE:n.FLOAT,accessor:"getFilterValue",shaderAttributes:{filterValues:{divisor:0},instanceFilterValues:{divisor:1}}},filterCategoryValues:{size:i,type:n.FLOAT,accessor:"getFilterCategory",transform:i===1?R=>_._getCategoryKey.call(this,R,0):R=>R.map((l,T)=>_._getCategoryKey.call(this,l,T)),shaderAttributes:{filterCategoryValues:{divisor:0},instanceFilterCategoryValues:{divisor:1}}}});let{device:a}=this.context;if(r&&_.opts.countItems){let R=Ze(a);r.add({filterIndices:{size:R?1:2,vertexOffset:1,type:n.UNSIGNED_BYTE,normalized:!0,accessor:(A,{index:f})=>{let c=A&&A.__source?A.__source.index:f;return R?(c+1)%255:[(c+1)%255,Math.floor(c/255)%255]},shaderAttributes:{filterPrevIndices:{vertexOffset:0},filterIndices:{vertexOffset:1}}}});let l=qe(a,R),T=Qe(a,_.getShaders.call(this,_),R);this.setState({filterFBO:l,filterModel:T})}}updateState({props:t,oldProps:_,changeFlags:r},i){let s=this.getAttributeManager(),{categorySize:o}=i.opts;if(this.state.filterModel){let a=s.attributes.filterValues.needsUpdate()||s.attributes.filterCategoryValues?.needsUpdate()||t.filterEnabled!==_.filterEnabled||t.filterRange!==_.filterRange||t.filterSoftRange!==_.filterSoftRange||t.filterCategories!==_.filterCategories;a&&this.setState({filterNeedsUpdate:a})}if(s?.attributes.filterCategoryValues){let a=s.attributes.filterCategoryValues.needsUpdate()||!(0,F._deepEqual)(t.filterCategories,_.filterCategories,2);a&&this.setState({categoryBitMaskNeedsUpdate:a}),r.dataChanged&&(this.setState({categoryMap:Array(o).fill(0).map(()=>({}))}),s.attributes.filterCategoryValues.setNeedsUpdate("categoryMap"))}}draw(t,_){let r=this.state.filterFBO,i=this.state.filterModel,s=this.state.filterNeedsUpdate,o=this.state.categoryBitMaskNeedsUpdate,{onFilteredItemsChange:a}=this.props;if(o&&_._updateCategoryBitMask.call(this,t,_),s&&a&&i){let{attributes:{filterValues:R,filterCategoryValues:l,filterIndices:T}}=this.getAttributeManager();i.setVertexCount(this.getNumInstances()),this.context.device.clearWebGL({framebuffer:r,color:[0,0,0,0]}),i.updateModuleSettings(t.moduleParameters),i.setAttributes({...R.getValue(),...l?.getValue(),...T?.getValue()}),i.setUniforms(t.uniforms),i.device.withParametersWebGL({framebuffer:r,...Je,viewport:[0,0,r.width,r.height]},()=>{i.draw(this.context.renderPass)});let A=i.device.readPixelsToArrayWebGL(r),f=0;for(let c=0;c<A.length;c++)f+=A[c];a({id:this.id,count:f}),this.state.filterNeedsUpdate=!1}}finalizeState(){let t=this.state.filterFBO,_=this.state.filterModel;t?.destroy(),_?.destroy()}_updateCategoryBitMask(t,_){let{categorySize:r}=_.opts,{filterCategories:i}=this.props,s=new Uint32Array([0,0,0,0]),o=r===1?[i]:i,a=r===1?128:r===2?64:32;for(let R=0;R<o.length;R++){let l=o[R];for(let T of l){let A=_._getCategoryKey.call(this,T,R);if(A<a){let f=R*(a/32)+Math.floor(A/32);s[f]+=Math.pow(2,A%32)}else F.log.warn(`Exceeded maximum number of categories (${a})`)()}}t.uniforms.filter_categoryBitMask=s,this.state.categoryBitMaskNeedsUpdate=!1}_getCategoryKey(t,_){let r=this.state.categoryMap[_];return t in r||(r[t]=Object.keys(r).length),r[t]}},U=G;(()=>{G.defaultProps=Qt})(),(()=>{G.extensionName="DataFilterExtension"})();var y=E(p(),1);var ee=e=>`${e}`;function te(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[],_=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0,r=Math.fround(e),i=e-r;return t[_]=r,t[_+1]=i,t}function Me(e){return e-Math.fround(e)}function Oe(e){let t=new Float32Array(32);for(let _=0;_<4;++_)for(let r=0;r<4;++r){let i=_*4+r;te(e[r*4+_],t,i*2)}return t}var me=ee`\
uniform float ONE;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * ONE - (t - a);
  float a_lo = a * ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * ONE;
  float err = b - (sum - a) * ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * ONE - a) * ONE;
  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * ONE - a) * ONE;
  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;var Le=ee`\
const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);

const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);

const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);

const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!

float nint(float d) {
    if (d == floor(d)) return d;
    return floor(d + 0.5);
}

vec2 nint_fp64(vec2 a) {
    float hi = nint(a.x);
    float lo;
    vec2 tmp;
    if (hi == a.x) {
        lo = nint(a.y);
        tmp = quickTwoSum(hi, lo);
    } else {
        lo = 0.0;
        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
            hi -= 1.0;
        }
        tmp = vec2(hi, lo);
    }
    return tmp;
}

/* k_power controls how much range reduction we would like to have
Range reduction uses the following method:
assume a = k_power * r + m * log(2), k and m being integers.
Set k_power = 4 (we can choose other k to trade accuracy with performance.
we only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;
*/

vec2 exp_fp64(vec2 a) {
  // We need to make sure these two numbers match
  // as bit-wise shift is not available in GLSL 1.0
  const int k_power = 4;
  const float k = 16.0;

  const float inv_k = 1.0 / k;

  if (a.x <= -88.0) return vec2(0.0, 0.0);
  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
  if (a.x == 1.0 && a.y == 0.0) return E_FP64;

  float m = floor(a.x / LOG2_FP64.x + 0.5);
  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
  vec2 s, t, p;

  p = mul_fp64(r, r);
  s = sum_fp64(r, p * 0.5);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);

  s = sum_fp64(s, t);


  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.
  for (int i = 0; i < k_power; i++) {
    s = sum_fp64(s * 2.0, mul_fp64(s, s));
  }

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = sum_fp64(s, vec2(ONE, 0.0));
#else
  s = sum_fp64(s, vec2(1.0, 0.0));
#endif

  return s * pow(2.0, m);
//   return r;
}

vec2 log_fp64(vec2 a)
{
  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
  vec2 x = vec2(log(a.x), 0.0);
  vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = vec2(ONE, 0.0);
#else
  s = vec2(1.0, 0.0);
#endif

  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
  return x;
}

vec2 sin_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(0.0, 0.0);
  }

  x = -mul_fp64(a, a);
  s = a;
  r = a;

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);
  // s = sum_fp64(s, t);

  return s;
}

vec2 cos_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(1.0, 0.0);
  }

  x = -mul_fp64(a, a);
  r = x;
  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);
  // s = sum_fp64(s, t);

  return s;
}

void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
  if (a.x == 0.0 && a.y == 0.0) {
    sin_t = vec2(0.0, 0.0);
    cos_t = vec2(1.0, 0.0);
  }

  sin_t = sin_taylor_fp64(a);
  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}

vec2 sin_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return sin_taylor_fp64(t);
        } else if (j == 1) {
            return cos_taylor_fp64(t);
        } else if (j == -1) {
            return -cos_taylor_fp64(t);
        } else {
            return -sin_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);



    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        }
    } else {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    }

    return result;
}

vec2 cos_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(1.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return cos_taylor_fp64(t);
        } else if (j == 1) {
            return -sin_taylor_fp64(t);
        } else if (j == -1) {
            return sin_taylor_fp64(t);
        } else {
            return -cos_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);

    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    return result;
}

vec2 tan_fp64(vec2 a) {
    vec2 sin_a;
    vec2 cos_a;

    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);


    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    // We just can't get PI/16 * 3.0 very accurately.
    // so let's just store it
    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }


    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

    vec2 sin_t, cos_t;
    vec2 s, c;
    sincos_taylor_fp64(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#else
        if (abs_k == 1) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs_k == 2) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs_k == 3) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs_k == 4) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#endif
        if (k > 0) {
            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return div_fp64(sin_a, cos_a);
}

vec2 radians_fp64(vec2 degree) {
  return mul_fp64(degree, PI_180_FP64);
}

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

// Vector functions
// vec2 functions
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sum_fp64(a[0], b[0]);
    out_val[1] = sum_fp64(a[1], b[1]);
}

void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sub_fp64(a[0], b[0]);
    out_val[1] = sub_fp64(a[1], b[1]);
}

void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = mul_fp64(a[0], b[0]);
    out_val[1] = mul_fp64(a[1], b[1]);
}

void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = div_fp64(a[0], b[0]);
    out_val[1] = div_fp64(a[1], b[1]);
}

void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
  vec2 range[2];
  vec2_sub_fp64(y, x, range);
  vec2 portion[2];
  portion[0] = range[0] * a;
  portion[1] = range[1] * a;
  vec2_sum_fp64(x, portion, out_val);
}

vec2 vec2_length_fp64(vec2 x[2]) {
  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}

void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
  vec2 length = vec2_length_fp64(x);
  vec2 length_vec2[2];
  length_vec2[0] = length;
  length_vec2[1] = length;

  vec2_div_fp64(x, length_vec2, out_val);
}

vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
  vec2 diff[2];
  vec2_sub_fp64(x, y, diff);
  return vec2_length_fp64(diff);
}

vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
  vec2 v[2];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);

  return sum_fp64(v[0], v[1]);
}

// vec3 functions
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

vec2 vec3_length_fp64(vec2 x[3]) {
  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
    mul_fp64(x[2], x[2])));
}

vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
  vec2 diff[3];
  vec3_sub_fp64(x, y, diff);
  return vec3_length_fp64(diff);
}

// vec4 functions
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
  out_val[0].x = a[0];
  out_val[0].y = 0.0;

  out_val[1].x = a[1];
  out_val[1].y = 0.0;

  out_val[2].x = a[2];
  out_val[2].y = 0.0;

  out_val[3].x = a[3];
  out_val[3].y = 0.0;
}

void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
  out_val[0] = mul_fp64(a[0], b);
  out_val[1] = mul_fp64(a[1], b);
  out_val[2] = mul_fp64(a[2], b);
  out_val[3] = mul_fp64(a[3], b);
}

void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
  for (int i = 0; i < 4; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
  vec2 v[4];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);
  v[2] = mul_fp64(a[2], b[2]);
  v[3] = mul_fp64(a[3], b[3]);

  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}

void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
  vec2 tmp[4];

  for (int i = 0; i < 4; i++)
  {
    for (int j = 0; j < 4; j++)
    {
      tmp[j] = b[j + i * 4];
    }
    vec4_dot_fp64(a, tmp, out_val[i]);
  }
}
`;var $t={ONE:1};function mt(){return $t}var Ge={name:"fp64-arithmetic",vs:me,getUniforms:mt,fp64ify:te,fp64LowPart:Me,fp64ifyMatrix4:Oe},_e={name:"fp64",vs:Le,dependencies:[Ge],fp64ify:te,fp64LowPart:Me,fp64ifyMatrix4:Oe};var Kr=1/Math.PI*180,Yr=1/180*Math.PI,Lt={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...Lt}};var g=globalThis.mathgl.config;function Ce(e){return Array.isArray(e)||ArrayBuffer.isView(e)&&!(e instanceof DataView)}function P(e,t,_){let r=g.EPSILON;_&&(g.EPSILON=_);try{if(e===t)return!0;if(Ce(e)&&Ce(t)){if(e.length!==t.length)return!1;for(let i=0;i<e.length;++i)if(!P(e[i],t[i]))return!1;return!0}return e&&e.equals?e.equals(t):t&&t.equals?t.equals(e):typeof e=="number"&&typeof t=="number"?Math.abs(e-t)<=g.EPSILON*Math.max(1,Math.abs(e),Math.abs(t)):!1}finally{g.EPSILON=r}}var x=typeof Float32Array<"u"?Float32Array:Array,Fe=Math.random;function re(e){return e>=0?Math.round(e):e%.5===0?Math.floor(e):Math.round(e)}var zr=Math.PI/180;var ie={};ge(ie,{add:()=>i_,angle:()=>h_,bezier:()=>d_,ceil:()=>s_,clone:()=>e_,copy:()=>__,create:()=>et,cross:()=>E_,dist:()=>H_,distance:()=>st,div:()=>b_,divide:()=>it,dot:()=>Be,equals:()=>g_,exactEquals:()=>U_,floor:()=>o_,forEach:()=>W_,fromValues:()=>t_,hermite:()=>N_,inverse:()=>c_,len:()=>X_,length:()=>tt,lerp:()=>p_,max:()=>R_,min:()=>a_,mul:()=>y_,multiply:()=>rt,negate:()=>f_,normalize:()=>n_,random:()=>I_,rotateX:()=>F_,rotateY:()=>P_,rotateZ:()=>B_,round:()=>l_,scale:()=>T_,scaleAndAdd:()=>A_,set:()=>r_,slerp:()=>S_,sqrDist:()=>V_,sqrLen:()=>u_,squaredDistance:()=>ot,squaredLength:()=>at,str:()=>v_,sub:()=>x_,subtract:()=>_t,transformMat3:()=>O_,transformMat4:()=>M_,transformQuat:()=>C_,zero:()=>D_});function et(){let e=new x(3);return x!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function e_(e){let t=new x(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function tt(e){let t=e[0],_=e[1],r=e[2];return Math.sqrt(t*t+_*_+r*r)}function t_(e,t,_){let r=new x(3);return r[0]=e,r[1]=t,r[2]=_,r}function __(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function r_(e,t,_,r){return e[0]=t,e[1]=_,e[2]=r,e}function i_(e,t,_){return e[0]=t[0]+_[0],e[1]=t[1]+_[1],e[2]=t[2]+_[2],e}function _t(e,t,_){return e[0]=t[0]-_[0],e[1]=t[1]-_[1],e[2]=t[2]-_[2],e}function rt(e,t,_){return e[0]=t[0]*_[0],e[1]=t[1]*_[1],e[2]=t[2]*_[2],e}function it(e,t,_){return e[0]=t[0]/_[0],e[1]=t[1]/_[1],e[2]=t[2]/_[2],e}function s_(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e}function o_(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e}function a_(e,t,_){return e[0]=Math.min(t[0],_[0]),e[1]=Math.min(t[1],_[1]),e[2]=Math.min(t[2],_[2]),e}function R_(e,t,_){return e[0]=Math.max(t[0],_[0]),e[1]=Math.max(t[1],_[1]),e[2]=Math.max(t[2],_[2]),e}function l_(e,t){return e[0]=re(t[0]),e[1]=re(t[1]),e[2]=re(t[2]),e}function T_(e,t,_){return e[0]=t[0]*_,e[1]=t[1]*_,e[2]=t[2]*_,e}function A_(e,t,_,r){return e[0]=t[0]+_[0]*r,e[1]=t[1]+_[1]*r,e[2]=t[2]+_[2]*r,e}function st(e,t){let _=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(_*_+r*r+i*i)}function ot(e,t){let _=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return _*_+r*r+i*i}function at(e){let t=e[0],_=e[1],r=e[2];return t*t+_*_+r*r}function f_(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e}function c_(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function n_(e,t){let _=t[0],r=t[1],i=t[2],s=_*_+r*r+i*i;return s>0&&(s=1/Math.sqrt(s)),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e}function Be(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function E_(e,t,_){let r=t[0],i=t[1],s=t[2],o=_[0],a=_[1],R=_[2];return e[0]=i*R-s*a,e[1]=s*o-r*R,e[2]=r*a-i*o,e}function p_(e,t,_,r){let i=t[0],s=t[1],o=t[2];return e[0]=i+r*(_[0]-i),e[1]=s+r*(_[1]-s),e[2]=o+r*(_[2]-o),e}function S_(e,t,_,r){let i=Math.acos(Math.min(Math.max(Be(t,_),-1),1)),s=Math.sin(i),o=Math.sin((1-r)*i)/s,a=Math.sin(r*i)/s;return e[0]=o*t[0]+a*_[0],e[1]=o*t[1]+a*_[1],e[2]=o*t[2]+a*_[2],e}function N_(e,t,_,r,i,s){let o=s*s,a=o*(2*s-3)+1,R=o*(s-2)+s,l=o*(s-1),T=o*(3-2*s);return e[0]=t[0]*a+_[0]*R+r[0]*l+i[0]*T,e[1]=t[1]*a+_[1]*R+r[1]*l+i[1]*T,e[2]=t[2]*a+_[2]*R+r[2]*l+i[2]*T,e}function d_(e,t,_,r,i,s){let o=1-s,a=o*o,R=s*s,l=a*o,T=3*s*a,A=3*R*o,f=R*s;return e[0]=t[0]*l+_[0]*T+r[0]*A+i[0]*f,e[1]=t[1]*l+_[1]*T+r[1]*A+i[1]*f,e[2]=t[2]*l+_[2]*T+r[2]*A+i[2]*f,e}function I_(e,t){t=t===void 0?1:t;let _=Fe()*2*Math.PI,r=Fe()*2-1,i=Math.sqrt(1-r*r)*t;return e[0]=Math.cos(_)*i,e[1]=Math.sin(_)*i,e[2]=r*t,e}function M_(e,t,_){let r=t[0],i=t[1],s=t[2],o=_[3]*r+_[7]*i+_[11]*s+_[15];return o=o||1,e[0]=(_[0]*r+_[4]*i+_[8]*s+_[12])/o,e[1]=(_[1]*r+_[5]*i+_[9]*s+_[13])/o,e[2]=(_[2]*r+_[6]*i+_[10]*s+_[14])/o,e}function O_(e,t,_){let r=t[0],i=t[1],s=t[2];return e[0]=r*_[0]+i*_[3]+s*_[6],e[1]=r*_[1]+i*_[4]+s*_[7],e[2]=r*_[2]+i*_[5]+s*_[8],e}function C_(e,t,_){let r=_[0],i=_[1],s=_[2],o=_[3],a=t[0],R=t[1],l=t[2],T=i*l-s*R,A=s*a-r*l,f=r*R-i*a,c=i*f-s*A,S=s*T-r*f,J=r*A-i*T,N=o*2;return T*=N,A*=N,f*=N,c*=2,S*=2,J*=2,e[0]=a+T+c,e[1]=R+A+S,e[2]=l+f+J,e}function F_(e,t,_,r){let i=[],s=[];return i[0]=t[0]-_[0],i[1]=t[1]-_[1],i[2]=t[2]-_[2],s[0]=i[0],s[1]=i[1]*Math.cos(r)-i[2]*Math.sin(r),s[2]=i[1]*Math.sin(r)+i[2]*Math.cos(r),e[0]=s[0]+_[0],e[1]=s[1]+_[1],e[2]=s[2]+_[2],e}function P_(e,t,_,r){let i=[],s=[];return i[0]=t[0]-_[0],i[1]=t[1]-_[1],i[2]=t[2]-_[2],s[0]=i[2]*Math.sin(r)+i[0]*Math.cos(r),s[1]=i[1],s[2]=i[2]*Math.cos(r)-i[0]*Math.sin(r),e[0]=s[0]+_[0],e[1]=s[1]+_[1],e[2]=s[2]+_[2],e}function B_(e,t,_,r){let i=[],s=[];return i[0]=t[0]-_[0],i[1]=t[1]-_[1],i[2]=t[2]-_[2],s[0]=i[0]*Math.cos(r)-i[1]*Math.sin(r),s[1]=i[0]*Math.sin(r)+i[1]*Math.cos(r),s[2]=i[2],e[0]=s[0]+_[0],e[1]=s[1]+_[1],e[2]=s[2]+_[2],e}function h_(e,t){let _=e[0],r=e[1],i=e[2],s=t[0],o=t[1],a=t[2],R=Math.sqrt((_*_+r*r+i*i)*(s*s+o*o+a*a)),l=R&&Be(e,t)/R;return Math.acos(Math.min(Math.max(l,-1),1))}function D_(e){return e[0]=0,e[1]=0,e[2]=0,e}function v_(e){return"vec3(".concat(e[0],", ").concat(e[1],", ").concat(e[2],")")}function U_(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function g_(e,t){let _=e[0],r=e[1],i=e[2],s=t[0],o=t[1],a=t[2];return Math.abs(_-s)<=1e-6*Math.max(1,Math.abs(_),Math.abs(s))&&Math.abs(r-o)<=1e-6*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(i-a)<=1e-6*Math.max(1,Math.abs(i),Math.abs(a))}var x_=_t,y_=rt,b_=it,H_=st,V_=ot,X_=tt,u_=at,W_=function(){let e=et();return function(t,_,r,i,s,o){let a,R;for(_||(_=3),r||(r=0),i?R=Math.min(i*_+r,t.length):R=t.length,a=r;a<R;a+=_)e[0]=t[a],e[1]=t[a+1],e[2]=t[a+2],s(e,e,o),t[a]=e[0],t[a+1]=e[1],t[a+2]=e[2];return t}}();var se=E(p(),1);var Rt=`
const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);

uniform vec2 project_uViewProjectionMatrixFP64[16];

// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {

#if defined(NVIDIA_FP64_WORKAROUND)
  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
  out_val[1] = sum_fp64(PI_FP64,
    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
  return;
}

void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
  vec2 pos_fp64[2];
  mercatorProject_fp64(position_fp64, pos_fp64);
  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);

  return;
}

void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
  vec4 position64xy = vec4(
    position.x, position64xyLow.x,
    position.y, position64xyLow.y);

  project_position_fp64(position64xy, out_val);
}

vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
  vec2 vertex_pos_clipspace[4];
  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,
    vertex_pos_clipspace);
  return vec4(
    vertex_pos_clipspace[0].x,
    vertex_pos_clipspace[1].x,
    vertex_pos_clipspace[2].x,
    vertex_pos_clipspace[3].x
    );
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
  // This is the local offset to the instance position
  vec2 offset64[4];
  vec4_fp64(vec4(offset, 0.0), offset64);

  float z = project_size(position.z);

  // Apply web mercator projection (depends on coordinate system imn use)
  vec2 projectedPosition64xy[2];
  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);

  vec2 commonPosition64[4];
  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
  commonPosition64[3] = vec2(1.0, 0.0);

  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);

  return project_common_position_to_clipspace_fp64(commonPosition64);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64xyLow, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(
    position, position64xyLow, offset, commonPosition
  );
}
`;var{fp64ify:k_,fp64ifyMatrix4:w_}=_e,oe={name:"project64",dependencies:[se.project,_e],vs:Rt,getUniforms:Y_},K_=(0,se._memoize)(j_);function Y_(e){if(e&&"viewport"in e){let{viewProjectionMatrix:t,scale:_}=e.viewport;return K_({viewProjectionMatrix:t,scale:_})}return{}}function j_({viewProjectionMatrix:e,scale:t}){let _=w_(e),r=k_(t);return{project_uViewProjectionMatrixFP64:_,project64_uViewProjectionMatrix:_,project64_uScale:r}}var he=class extends y.LayerExtension{getShaders(){let{coordinateSystem:t}=this.props;if(t!==y.COORDINATE_SYSTEM.LNGLAT&&t!==y.COORDINATE_SYSTEM.DEFAULT)throw new Error("fp64: coordinateSystem must be LNGLAT");return{modules:[oe]}}},b=he;(()=>{he.extensionName="Fp64Extension"})();var H=E(p(),1);var lt={inject:{"vs:#decl":`
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,"vs:#main-end":`
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,"fs:#decl":`
uniform float dashAlignMode;
uniform float capType;
uniform bool dashGapPickable;
in vec2 vDashArray;
in float vDashOffset;
`,"fs:#main-start":`
  float solidLength = vDashArray.x;
  float gapLength = vDashArray.y;
  float unitLength = solidLength + gapLength;

  float offset;

  if (unitLength > 0.0) {
    if (dashAlignMode == 0.0) {
      offset = vDashOffset;
    } else {
      unitLength = vPathLength / round(vPathLength / unitLength);
      offset = solidLength / 2.0;
    }

    float unitOffset = mod(vPathPosition.y + offset, unitLength);

    if (gapLength > 0.0 && unitOffset > solidLength) {
      if (capType <= 0.5) {
        if (!(dashGapPickable && bool(picking.isActive))) {
          discard;
        }
      } else {
        // caps are rounded, test the distance to solid ends
        float distToEnd = length(vec2(
          min(unitOffset - solidLength, unitLength - unitOffset),
          vPathPosition.x
        ));
        if (distToEnd > 1.0) {
          if (!(dashGapPickable && bool(picking.isActive))) {
            discard;
          }
        }
      }
    }
  }
`}},Tt={inject:{"vs:#decl":`
in float instanceOffsets;
`,"vs:DECKGL_FILTER_SIZE":`
  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
  size *= offsetWidth;
`,"vs:#main-end":`
  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
  float offsetDir = sign(instanceOffsets);
  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
  vPathPosition.y *= offsetWidth;
  vPathLength *= offsetWidth;
`,"fs:#main-start":`
  float isInside;
  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
  if (isInside == 0.0) {
    discard;
  }
`}};var z_={getDashArray:{type:"accessor",value:[0,0]},getOffset:{type:"accessor",value:0},dashJustified:!1,dashGapPickable:!1},ae=class extends H.LayerExtension{constructor({dash:t=!1,offset:_=!1,highPrecisionDash:r=!1}={}){super({dash:t||r,offset:_,highPrecisionDash:r})}isEnabled(t){return"pathTesselator"in t.state}getShaders(t){if(!t.isEnabled(this))return null;let _={};return t.opts.dash&&(_=(0,H._mergeShaders)(_,lt)),t.opts.offset&&(_=(0,H._mergeShaders)(_,Tt)),_}initializeState(t,_){let r=this.getAttributeManager();!r||!_.isEnabled(this)||(_.opts.dash&&r.addInstanced({instanceDashArrays:{size:2,accessor:"getDashArray"},instanceDashOffsets:_.opts.highPrecisionDash?{size:1,accessor:"getPath",transform:_.getDashOffsets.bind(this)}:{size:1,update:i=>{i.constant=!0,i.value=[0]}}}),_.opts.offset&&r.addInstanced({instanceOffsets:{size:1,accessor:"getOffset"}}))}updateState(t,_){if(!_.isEnabled(this))return;let r={};_.opts.dash&&(r.dashAlignMode=this.props.dashJustified?1:0,r.dashGapPickable=Boolean(this.props.dashGapPickable)),this.state.model?.setUniforms(r)}getDashOffsets(t){let _=[0],r=this.props.positionFormat==="XY"?2:3,i=Array.isArray(t[0]),s=i?t.length:t.length/r,o,a;for(let R=0;R<s-1;R++)o=i?t[R]:t.slice(R*r,R*r+r),o=this.projectPosition(o),R>0&&(_[R]=_[R-1]+ie.dist(a,o)),a=o;return _}},V=ae;(()=>{ae.defaultProps=z_})(),(()=>{ae.extensionName="PathStyleExtension"})();var ft=E(p(),1);var X=E(p(),1),Z_=`
#ifdef NON_INSTANCED_MODEL
  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames
  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales
  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets
#else
  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames
  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales
  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets
#endif

in vec4 FILL_PATTERN_FRAME_ATTRIB;
in float FILL_PATTERN_SCALE_ATTRIB;
in vec2 FILL_PATTERN_OFFSET_ATTRIB;

uniform bool fill_patternEnabled;
uniform vec2 fill_patternTextureSize;

out vec2 fill_uv;
out vec4 fill_patternBounds;
out vec4 fill_patternPlacement;
`,q_=`
uniform bool fill_patternEnabled;
uniform bool fill_patternMask;
uniform sampler2D fill_patternTexture;
uniform vec2 fill_uvCoordinateOrigin;
uniform vec2 fill_uvCoordinateOrigin64Low;

in vec4 fill_patternBounds;
in vec4 fill_patternPlacement;
in vec2 fill_uv;

const float FILL_UV_SCALE = 512.0 / 40000000.0;
`,Q_={"vs:DECKGL_FILTER_GL_POSITION":`
    fill_uv = geometry.position.xy;
  `,"vs:DECKGL_FILTER_COLOR":`
    if (fill_patternEnabled) {
      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);
      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;
      fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;
    }
  `,"fs:DECKGL_FILTER_COLOR":`
    if (fill_patternEnabled) {
      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;
      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);

      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;

      vec4 patternColor = texture(fill_patternTexture, texCoords);
      color.a *= patternColor.a;
      if (!fill_patternMask) {
        color.rgb = patternColor.rgb;
      }
    }
  `};function J_(e,t){if(!e)return{};if("fillPatternTexture"in e){let{fillPatternTexture:_}=e;return{fill_patternTexture:_,fill_patternTextureSize:[_.width,_.height]}}if("viewport"in e){let{fillPatternMask:_=!0,fillPatternEnabled:r=!0}=e,{project_uCommonOrigin:i}=t,s=[(0,X.fp64LowPart)(i[0]),(0,X.fp64LowPart)(i[1])];return{fill_uvCoordinateOrigin:i.slice(0,2),fill_uvCoordinateOrigin64Low:s,fill_patternMask:_,fill_patternEnabled:r}}return{}}var At={name:"fill-pattern",vs:Z_,fs:q_,inject:Q_,dependencies:[X.project],getUniforms:J_};var $_={fillPatternEnabled:!0,fillPatternAtlas:{type:"image",value:null,async:!0,parameters:{minFilter:"linear"}},fillPatternMapping:{type:"object",value:{},async:!0},fillPatternMask:!0,getFillPattern:{type:"accessor",value:e=>e.pattern},getFillPatternScale:{type:"accessor",value:1},getFillPatternOffset:{type:"accessor",value:[0,0]}},Re=class extends ft.LayerExtension{constructor({pattern:t=!1}={}){super({pattern:t})}isEnabled(t){return t.getAttributeManager()!==null&&!("pathTesselator"in t.state)}getShaders(t){return t.isEnabled(this)?{modules:[t.opts.pattern&&At].filter(Boolean)}:null}initializeState(t,_){if(!_.isEnabled(this))return;let r=this.getAttributeManager();_.opts.pattern&&r.add({fillPatternFrames:{size:4,accessor:"getFillPattern",transform:_.getPatternFrame.bind(this),shaderAttributes:{fillPatternFrames:{divisor:0},instanceFillPatternFrames:{divisor:1}}},fillPatternScales:{size:1,accessor:"getFillPatternScale",defaultValue:1,shaderAttributes:{fillPatternScales:{divisor:0},instanceFillPatternScales:{divisor:1}}},fillPatternOffsets:{size:2,accessor:"getFillPatternOffset",shaderAttributes:{fillPatternOffsets:{divisor:0},instanceFillPatternOffsets:{divisor:1}}}}),this.setState({emptyTexture:this.context.device.createTexture({data:new Uint8Array(4),width:1,height:1})})}updateState({props:t,oldProps:_},r){r.isEnabled(this)&&t.fillPatternMapping&&t.fillPatternMapping!==_.fillPatternMapping&&this.getAttributeManager().invalidate("getFillPattern")}draw(t,_){if(!_.isEnabled(this))return;let{fillPatternAtlas:r}=this.props;this.setModuleParameters({fillPatternTexture:r||this.state.emptyTexture})}finalizeState(){this.state.emptyTexture?.delete()}getPatternFrame(t){let{fillPatternMapping:_}=this.getCurrentLayer().props,r=_&&_[t];return r?[r.x,r.y,r.width,r.height]:[0,0,0,0]}},u=Re;(()=>{Re.defaultProps=$_})(),(()=>{Re.extensionName="FillStyleExtension"})();var ct=E(p(),1),m_={clipBounds:[0,0,1,1],clipByInstance:void 0},nt=`
uniform vec4 clip_bounds;

bool clip_isInBounds(vec2 position) {
  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];
}
`,L_={name:"clip-vs",vs:nt},G_={"vs:#decl":`
out float clip_isVisible;
`,"vs:DECKGL_FILTER_GL_POSITION":`
  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`,"fs:#decl":`
in float clip_isVisible;
`,"fs:DECKGL_FILTER_COLOR":`
  if (clip_isVisible < 0.5) discard;
`},er={name:"clip-fs",fs:nt},tr={"vs:#decl":`
out vec2 clip_commonPosition;
`,"vs:DECKGL_FILTER_GL_POSITION":`
  clip_commonPosition = geometry.position.xy;
`,"fs:#decl":`
in vec2 clip_commonPosition;
`,"fs:DECKGL_FILTER_COLOR":`
  if (!clip_isInBounds(clip_commonPosition)) discard;
`},le=class extends ct.LayerExtension{getShaders(){let t="instancePositions"in this.getAttributeManager().attributes;return this.props.clipByInstance!==void 0&&(t=Boolean(this.props.clipByInstance)),this.state.clipByInstance=t,t?{modules:[L_],inject:G_}:{modules:[er],inject:tr}}draw({uniforms:t}){let{clipBounds:_}=this.props;if(this.state.clipByInstance)t.clip_bounds=_;else{let r=this.projectPosition([_[0],_[1],0]),i=this.projectPosition([_[2],_[3],0]);t.clip_bounds=[Math.min(r[0],i[0]),Math.min(r[1],i[1]),Math.max(r[0],i[0]),Math.max(r[1],i[1])]}}},W=le;(()=>{le.defaultProps=m_})(),(()=>{le.extensionName="ClipExtension"})();var It=E(p(),1);var Et=E(p(),1),_r=`
#ifdef NON_INSTANCED_MODEL
in float collisionPriorities;
#else
in float instanceCollisionPriorities;
#endif

uniform sampler2D collision_texture;
uniform bool collision_sort;
uniform bool collision_enabled;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision_enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project_uViewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`,rr={"vs:#decl":`
  float collision_fade = 1.0;
`,"vs:DECKGL_FILTER_GL_POSITION":`
  if (collision_sort) {
    #ifdef NON_INSTANCED_MODEL
    float collisionPriority = collisionPriorities;
    #else
    float collisionPriority = instanceCollisionPriorities;
    #endif
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision_enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `,"vs:DECKGL_FILTER_COLOR":`
  color.a *= collision_fade;
  `},ir=(e,t)=>{if(!e||!("dummyCollisionMap"in e))return{};let{collisionFBO:_,drawToCollisionMap:r,dummyCollisionMap:i}=e;return{collision_sort:Boolean(r),collision_texture:!r&&_?_.colorAttachments[0]:i}},pt={name:"collision",dependencies:[Et.project],vs:_r,inject:rr,getUniforms:ir};var dt=E(p(),1);var St=E(p(),1),k=class extends St._LayersPass{renderCollisionMap(t,_){let i=[0,0,0,0];return this.device.withParametersWebGL({scissorTest:!0,scissor:[1,1,t.width-2*1,t.height-2*1],blend:!1,depthTest:!0,depthRange:[0,1]},()=>this.render({..._,clearColor:i,target:t,pass:"collision"}))}getModuleParameters(){return{drawToCollisionMap:!0,picking:{isActive:1,isAttribute:!1},lightSources:{}}}};var De=E(p(),1);var Nt=E(p(),1),w=class extends Nt._LayersPass{constructor(t,_){super(t,_);let{mapSize:r=2048}=_;this.maskMap=t.createTexture({format:"rgba8unorm",width:r,height:r,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),this.fbo=t.createFramebuffer({id:"maskmap",width:r,height:r,colorAttachments:[this.maskMap]})}render(t){let _=[!1,!1,!1,!1];_[t.channel]=!0;let r=[255,255,255,255];return this.device.withParametersWebGL({blend:!0,blendFunc:[n.ZERO,n.ONE],blendEquation:n.FUNC_SUBTRACT,colorMask:_,depthTest:!1},()=>super.render({...t,clearColor:r,target:this.fbo,pass:"mask"}))}shouldDrawLayer(t){return t.props.operation.includes("mask")}delete(){this.fbo.delete(),this.maskMap.delete()}};var Te=E(p(),1);function B(e,t){let _=[1/0,1/0,-1/0,-1/0];for(let r of e){let i=r.getBounds();if(i){let s=r.projectPosition(i[0],{viewport:t,autoOffset:!1}),o=r.projectPosition(i[1],{viewport:t,autoOffset:!1});_[0]=Math.min(_[0],s[0]),_[1]=Math.min(_[1],s[1]),_[2]=Math.max(_[2],o[0]),_[3]=Math.max(_[3],o[1])}}return Number.isFinite(_[0])?_:null}var sr=2048;function h(e){let{bounds:t,viewport:_,border:r=0}=e,{isGeospatial:i}=_;if(t[2]<=t[0]||t[3]<=t[1])return null;let s=_.unprojectPosition([(t[0]+t[2])/2,(t[1]+t[3])/2,0]),{width:o,height:a,zoom:R}=e;if(R===void 0){o=o-r*2,a=a-r*2;let l=Math.min(o/(t[2]-t[0]),a/(t[3]-t[1]));R=Math.min(Math.log2(l),20)}else if(!o||!a){let l=2**R;o=Math.round(Math.abs(t[2]-t[0])*l),a=Math.round(Math.abs(t[3]-t[1])*l);let T=sr-r*2;if(o>T||a>T){let A=T/Math.max(o,a);o=Math.round(o*A),a=Math.round(a*A),R+=Math.log2(A)}}return i?new Te.WebMercatorViewport({id:_.id,x:r,y:r,width:o,height:a,longitude:s[0],latitude:s[1],zoom:R,orthographic:!0}):new Te.OrthographicViewport({id:_.id,x:r,y:r,width:o,height:a,target:s,zoom:R,flipY:!1})}function or(e,t){let _;if(t&&t.length===2){let[s,o]=t,a=e.getBounds({z:s}),R=e.getBounds({z:o});_=[Math.min(a[0],R[0]),Math.min(a[1],R[1]),Math.max(a[2],R[2]),Math.max(a[3],R[3])]}else _=e.getBounds();let r=e.projectPosition(_.slice(0,2)),i=e.projectPosition(_.slice(2,4));return[r[0],r[1],i[0],i[1]]}function D(e,t,_){if(!e)return[0,0,1,1];let r=or(t,_),i=ar(r);return e[2]-e[0]<=i[2]-i[0]&&e[3]-e[1]<=i[3]-i[1]?e:[Math.max(e[0],i[0]),Math.max(e[1],i[1]),Math.min(e[2],i[2]),Math.min(e[3],i[3])]}function ar(e){let t=e[2]-e[0],_=e[3]-e[1],r=(e[0]+e[2])/2,i=(e[1]+e[3])/2;return[r-t,i-_,r+t,i+_]}var C=class{constructor(){this.id="mask-effect",this.props=null,this.useInPicking=!0,this.order=0,this.channels=[],this.masks=null}preRender(t,{layers:_,layerFilter:r,viewports:i,onViewportActive:s,views:o,isPicking:a}){let R=!1;if(this.dummyMaskMap||(this.dummyMaskMap=t.createTexture({width:1,height:1})),a)return{didRender:R};let l=_.filter(c=>c.props.visible&&c.props.operation.includes("mask"));if(l.length===0)return this.masks=null,this.channels.length=0,{didRender:R};this.masks={},this.maskPass||(this.maskPass=new w(t,{id:"default-mask"}),this.maskMap=this.maskPass.maskMap);let T=this._sortMaskChannels(l),A=i[0],f=!this.lastViewport||!this.lastViewport.equals(A);if(A.resolution!==void 0)return De.log.warn("MaskExtension is not supported in GlobeView")(),{didRender:R};for(let c in T){let S=this._renderChannel(T[c],{layerFilter:r,onViewportActive:s,views:o,viewport:A,viewportChanged:f});R||=S}return{didRender:R}}_renderChannel(t,{layerFilter:_,onViewportActive:r,views:i,viewport:s,viewportChanged:o}){let a=!1,R=this.channels[t.index];if(!R)return a;let l=t===R||t.layers.length!==R.layers.length||t.layers.some((T,A)=>T!==R.layers[A]||T.props.transitions)||t.layerBounds.some((T,A)=>T!==R.layerBounds[A]);if(t.bounds=R.bounds,t.maskBounds=R.maskBounds,this.channels[t.index]=t,l||o){this.lastViewport=s;let T=B(t.layers,s);if(t.bounds=T&&D(T,s),l||!P(t.bounds,R.bounds)){let{maskPass:A,maskMap:f}=this,c=T&&h({bounds:t.bounds,viewport:s,width:f.width,height:f.height,border:1});t.maskBounds=c?c.getBounds():[0,0,1,1],A.render({pass:"mask",channel:t.index,layers:t.layers,layerFilter:_,viewports:c?[c]:[],onViewportActive:r,views:i,moduleParameters:{devicePixelRatio:1}}),a=!0}}return this.masks[t.id]={index:t.index,bounds:t.maskBounds,coordinateOrigin:t.coordinateOrigin,coordinateSystem:t.coordinateSystem},a}_sortMaskChannels(t){let _={},r=0;for(let i of t){let{id:s}=i.root,o=_[s];if(!o){if(++r>4){De.log.warn("Too many mask layers. The max supported is 4")();continue}o={id:s,index:this.channels.findIndex(a=>a?.id===s),layers:[],layerBounds:[],coordinateOrigin:i.root.props.coordinateOrigin,coordinateSystem:i.root.props.coordinateSystem},_[s]=o}o.layers.push(i),o.layerBounds.push(i.getBounds())}for(let i=0;i<4;i++){let s=this.channels[i];(!s||!(s.id in _))&&(this.channels[i]=null)}for(let i in _){let s=_[i];s.index<0&&(s.index=this.channels.findIndex(o=>!o),this.channels[s.index]=s)}return _}getModuleParameters(){return{maskMap:this.masks?this.maskMap:this.dummyMaskMap,maskChannels:this.masks}}cleanup(){this.dummyMaskMap&&(this.dummyMaskMap.delete(),this.dummyMaskMap=void 0),this.maskPass&&(this.maskPass.delete(),this.maskPass=void 0,this.maskMap=void 0),this.lastViewport=void 0,this.masks=null,this.channels.length=0}};var ve=2,K=class{constructor(){this.id="collision-filter-effect",this.props=null,this.useInPicking=!0,this.order=1,this.channels={},this.collisionFBOs={}}preRender(t,{effects:_,layers:r,layerFilter:i,viewports:s,onViewportActive:o,views:a,isPicking:R,preRenderStats:l={}}){if(this.dummyCollisionMap||(this.dummyCollisionMap=t.createTexture({width:1,height:1})),R)return;let T=r.filter(({props:{visible:N,collisionEnabled:Ie}})=>N&&Ie);if(T.length===0){this.channels={};return}this.collisionFilterPass||(this.collisionFilterPass=new k(t,{id:"default-collision-filter"}));let A=_?.filter(N=>N.constructor===C),f=l["mask-effect"]?.didRender,c=this._groupByCollisionGroup(t,T),S=s[0],J=!this.lastViewport||!this.lastViewport.equals(S)||f;for(let N in c){let Ie=this.collisionFBOs[N],Ut=c[N],[gt,xt]=t.canvasContext.getPixelSize();Ie.resize({width:gt/ve,height:xt/ve}),this._render(Ut,{effects:A,layerFilter:i,onViewportActive:o,views:a,viewport:S,viewportChanged:J})}}_render(t,{effects:_,layerFilter:r,onViewportActive:i,views:s,viewport:o,viewportChanged:a}){let{collisionGroup:R}=t,l=this.channels[R];if(!l)return;let T=a||t===l||!(0,dt._deepEqual)(l.layers,t.layers,1)||t.layerBounds.some((A,f)=>!P(A,l.layerBounds[f]))||t.allLayersLoaded!==l.allLayersLoaded||t.layers.some(A=>A.props.transitions);if(this.channels[R]=t,T){this.lastViewport=o;let A=this.collisionFBOs[R];this.collisionFilterPass.renderCollisionMap(A,{pass:"collision-filter",isPicking:!0,layers:t.layers,effects:_,layerFilter:r,viewports:o?[o]:[],onViewportActive:i,views:s,moduleParameters:{dummyCollisionMap:this.dummyCollisionMap,devicePixelRatio:A.device.canvasContext.getDevicePixelRatio()/ve}})}}_groupByCollisionGroup(t,_){let r={};for(let i of _){let{collisionGroup:s}=i.props,o=r[s];o||(o={collisionGroup:s,layers:[],layerBounds:[],allLayersLoaded:!0},r[s]=o),o.layers.push(i),o.layerBounds.push(i.getBounds()),i.isLoaded||(o.allLayersLoaded=!1)}for(let i of Object.keys(r))this.collisionFBOs[i]||this.createFBO(t,i),this.channels[i]||(this.channels[i]=r[i]);for(let i of Object.keys(this.collisionFBOs))r[i]||this.destroyFBO(i);return r}getModuleParameters(t){let{collisionGroup:_}=t.props,{collisionFBOs:r,dummyCollisionMap:i}=this;return{collisionFBO:r[_],dummyCollisionMap:i}}cleanup(){this.dummyCollisionMap&&(this.dummyCollisionMap.delete(),this.dummyCollisionMap=void 0),this.channels={};for(let t of Object.keys(this.collisionFBOs))this.destroyFBO(t);this.collisionFBOs={},this.lastViewport=void 0}createFBO(t,_){let{width:r,height:i}=t.gl.canvas,s=t.createTexture({format:"rgba8unorm",width:r,height:i,sampler:{minFilter:"nearest",magFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),o=t.createTexture({format:"depth16unorm",width:r,height:i,mipmaps:!1,dataFormat:6402,type:5125});this.collisionFBOs[_]=t.createFramebuffer({id:`collision-${_}`,width:r,height:i,colorAttachments:[s],depthStencilAttachment:o})}destroyFBO(t){let _=this.collisionFBOs[t];_.colorAttachments[0]?.destroy(),_.depthStencilAttachment?.destroy(),_.destroy(),delete this.collisionFBOs[t]}};var Rr={getCollisionPriority:{type:"accessor",value:0},collisionEnabled:!0,collisionGroup:{type:"string",value:"default"},collisionTestProps:{}},Ae=class extends It.LayerExtension{getShaders(){return{modules:[pt]}}draw({uniforms:t,context:_,moduleParameters:r}){let{collisionEnabled:i}=this.props,{collisionFBO:s,drawToCollisionMap:o}=r,a=i&&Boolean(s);t.collision_enabled=a,o&&(this.props=this.clone(this.props.collisionTestProps).props)}initializeState(t,_){if(this.getAttributeManager()===null)return;this.context.deck?._addDefaultEffect(new K),this.getAttributeManager().add({collisionPriorities:{size:1,accessor:"getCollisionPriority",shaderAttributes:{collisionPriorities:{divisor:0},instanceCollisionPriorities:{divisor:1}}}})}getNeedsPickingBuffer(){return this.props.collisionEnabled}},Y=Ae;(()=>{Ae.defaultProps=Rr})(),(()=>{Ae.extensionName="CollisionFilterExtension"})();var O=E(p(),1);var Mt=E(p(),1),lr=`
uniform vec4 mask_bounds;
uniform bool mask_maskByInstance;
vec2 mask_getCoords(vec4 position) {
  return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);
}
`,Tr=`
uniform sampler2D mask_texture;
uniform int mask_channel;
uniform bool mask_enabled;
uniform bool mask_inverted;
bool mask_isInBounds(vec2 texCoords) {
  if (!mask_enabled) {
    return true;
  }
  vec4 maskColor = texture(mask_texture, texCoords);
  float maskValue = 1.0;
  if (mask_channel == 0) {
    maskValue = maskColor.r;
  } else if (mask_channel == 1) {
    maskValue = maskColor.g;
  } else if (mask_channel == 2) {
    maskValue = maskColor.b;
  } else if (mask_channel == 3) {
    maskValue = maskColor.a;
  }

  if (mask_inverted) {
    return maskValue >= 0.5;
  } else {
    return maskValue < 0.5;
  }
}
`,Ar={"vs:#decl":`
out vec2 mask_texCoords;
`,"vs:#main-end":`
   vec4 mask_common_position;
   if (mask_maskByInstance) {
     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
   } else {
     mask_common_position = geometry.position;
   }
   mask_texCoords = mask_getCoords(mask_common_position);
`,"fs:#decl":`
in vec2 mask_texCoords;
`,"fs:#main-start":`
  if (mask_enabled) {
    bool mask = mask_isInBounds(mask_texCoords);

    // Debug: show extent of render target
    // fragColor = vec4(mask_texCoords, 0.0, 1.0);
    fragColor = texture(mask_texture, mask_texCoords);

    if (!mask) discard;
  }
`},fr=e=>e&&"maskMap"in e?{mask_texture:e.maskMap}:{},Ot={name:"mask",dependencies:[Mt.project],vs:lr,fs:Tr,inject:Ar,getUniforms:fr};var cr={maskId:"",maskByInstance:void 0,maskInverted:!1},fe=class extends O.LayerExtension{initializeState(){this.context.deck?._addDefaultEffect(new C)}getShaders(){let t="instancePositions"in this.getAttributeManager().attributes;return this.props.maskByInstance!==void 0&&(t=Boolean(this.props.maskByInstance)),this.state.maskByInstance=t,{modules:[Ot]}}draw({uniforms:t,context:_,moduleParameters:r}){t.mask_maskByInstance=this.state.maskByInstance;let{maskId:i,maskInverted:s}=this.props,{maskChannels:o}=r,{viewport:a}=_;if(o&&o[i]){let{index:R,bounds:l,coordinateOrigin:T}=o[i],{coordinateSystem:A}=o[i];t.mask_enabled=!0,t.mask_channel=R,t.mask_inverted=s,A===O.COORDINATE_SYSTEM.DEFAULT&&(A=a.isGeospatial?O.COORDINATE_SYSTEM.LNGLAT:O.COORDINATE_SYSTEM.CARTESIAN);let f={modelMatrix:null,fromCoordinateOrigin:T,fromCoordinateSystem:A},c=this.projectPosition([l[0],l[1],0],f),S=this.projectPosition([l[2],l[3],0],f);t.mask_bounds=[c[0],c[1],S[0],S[1]]}else i&&O.log.warn(`Could not find a mask layer with id: ${i}`)(),t.mask_enabled=!1}},j=fe;(()=>{fe.defaultProps=cr})(),(()=>{fe.extensionName="MaskExtension"})();var vt=E(p(),1);var Ne=E(p(),1);var Ft=E(p(),1),I={NONE:0,WRITE_HEIGHT_MAP:1,USE_HEIGHT_MAP:2,USE_COVER:3,USE_COVER_ONLY:4,SKIP:5},Ct=Object.keys(I).map(e=>`const float TERRAIN_MODE_${e} = ${I[e]}.0;`).join(`
`),ce={name:"terrain",dependencies:[Ft.project],inject:{"vs:#decl":`
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
out vec3 commonPos;
${Ct}
    `,"vs:#main-start":`
if (terrain_mode == TERRAIN_MODE_SKIP) {
  gl_Position = vec4(0.0);
  return;
}
`,"vs:DECKGL_FILTER_GL_POSITION":`
commonPos = geometry.position.xyz;
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
  commonPos.z += project_uCommonOrigin.z;
}
if (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
  vec3 anchor = geometry.worldPosition;
  anchor.z = 0.0;
  vec3 anchorCommon = project_position(anchor);
  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;
  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
    float terrainZ = texture(terrain_map, texCoords).r;
    geometry.position.z += terrainZ;
    position = project_common_position_to_clipspace(geometry.position);
  }
}
    `,"fs:#decl":`
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
in vec3 commonPos;
${Ct}
    `,"fs:#main-start":`
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
  return;
}
    `,"fs:DECKGL_FILTER_COLOR":`
if ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {
  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
  vec4 pixel = texture(terrain_map, texCoords);
  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {
    color = pixel;
  } else {
    // pixel is premultiplied
    color = pixel + color * (1.0 - pixel.a);
  }
  return;
}
    `},getUniforms:(e={},t)=>{if("dummyHeightMap"in e){let{drawToTerrainHeightMap:_,heightMap:r,heightMapBounds:i,dummyHeightMap:s,terrainCover:o,useTerrainHeightMap:a,terrainSkipRender:R}=e,{project_uCommonOrigin:l}=t,T=R?I.SKIP:I.NONE,A=s,f=null;if(_)T=I.WRITE_HEIGHT_MAP,f=i;else if(a&&r)T=I.USE_HEIGHT_MAP,A=r,f=i;else if(o){let c=e.picking?.isActive;A=c?o.getPickingFramebuffer():o.getRenderFramebuffer(),c&&(T=I.SKIP),A?(T=T===I.SKIP?I.USE_COVER_ONLY:I.USE_COVER,f=o.bounds):A=s}return{terrain_mode:T,terrain_map:A,terrain_bounds:f?[f[0]-l[0],f[1]-l[1],f[2]-f[0],f[3]-f[1]]:[0,0,0,0]}}return null}};function z(e,t){return e.createFramebuffer({id:t.id,colorAttachments:[e.createTexture({...t.float&&{format:e.info.type==="webgl2"?"rgba32float":"rgba8unorm",type:n.FLOAT},mipmaps:!1,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}})]})}var ne=class{constructor(t){this.isDirty=!0,this.renderViewport=null,this.bounds=null,this.layers=[],this.targetBounds=null,this.targetBoundsCommon=null,this.targetLayer=t,this.tile=Pt(t)}get id(){return this.targetLayer.id}get isActive(){return Boolean(this.targetLayer.getCurrentLayer())}shouldUpdate({targetLayer:t,viewport:_,layers:r,layerNeedsRedraw:i}){t&&(this.targetLayer=t);let s=_?this._updateViewport(_):!1,o=r?this._updateLayers(r):!1;if(i){for(let a of this.layers)if(i[a]){o=!0;break}}return o||s}_updateLayers(t){let _=!1;if(t=this.tile?nr(this.tile,t):t,t.length!==this.layers.length)_=!0;else for(let r=0;r<t.length;r++)if(t[r].id!==this.layers[r]){_=!0;break}return _&&(this.layers=t.map(r=>r.id)),_}_updateViewport(t){let _=this.targetLayer,r=!1;if(this.tile&&"boundingBox"in this.tile){if(!this.targetBounds){r=!0,this.targetBounds=this.tile.boundingBox;let s=t.projectPosition(this.targetBounds[0]),o=t.projectPosition(this.targetBounds[1]);this.targetBoundsCommon=[s[0],s[1],o[0],o[1]]}}else this.targetBounds!==_.getBounds()&&(r=!0,this.targetBounds=_.getBounds(),this.targetBoundsCommon=B([_],t));if(!this.targetBoundsCommon)return!1;let i=Math.ceil(t.zoom+.5);if(this.tile)this.bounds=this.targetBoundsCommon;else{let s=this.renderViewport?.zoom;r=r||i!==s;let o=D(this.targetBoundsCommon,t),a=this.bounds;r=r||!a||o.some((R,l)=>R!==a[l]),this.bounds=o}return r&&(this.renderViewport=h({bounds:this.bounds,zoom:i,viewport:t})),r}getRenderFramebuffer(){return!this.renderViewport||this.layers.length===0?null:(this.fbo||(this.fbo=z(this.targetLayer.context.device,{id:this.id})),this.fbo)}getPickingFramebuffer(){return!this.renderViewport||this.layers.length===0&&!this.targetLayer.props.pickable?null:(this.pickingFbo||(this.pickingFbo=z(this.targetLayer.context.device,{id:`${this.id}-picking`})),this.pickingFbo)}filterLayers(t){return t.filter(({id:_})=>this.layers.includes(_))}delete(){let{fbo:t,pickingFbo:_}=this;t&&(t.colorAttachments[0].destroy(),t.destroy()),_&&(_.colorAttachments[0].destroy(),_.destroy())}};function nr(e,t){return t.filter(_=>{let r=Pt(_);return r?Er(e.boundingBox,r.boundingBox):!0})}function Pt(e){for(;e;){let{tile:t}=e.props;if(t)return t;e=e.parent}return null}function Er(e,t){return e&&t?e[0][0]<t[1][0]&&t[0][0]<e[1][0]&&e[0][1]<t[1][1]&&t[0][1]<e[1][1]:!1}var Bt=E(p(),1),Ee=class extends Bt._LayersPass{getRenderableLayers(t,_){let{layers:r}=_,i=[],s=this._getDrawLayerParams(t,_,!0);for(let o=0;o<r.length;o++){let a=r[o];!a.isComposite&&s[o].shouldDrawLayer&&i.push(a)}return i}renderHeightMap(t,_){let r=t.getRenderFramebuffer(),i=t.renderViewport;!r||!i||(r.resize(i),this.device.withParametersWebGL({clearColor:[0,0,0,0],blend:!0,blendFunc:[n.ONE,n.ONE],blendEquation:n.MAX,depthTest:!1},()=>this.render({..._,target:r,pass:"terrain-height-map",layers:_.layers,viewports:[i],effects:[]})))}renderTerrainCover(t,_){let r=t.getRenderFramebuffer(),i=t.renderViewport;if(!r||!i)return;let s=t.filterLayers(_.layers);r.resize(i),this.device.withParametersWebGL({clearColor:[0,0,0,0],depthTest:!1},()=>this.render({..._,target:r,pass:`terrain-cover-${t.id}`,layers:s,effects:[],viewports:[i]}))}};var ht=E(p(),1),pe=class extends ht._PickLayersPass{constructor(){super(...arguments),this.drawParameters={}}getRenderableLayers(t,_){let{layers:r}=_,i=[];this.drawParameters={},this._resetColorEncoder(_.pickZ);let s=this._getDrawLayerParams(t,_);for(let o=0;o<r.length;o++){let a=r[o];!a.isComposite&&s[o].shouldDrawLayer&&(i.push(a),this.drawParameters[a.id]=s[o].layerParameters)}return i}renderTerrainCover(t,_){let r=t.getPickingFramebuffer(),i=t.renderViewport;if(!r||!i)return;let s=t.filterLayers(_.layers),o=t.targetLayer;o.props.pickable&&s.unshift(o),r.resize(i),this.device.withParametersWebGL({depthTest:!1},()=>this.render({..._,pickingFBO:r,pass:`terrain-cover-picking-${t.id}`,layers:s,effects:[],viewports:[i],cullRect:void 0,deviceRect:i,pickZ:!1}))}getLayerParameters(t,_,r){if(this.drawParameters[t.id])return this.drawParameters[t.id];let i=super.getLayerParameters(t,_,r);return i.blend=!0,i}};var Dt=2048,Z=class{static isSupported(t){return t.isTextureFormatRenderable("rgba32float")}constructor(t){this.renderViewport=null,this.bounds=null,this.layers=[],this.layersBounds=[],this.layersBoundsCommon=null,this.lastViewport=null,this.device=t}getRenderFramebuffer(){return this.renderViewport?(this.fbo||(this.fbo=z(this.device,{id:"height-map",float:!0})),this.fbo):null}shouldUpdate({layers:t,viewport:_}){let r=t.length!==this.layers.length||t.some((s,o)=>s!==this.layers[o]||s.props.transitions||s.getBounds()!==this.layersBounds[o]);r&&(this.layers=t,this.layersBounds=t.map(s=>s.getBounds()),this.layersBoundsCommon=B(t,_));let i=!this.lastViewport||!_.equals(this.lastViewport);if(!this.layersBoundsCommon)this.renderViewport=null;else if(r||i){let s=D(this.layersBoundsCommon,_);if(s[2]<=s[0]||s[3]<=s[1])return this.renderViewport=null,!1;this.bounds=s,this.lastViewport=_;let o=_.scale,a=(s[2]-s[0])*o,R=(s[3]-s[1])*o;return this.renderViewport=a>0||R>0?h({bounds:[_.center[0]-1,_.center[1]-1,_.center[0]+1,_.center[1]+1],zoom:_.zoom,width:Math.min(a,Dt),height:Math.min(R,Dt),viewport:_}):null,!0}return!1}delete(){this.fbo&&(this.fbo.colorAttachments[0].delete(),this.fbo.delete())}};var Se=class{constructor(){this.id="terrain-effect",this.props=null,this.useInPicking=!0,this.isPicking=!1,this.isDrapingEnabled=!1,this.terrainCovers=new Map}initialize(t){this.dummyHeightMap=t.createTexture({width:1,height:1,data:new Uint8Array([0,0,0,0])}),this.terrainPass=new Ee(t,{id:"terrain"}),this.terrainPickingPass=new pe(t,{id:"terrain-picking"}),Z.isSupported(t)?this.heightMap=new Z(t):Ne.log.warn("Terrain offset mode is not supported by this browser")(),(0,Ne.getShaderAssembler)().addDefaultModule(ce)}preRender(t,_){if(!this.dummyHeightMap){this.initialize(t);for(let l of _.layers)l.props.operation.includes("terrain")&&l.setChangeFlags({extensionsChanged:!0})}if(_.pickZ){this.isDrapingEnabled=!1;return}let{viewports:r}=_,i=_.pass.startsWith("picking");this.isPicking=i,this.isDrapingEnabled=!0;let s=r[0],o=(i?this.terrainPickingPass:this.terrainPass).getRenderableLayers(s,_),a=o.filter(l=>l.props.operation.includes("terrain"));if(a.length===0)return;i||o.filter(T=>T.state.terrainDrawMode==="offset").length>0&&this._updateHeightMap(a,s,_);let R=o.filter(l=>l.state.terrainDrawMode==="drape");this._updateTerrainCovers(a,R,s,_)}getModuleParameters(t){let{terrainDrawMode:_}=t.state;return{heightMap:this.heightMap?.getRenderFramebuffer(),heightMapBounds:this.heightMap?.bounds,dummyHeightMap:this.dummyHeightMap,terrainCover:this.isDrapingEnabled?this.terrainCovers.get(t.id):null,useTerrainHeightMap:_==="offset",terrainSkipRender:_==="drape"||!t.props.operation.includes("draw")}}cleanup(){this.dummyHeightMap&&(this.dummyHeightMap.delete(),this.dummyHeightMap=void 0),this.heightMap&&(this.heightMap.delete(),this.heightMap=void 0);for(let t of this.terrainCovers.values())t.delete();this.terrainCovers.clear()}_updateHeightMap(t,_,r){!this.heightMap||!this.heightMap.shouldUpdate({layers:t,viewport:_})||this.terrainPass.renderHeightMap(this.heightMap,{...r,layers:t,moduleParameters:{heightMapBounds:this.heightMap.bounds,dummyHeightMap:this.dummyHeightMap,devicePixelRatio:1,drawToTerrainHeightMap:!0}})}_updateTerrainCovers(t,_,r,i){let s={};for(let o of _)o.state.terrainCoverNeedsRedraw&&(s[o.id]=!0,o.state.terrainCoverNeedsRedraw=!1);for(let o of this.terrainCovers.values())o.isDirty=o.isDirty||o.shouldUpdate({layerNeedsRedraw:s});for(let o of t)this._updateTerrainCover(o,_,r,i);this.isPicking||this._pruneTerrainCovers()}_updateTerrainCover(t,_,r,i){let s=this.isPicking?this.terrainPickingPass:this.terrainPass,o=this.terrainCovers.get(t.id);o||(o=new ne(t),this.terrainCovers.set(t.id,o));try{let a=o.shouldUpdate({targetLayer:t,viewport:r,layers:_});(this.isPicking||o.isDirty||a)&&(s.renderTerrainCover(o,{...i,layers:_,moduleParameters:{dummyHeightMap:this.dummyHeightMap,terrainSkipRender:!1,devicePixelRatio:1}}),this.isPicking||(o.isDirty=!1))}catch(a){t.raiseError(a,`Error rendering terrain cover ${o.id}`)}}_pruneTerrainCovers(){let t=[];for(let[_,r]of this.terrainCovers)r.isActive||t.push(_);for(let _ of t)this.terrainCovers.delete(_)}};var pr={terrainDrawMode:void 0},de=class extends vt.LayerExtension{getShaders(){return{modules:[ce]}}initializeState(){this.context.deck?._addDefaultEffect(new Se)}updateState(t){let{props:_,oldProps:r}=t;if(this.state.terrainDrawMode&&_.terrainDrawMode===r.terrainDrawMode&&_.extruded===r.extruded)return;let{terrainDrawMode:i}=_;if(!i){let s=this.props.extruded,o=this.getAttributeManager()?.attributes,a=o&&"instancePositions"in o;i=s||a?"offset":"drape"}this.setState({terrainDrawMode:i})}onNeedsRedraw(){let t=this.state;t.terrainDrawMode==="drape"&&(t.terrainCoverNeedsRedraw=!0)}},q=de;(()=>{de.defaultProps=pr})(),(()=>{de.extensionName="TerrainExtension"})();return ut(Q);})();
      return __exports__;
      });
