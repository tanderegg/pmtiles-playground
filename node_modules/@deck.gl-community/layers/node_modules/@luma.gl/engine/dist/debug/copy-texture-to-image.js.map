{"version":3,"file":"copy-texture-to-image.js","names":["flipRows","scalePixels","copyTextureToImage","source","options","dataUrl","copyTextureToDataUrl","targetImage","Image","src","arguments","length","undefined","sourceAttachment","targetMaxHeight","Number","MAX_SAFE_INTEGER","data","device","readPixelsToArrayWebGL","width","height","canvas","document","createElement","context","getContext","imageData","createImageData","set","putImageData","toDataURL"],"sources":["../../src/debug/copy-texture-to-image.ts"],"sourcesContent":["// luma.gl, MIT license\nimport {Texture, Framebuffer} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\nimport {flipRows, scalePixels} from './pixel-data-utils';\n\n/**\n * Options for copying texture pixels to image\n * @todo - support gl.readBuffer\n */\nexport type CopyTextureToImageOptions = {\n  sourceAttachment?: number; \n  targetMaxHeight?: number;\n  targetImage?: HTMLImageElement;\n};\n\n/**\n * Reads pixels from a Framebuffer or Texture object into an HTML Image\n * @todo - can we move this to @luma.gl/core?\n * @param source \n * @param options options passed to copyToDataUrl\n * @returns \n */\nexport function copyTextureToImage(\n  source: Texture | Framebuffer,\n  options?: CopyTextureToImageOptions\n): HTMLImageElement {\n\n  const dataUrl = copyTextureToDataUrl(source, options);\n  const targetImage: HTMLImageElement = options?.targetImage || new Image();\n  targetImage.src = dataUrl;\n\n  return targetImage;\n}\n\n/**\n * Reads pixels from a Framebuffer or Texture object to a dataUrl\n * @todo - can we move this to @luma.gl/core?\n * @param source texture or framebuffer to read from\n * @param options \n */\nexport function copyTextureToDataUrl(\n  source: Texture | Framebuffer,\n  options: CopyTextureToImageOptions = {}\n): string {\n  const {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMaxHeight = Number.MAX_SAFE_INTEGER\n  } = options;\n\n  let data = source.device.readPixelsToArrayWebGL(source, {sourceAttachment});\n\n  // Scale down\n  let {width, height} = source;\n  while (height > targetMaxHeight) {\n    ({data, width, height} = scalePixels({data, width, height}));\n  }\n\n  // Flip to top down coordinate system\n  flipRows({data, width, height});\n\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n\n  // Copy the pixels to a 2D canvas\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n\n  return canvas.toDataURL('image/png');\n}\n"],"mappings":"SAGQA,QAAQ,EAAEC,WAAW;AAmB7B,OAAO,SAASC,kBAAkBA,CAChCC,MAA6B,EAC7BC,OAAmC,EACjB;EAElB,MAAMC,OAAO,GAAGC,oBAAoB,CAACH,MAAM,EAAEC,OAAO,CAAC;EACrD,MAAMG,WAA6B,GAAG,CAAAH,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEG,WAAW,KAAI,IAAIC,KAAK,CAAC,CAAC;EACzED,WAAW,CAACE,GAAG,GAAGJ,OAAO;EAEzB,OAAOE,WAAW;AACpB;AAQA,OAAO,SAASD,oBAAoBA,CAClCH,MAA6B,EAErB;EAAA,IADRC,OAAkC,GAAAM,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAEvC,MAAM;IACJG,gBAAgB,QAAuB;IACvCC,eAAe,GAAGC,MAAM,CAACC;EAC3B,CAAC,GAAGZ,OAAO;EAEX,IAAIa,IAAI,GAAGd,MAAM,CAACe,MAAM,CAACC,sBAAsB,CAAChB,MAAM,EAAE;IAACU;EAAgB,CAAC,CAAC;EAG3E,IAAI;IAACO,KAAK;IAAEC;EAAM,CAAC,GAAGlB,MAAM;EAC5B,OAAOkB,MAAM,GAAGP,eAAe,EAAE;IAC/B,CAAC;MAACG,IAAI;MAAEG,KAAK;MAAEC;IAAM,CAAC,GAAGpB,WAAW,CAAC;MAACgB,IAAI;MAAEG,KAAK;MAAEC;IAAM,CAAC,CAAC;EAC7D;EAGArB,QAAQ,CAAC;IAACiB,IAAI;IAAEG,KAAK;IAAEC;EAAM,CAAC,CAAC;EAE/B,MAAMC,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;EAC/CF,MAAM,CAACF,KAAK,GAAGA,KAAK;EACpBE,MAAM,CAACD,MAAM,GAAGA,MAAM;EACtB,MAAMI,OAAO,GAAGH,MAAM,CAACI,UAAU,CAAC,IAAI,CAAC;EAGvC,MAAMC,SAAS,GAAGF,OAAO,CAACG,eAAe,CAACR,KAAK,EAAEC,MAAM,CAAC;EACxDM,SAAS,CAACV,IAAI,CAACY,GAAG,CAACZ,IAAI,CAAC;EACxBQ,OAAO,CAACK,YAAY,CAACH,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;EAErC,OAAOL,MAAM,CAACS,SAAS,CAAC,WAAW,CAAC;AACtC"}