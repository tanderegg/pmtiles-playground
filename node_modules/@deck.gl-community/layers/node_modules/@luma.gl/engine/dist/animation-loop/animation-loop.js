import { luma } from '@luma.gl/core';
import { requestAnimationFrame, cancelAnimationFrame } from '@luma.gl/core';
import { Stats } from '@probe.gl/stats';
let statIdCounter = 0;
const DEFAULT_ANIMATION_LOOP_PROPS = {
  device: null,
  onAddHTML: () => '',
  onInitialize: async () => {
    return null;
  },
  onRender: () => {},
  onFinalize: () => {},
  onError: error => console.error(error),
  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),
  useDevicePixels: true,
  autoResizeViewport: false,
  autoResizeDrawingBuffer: false
};
export class AnimationLoop {
  constructor(props) {
    this.device = null;
    this.canvas = null;
    this.props = void 0;
    this.animationProps = null;
    this.timeline = null;
    this.stats = void 0;
    this.cpuTime = void 0;
    this.gpuTime = void 0;
    this.frameRate = void 0;
    this.display = void 0;
    this.needsRedraw = 'initialized';
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.props = {
      ...DEFAULT_ANIMATION_LOOP_PROPS,
      ...props
    };
    props = this.props;
    if (!props.device) {
      throw new Error('No device provided');
    }
    const {
      useDevicePixels = true
    } = this.props;
    this.stats = props.stats || new Stats({
      id: 'animation-loop-stats'
    });
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');
    this.setProps({
      autoResizeViewport: props.autoResizeViewport,
      autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop();
    this._setDisplay(null);
  }
  delete() {
    this.destroy();
  }
  setNeedsRedraw(reason) {
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }
  setProps(props) {
    if ('autoResizeViewport' in props) {
      this.props.autoResizeViewport = props.autoResizeViewport || false;
    }
    if ('autoResizeDrawingBuffer' in props) {
      this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
    }
    if ('useDevicePixels' in props) {
      this.props.useDevicePixels = props.useDevicePixels || false;
    }
    return this;
  }
  async start() {
    if (this._running) {
      return this;
    }
    this._running = true;
    try {
      let appContext;
      if (!this._initialized) {
        this._initialized = true;
        await this._initDevice();
        this._initialize();
        await this.props.onInitialize(this._getAnimationProps());
      }
      if (!this._running) {
        return null;
      }
      if (appContext !== false) {
        this._cancelAnimationFrame();
        this._requestAnimationFrame();
      }
      return this;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      this.props.onError(error);
      throw error;
    }
  }
  stop() {
    if (this._running) {
      if (this.animationProps) {
        this.props.onFinalize(this.animationProps);
      }
      this._cancelAnimationFrame();
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._running = false;
    }
    return this;
  }
  redraw() {
    var _this$device;
    if ((_this$device = this.device) !== null && _this$device !== void 0 && _this$device.isLost) {
      return this;
    }
    this._beginFrameTimers();
    this._setupFrame();
    this._updateAnimationProps();
    this._renderFrame(this._getAnimationProps());
    this._clearNeedsRedraw();
    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }
    this._endFrameTimers();
    return this;
  }
  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }
  detachTimeline() {
    this.timeline = null;
  }
  waitForRender() {
    this.setNeedsRedraw('waitForRender');
    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise(resolve => {
        this._resolveNextFrame = resolve;
      });
    }
    return this._nextFramePromise;
  }
  async toDataURL() {
    this.setNeedsRedraw('toDataURL');
    await this.waitForRender();
    if (this.canvas instanceof HTMLCanvasElement) {
      return this.canvas.toDataURL();
    }
    throw new Error('OffscreenCanvas');
  }
  _initialize() {
    this._startEventHandling();
    this._initializeAnimationProps();
    this._updateAnimationProps();
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
  }
  _setDisplay(display) {
    if (this.display) {
      this.display.destroy();
      this.display.animationLoop = null;
    }
    if (display) {
      display.animationLoop = this;
    }
    this.display = display;
  }
  _requestAnimationFrame() {
    if (!this._running) {
      return;
    }
    this._animationFrameId = requestAnimationFrame(this._animationFrame.bind(this));
  }
  _cancelAnimationFrame() {
    if (this._animationFrameId === null) {
      return;
    }
    cancelAnimationFrame(this._animationFrameId);
    this._animationFrameId = null;
  }
  _animationFrame() {
    if (!this._running) {
      return;
    }
    this.redraw();
    this._requestAnimationFrame();
  }
  _renderFrame(animationProps) {
    if (this.display) {
      this.display._renderFrame(animationProps);
      return;
    }
    this.props.onRender(this._getAnimationProps());
    this.device.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = false;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
  }
  _initializeAnimationProps() {
    var _this$device2;
    if (!this.device) {
      throw new Error('loop');
    }
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: (_this$device2 = this.device) === null || _this$device2 === void 0 || (_this$device2 = _this$device2.canvasContext) === null || _this$device2 === void 0 ? void 0 : _this$device2.canvas,
      timeline: this.timeline,
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: false,
      width: 1,
      height: 1,
      aspect: 1,
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      _mousePosition: null
    };
  }
  _getAnimationProps() {
    if (!this.animationProps) {
      throw new Error('animationProps');
    }
    return this.animationProps;
  }
  _updateAnimationProps() {
    if (!this.animationProps) {
      return;
    }
    const {
      width,
      height,
      aspect
    } = this._getSizeAndAspect();
    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw('drawing buffer resized');
    }
    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw('drawing buffer aspect changed');
    }
    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }
    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  async _initDevice() {
    var _this$device$canvasCo;
    this.device = await this.props.device;
    if (!this.device) {
      throw new Error('No device provided');
    }
    this.canvas = ((_this$device$canvasCo = this.device.canvasContext) === null || _this$device$canvasCo === void 0 ? void 0 : _this$device$canvasCo.canvas) || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement('div');
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = 'relative';
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.left = '10px';
      div.style.bottom = '10px';
      div.style.width = '300px';
      div.style.background = 'white';
      if (this.canvas instanceof HTMLCanvasElement) {
        wrapperDiv.appendChild(this.canvas);
      }
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);
      if (html) {
        div.innerHTML = html;
      }
    }
  }
  _getSizeAndAspect() {
    var _this$device3, _this$device4;
    if (!this.device) {
      return {
        width: 1,
        height: 1,
        aspect: 1
      };
    }
    const [width, height] = ((_this$device3 = this.device) === null || _this$device3 === void 0 || (_this$device3 = _this$device3.canvasContext) === null || _this$device3 === void 0 ? void 0 : _this$device3.getPixelSize()) || [1, 1];
    let aspect = 1;
    const canvas = (_this$device4 = this.device) === null || _this$device4 === void 0 || (_this$device4 = _this$device4.canvasContext) === null || _this$device4 === void 0 ? void 0 : _this$device4.canvas;
    if (canvas && canvas.clientHeight) {
      aspect = canvas.clientWidth / canvas.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }
    return {
      width,
      height,
      aspect
    };
  }
  _resizeViewport() {
    if (this.props.autoResizeViewport && this.device.gl) {
      this.device.gl.viewport(0, 0, this.device.gl.drawingBufferWidth, this.device.gl.drawingBufferHeight);
    }
  }
  _resizeCanvasDrawingBuffer() {
    if (this.props.autoResizeDrawingBuffer) {
      var _this$device5;
      (_this$device5 = this.device) === null || _this$device5 === void 0 || (_this$device5 = _this$device5.canvasContext) === null || _this$device5 === void 0 ? void 0 : _this$device5.resize({
        useDevicePixels: this.props.useDevicePixels
      });
    }
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();
    this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  _startEventHandling() {
    if (this.canvas) {
      this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));
      this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));
    }
  }
  _onMousemove(event) {
    if (event instanceof MouseEvent) {
      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];
    }
  }
  _onMouseleave(event) {
    this._getAnimationProps()._mousePosition = null;
  }
}
//# sourceMappingURL=animation-loop.js.map