import { Model } from "../model/model.js";
import { getPassthroughFS } from '@luma.gl/shadertools';
const FS_OUTPUT_VARIABLE = 'transform_output';
export class TextureTransform {
  constructor(device, props) {
    this.device = void 0;
    this.model = void 0;
    this.sampler = void 0;
    this.currentIndex = 0;
    this.samplerTextureMap = null;
    this.bindings = [];
    this.resources = {};
    this.device = device;
    this.sampler = device.createSampler({
      addressModeU: 'clamp-to-edge',
      addressModeV: 'clamp-to-edge',
      minFilter: 'nearest',
      magFilter: 'nearest',
      mipmapFilter: 'nearest'
    });
    this.model = new Model(this.device, {
      id: props.id || 'texture-transform-model',
      fs: props.fs || getPassthroughFS({
        version: 300,
        input: props.targetTextureVarying,
        inputChannels: props.targetTextureChannels,
        output: FS_OUTPUT_VARIABLE
      }),
      vertexCount: props.vertexCount,
      ...props
    });
    this._initialize(props);
    Object.seal(this);
  }
  destroy() {}
  delete() {
    this.destroy();
  }
  run(options) {
    const {
      framebuffer
    } = this.bindings[this.currentIndex];
    const renderPass = this.device.beginRenderPass({
      framebuffer,
      ...options
    });
    this.model.draw(renderPass);
    renderPass.end();
  }
  update() {
    console.warn('TextureTransform#update() not implemented');
  }
  getData() {
    let {
      packed = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    throw new Error('getData() not implemented');
  }
  getTargetTexture() {
    const {
      targetTexture
    } = this.bindings[this.currentIndex];
    return targetTexture;
  }
  getFramebuffer() {
    const currentResources = this.bindings[this.currentIndex];
    return currentResources.framebuffer;
  }
  _initialize(props) {
    this._updateBindings(props);
  }
  _updateBindings(props) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);
  }
  _updateBinding(binding, _ref) {
    let {
      sourceBuffers,
      sourceTextures,
      targetTexture
    } = _ref;
    if (!binding) {
      binding = {
        sourceBuffers: {},
        sourceTextures: {},
        targetTexture: null
      };
    }
    Object.assign(binding.sourceTextures, sourceTextures);
    Object.assign(binding.sourceBuffers, sourceBuffers);
    if (targetTexture) {
      binding.targetTexture = targetTexture;
      const {
        width,
        height
      } = targetTexture;
      if (binding.framebuffer) {
        binding.framebuffer.destroy();
      }
      binding.framebuffer = this.device.createFramebuffer({
        id: 'transform-framebuffer',
        width,
        height,
        colorAttachments: [targetTexture]
      });
      binding.framebuffer.resize({
        width,
        height
      });
    }
    return binding;
  }
  _setSourceTextureParameters() {
    const index = this.currentIndex;
    const {
      sourceTextures
    } = this.bindings[index];
    for (const name in sourceTextures) {
      sourceTextures[name].sampler = this.sampler;
    }
  }
}
//# sourceMappingURL=texture-transform.js.map