import { Buffer, assert } from '@luma.gl/core';
import { getPassthroughFS } from '@luma.gl/shadertools';
import { Model } from "../model/model.js";
export class BufferTransform {
  static isSupported(device) {
    return device.features.has('transform-feedback-webgl2');
  }
  constructor(device) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Model.defaultProps;
    this.device = void 0;
    this.model = void 0;
    this.transformFeedback = void 0;
    assert(device.features.has('transform-feedback-webgl2'), 'Device must support transform feedback');
    this.device = device;
    this.model = new Model(this.device, {
      id: props.id || 'buffer-transform-model',
      fs: props.fs || getPassthroughFS({
        version: 300
      }),
      topology: props.topology || 'point-list',
      ...props
    });
    this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      buffers: props.feedbackBuffers
    });
    this.model.setTransformFeedback(this.transformFeedback);
    Object.seal(this);
  }
  destroy() {
    if (this.model) {
      this.model.destroy();
    }
  }
  delete() {
    this.destroy();
  }
  run(options) {
    const renderPass = this.device.beginRenderPass(options);
    this.model.draw(renderPass);
    renderPass.end();
  }
  update() {
    console.warn('TextureTransform#update() not implemented');
  }
  getBuffer(varyingName) {
    return this.transformFeedback.getBuffer(varyingName);
  }
  readAsync(varyingName) {
    const result = this.getBuffer(varyingName);
    if (result instanceof Buffer) {
      return result.readAsync();
    }
    const {
      buffer,
      byteOffset = 0,
      byteLength = buffer.byteLength
    } = result;
    return buffer.readAsync(byteOffset, byteLength);
  }
}
//# sourceMappingURL=buffer-transform.js.map