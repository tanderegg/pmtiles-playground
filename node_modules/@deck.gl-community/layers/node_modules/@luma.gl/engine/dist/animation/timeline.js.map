{"version":3,"file":"timeline.js","names":["channelHandles","animationHandles","Timeline","constructor","time","channels","Map","animations","playing","lastEngineTime","addChannel","props","delay","duration","Number","POSITIVE_INFINITY","rate","repeat","channelId","channel","_setChannelTime","set","removeChannel","delete","animationHandle","animation","detachAnimation","isFinished","get","undefined","getTime","setTime","Math","max","values","animationData","play","pause","reset","attachAnimation","channelHandle","update","engineTime","offsetTime","totalDuration"],"sources":["../../src/animation/timeline.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\n/**\n * Timeline channel properties\n * @param delay = 0;\n * @param duration = Number.POSITIVE_INFINITY;\n * @param rate = 1\n * @param repeat = 1\n */\nexport type ChannelOptions = {\n  delay?: number\n  duration?: number\n  rate?: number\n  repeat?: number\n}\n\nexport type AnimationOptions = {\n  setTime: (time: number) => void\n}\n\n type Channel = {\n  time: number\n  delay: number\n  duration: number\n  rate: number\n  repeat: number\n}\n\ntype Animation = {\n  channel?: number;\n  animation: {\n    setTime: (time: number) => void\n  }\n}\n\nlet channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  time: number = 0;\n  channels = new Map<number, Channel>();\n  animations = new Map<number, Animation>();\n  playing: boolean = false;\n  lastEngineTime: number = -1;\n\n  constructor() {\n  }\n\n  addChannel(props: ChannelOptions): number {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const channelId = channelHandles++;\n    const channel: Channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(channelId, channel);\n\n    return channelId;\n  }\n\n  removeChannel(channelId: number): void {\n    this.channels.delete(channelId);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === channelId) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(channelId: number): boolean {\n    const channel = this.channels.get(channelId);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(channelId?: number): number {\n    if (channelId === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(channelId);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time: number): void {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play(): void {\n    this.playing = true;\n  }\n\n  pause(): void {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset(): void {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation: AnimationOptions, channelHandle?: number): number {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(channelId: number): void {\n    this.animations.delete(channelId);\n  }\n\n  update(engineTime: number): void {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel: Channel, time: number): void {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n"],"mappings":"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"}