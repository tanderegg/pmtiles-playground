import { Buffer, RenderPipeline, UniformStore, getTypedArrayFromDataType } from '@luma.gl/core';
import { log, uid, deepEqual, splitUniformsAndBindings, isNumberArray } from '@luma.gl/core';
import { getAttributeInfosFromLayouts } from '@luma.gl/core';
import { ShaderAssembler, getShaderLayoutFromWGSL } from '@luma.gl/shadertools';
import { ShaderInputs } from "../shader-inputs.js";
import { makeGPUGeometry } from "../geometry/gpu-geometry.js";
import { PipelineFactory } from "../lib/pipeline-factory.js";
import { getDebugTableForShaderLayout } from "../debug/debug-shader-layout.js";
import { debugFramebuffer } from "../debug/debug-framebuffer.js";
const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;
export class Model {
  constructor(device, props) {
    var _this$props$modules, _this$props$modules2, _this$shaderInputs;
    this.device = void 0;
    this.id = void 0;
    this.vs = void 0;
    this.fs = void 0;
    this.pipelineFactory = void 0;
    this.userData = {};
    this.parameters = void 0;
    this.topology = void 0;
    this.bufferLayout = void 0;
    this.vertexCount = void 0;
    this.instanceCount = 0;
    this.indexBuffer = null;
    this.bufferAttributes = {};
    this.constantAttributes = {};
    this.bindings = {};
    this.uniforms = {};
    this.vertexArray = void 0;
    this.transformFeedback = null;
    this.pipeline = void 0;
    this.shaderInputs = void 0;
    this._uniformStore = void 0;
    this._pipelineNeedsUpdate = 'newly created';
    this._attributeInfos = {};
    this._gpuGeometry = null;
    this._getModuleUniforms = void 0;
    this.props = void 0;
    this._lastLogTime = 0;
    this._logOpen = false;
    this._drawCount = 0;
    this.props = {
      ...Model.defaultProps,
      ...props
    };
    props = this.props;
    this.id = props.id || uid('model');
    this.device = device;
    Object.assign(this.userData, props.userData);
    const moduleMap = Object.fromEntries(((_this$props$modules = this.props.modules) === null || _this$props$modules === void 0 ? void 0 : _this$props$modules.map(module => [module.name, module])) || []);
    this.setShaderInputs(props.shaderInputs || new ShaderInputs(moduleMap));
    const isWebGPU = this.device.info.type === 'webgpu';
    if (this.props.source) {
      if (isWebGPU) {
        var _this$props;
        (_this$props = this.props).shaderLayout || (_this$props.shaderLayout = getShaderLayoutFromWGSL(this.props.source));
      }
      this.props.fs = this.props.source;
      this.props.vs = this.props.source;
    }
    if (isWebGPU && typeof this.props.vs !== 'string') {
      var _this$props2;
      (_this$props2 = this.props).shaderLayout || (_this$props2.shaderLayout = getShaderLayoutFromWGSL(this.props.vs.wgsl));
    }
    const platformInfo = getPlatformInfo(device);
    const modules = (((_this$props$modules2 = this.props.modules) === null || _this$props$modules2 === void 0 ? void 0 : _this$props$modules2.length) > 0 ? this.props.modules : (_this$shaderInputs = this.shaderInputs) === null || _this$shaderInputs === void 0 ? void 0 : _this$shaderInputs.getModules()) || [];
    const {
      vs,
      fs,
      getUniforms
    } = this.props.shaderAssembler.assembleShaders({
      platformInfo,
      ...this.props,
      modules
    });
    this.vs = vs;
    this.fs = fs;
    this._getModuleUniforms = getUniforms;
    this.vertexCount = this.props.vertexCount;
    this.instanceCount = this.props.instanceCount;
    this.topology = this.props.topology;
    this.bufferLayout = this.props.bufferLayout;
    this.parameters = this.props.parameters;
    if (props.geometry) {
      this._gpuGeometry = this.setGeometry(props.geometry);
    }
    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
    this.pipeline = this._updatePipeline();
    this.vertexArray = device.createVertexArray({
      renderPipeline: this.pipeline
    });
    if (this._gpuGeometry) {
      this._setGeometryAttributes(this._gpuGeometry);
    }
    if (props.vertexCount) {
      this.setVertexCount(props.vertexCount);
    }
    if (props.instanceCount) {
      this.setInstanceCount(props.instanceCount);
    }
    if (props.indices) {
      throw new Error('Model.props.indices removed. Use props.indexBuffer');
    }
    if (props.indexBuffer) {
      this.setIndexBuffer(props.indexBuffer);
    }
    if (props.attributes) {
      this.setAttributes(props.attributes);
    }
    if (props.constantAttributes) {
      this.setConstantAttributes(props.constantAttributes);
    }
    if (props.bindings) {
      this.setBindings(props.bindings);
    }
    if (props.uniforms) {
      this.setUniforms(props.uniforms);
    }
    if (props.moduleSettings) {
      log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();
      this.updateModuleSettings(props.moduleSettings);
    }
    if (props.transformFeedback) {
      this.transformFeedback = props.transformFeedback;
    }
    Object.seal(this);
  }
  destroy() {
    this.pipelineFactory.release(this.pipeline);
    this._uniformStore.destroy();
  }
  predraw() {
    this.updateShaderInputs();
  }
  draw(renderPass) {
    this.predraw();
    try {
      this._logDrawCallStart();
      this.pipeline = this._updatePipeline();
      this.pipeline.setBindings(this.bindings);
      this.pipeline.setUniforms(this.uniforms);
      const {
        indexBuffer
      } = this.vertexArray;
      const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2) : undefined;
      this.pipeline.draw({
        renderPass,
        vertexArray: this.vertexArray,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount,
        transformFeedback: this.transformFeedback
      });
    } finally {
      this._logDrawCallEnd();
    }
    this._logFramebuffer(renderPass);
  }
  setGeometry(geometry) {
    const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);
    this.setTopology(gpuGeometry.topology || 'triangle-list');
    this.bufferLayout = mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
    if (this.vertexArray) {
      this._setGeometryAttributes(gpuGeometry);
    }
    return gpuGeometry;
  }
  _setGeometryAttributes(gpuGeometry) {
    const attributes = {
      ...gpuGeometry.attributes
    };
    for (const [attributeName] of Object.entries(attributes)) {
      if (!this.pipeline.shaderLayout.attributes.find(layout => layout.name === attributeName) && attributeName !== 'positions') {
        delete attributes[attributeName];
      }
    }
    this.vertexCount = gpuGeometry.vertexCount;
    this.setIndexBuffer(gpuGeometry.indices);
    this.setAttributes(gpuGeometry.attributes, 'ignore-unknown');
    this.setAttributes(attributes);
  }
  setTopology(topology) {
    if (topology !== this.topology) {
      this.topology = topology;
      this._setPipelineNeedsUpdate('topology');
    }
  }
  setBufferLayout(bufferLayout) {
    this.bufferLayout = this._gpuGeometry ? mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
    this._setPipelineNeedsUpdate('bufferLayout');
    this.pipeline = this._updatePipeline();
    this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    });
    if (this._gpuGeometry) {
      this._setGeometryAttributes(this._gpuGeometry);
    }
  }
  setParameters(parameters) {
    if (!deepEqual(parameters, this.parameters, 2)) {
      this.parameters = parameters;
      this._setPipelineNeedsUpdate('parameters');
    }
  }
  setVertexCount(vertexCount) {
    this.vertexCount = vertexCount;
  }
  setInstanceCount(instanceCount) {
    this.instanceCount = instanceCount;
  }
  setShaderInputs(shaderInputs) {
    this.shaderInputs = shaderInputs;
    this._uniformStore = new UniformStore(this.shaderInputs.modules);
    for (const moduleName of Object.keys(this.shaderInputs.modules)) {
      const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
      this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
    }
  }
  setShaderModuleProps(props) {
    const uniforms = this._getModuleUniforms(props);
    const keys = Object.keys(uniforms).filter(k => {
      const uniform = uniforms[k];
      return !isNumberArray(uniform) && typeof uniform !== 'number' && typeof uniform !== 'boolean';
    });
    const bindings = {};
    for (const k of keys) {
      bindings[k] = uniforms[k];
      delete uniforms[k];
    }
  }
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
  }
  updateModuleSettings(props) {
    log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();
    const {
      bindings,
      uniforms
    } = splitUniformsAndBindings(this._getModuleUniforms(props));
    Object.assign(this.bindings, bindings);
    Object.assign(this.uniforms, uniforms);
  }
  setBindings(bindings) {
    Object.assign(this.bindings, bindings);
  }
  setUniforms(uniforms) {
    this.pipeline.setUniforms(uniforms);
    Object.assign(this.uniforms, uniforms);
  }
  setIndexBuffer(indexBuffer) {
    this.vertexArray.setIndexBuffer(indexBuffer);
  }
  setTransformFeedback(transformFeedback) {
    this.transformFeedback = transformFeedback;
  }
  setAttributes(buffers, _option) {
    if (buffers.indices) {
      log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
    }
    for (const [bufferName, buffer] of Object.entries(buffers)) {
      const bufferLayout = this.bufferLayout.find(layout => getAttributeNames(layout).includes(bufferName));
      if (!bufferLayout) {
        log.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
        continue;
      }
      const attributeNames = getAttributeNames(bufferLayout);
      let set = false;
      for (const attributeName of attributeNames) {
        const attributeInfo = this._attributeInfos[attributeName];
        if (attributeInfo) {
          this.vertexArray.setBuffer(attributeInfo.location, buffer);
          set = true;
        }
      }
      if (!set && _option !== 'ignore-unknown') {
        log.warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
      }
    }
  }
  setConstantAttributes(attributes) {
    for (const [attributeName, value] of Object.entries(attributes)) {
      const attributeInfo = this._attributeInfos[attributeName];
      if (attributeInfo) {
        this.vertexArray.setConstant(attributeInfo.location, value);
      } else {
        log.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
      }
    }
  }
  _setPipelineNeedsUpdate(reason) {
    this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;
  }
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      if (this.pipeline) {
        log.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
      }
      this._pipelineNeedsUpdate = false;
      const vs = this.device.createShader({
        id: `${this.id}-vertex`,
        stage: 'vertex',
        source: this.vs
      });
      const fs = this.fs ? this.device.createShader({
        id: `${this.id}-fragment`,
        stage: 'fragment',
        source: this.fs
      }) : null;
      this.pipeline = this.device.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        vs,
        fs
      });
      this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
    }
    return this.pipeline;
  }
  _logDrawCallStart() {
    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
      return;
    }
    this._lastLogTime = Date.now();
    this._logOpen = true;
    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {
      collapsed: log.level <= 2
    })();
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
      log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
      const uniformTable = this.shaderInputs.getDebugTable();
      for (const [name, value] of Object.entries(this.uniforms)) {
        uniformTable[name] = {
          value
        };
      }
      log.table(LOG_DRAW_PRIORITY, uniformTable)();
      const attributeTable = this._getAttributeDebugTable();
      log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
      log.table(LOG_DRAW_PRIORITY, attributeTable)();
      log.groupEnd(LOG_DRAW_PRIORITY)();
      this._logOpen = false;
    }
  }
  _logFramebuffer(renderPass) {
    const debugFramebuffers = log.get('framebuffer');
    this._drawCount++;
    if (!debugFramebuffers || this._drawCount++ > 3 && this._drawCount % 60) {
      return;
    }
    const framebuffer = renderPass.props.framebuffer;
    if (framebuffer) {
      debugFramebuffer(framebuffer, {
        id: framebuffer.id,
        minimap: true
      });
    }
  }
  _getAttributeDebugTable() {
    const table = {};
    for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {
      table[attributeInfo.location] = {
        name,
        type: attributeInfo.shaderType,
        values: this._getBufferOrConstantValues(this.vertexArray.attributes[attributeInfo.location], attributeInfo.bufferDataType)
      };
    }
    if (this.vertexArray.indexBuffer) {
      const {
        indexBuffer
      } = this.vertexArray;
      const values = indexBuffer.indexType === 'uint32' ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
      table.indices = {
        name: 'indices',
        type: indexBuffer.indexType,
        values: values.toString()
      };
    }
    return table;
  }
  _getBufferOrConstantValues(attribute, dataType) {
    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);
    const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;
    return typedArray.toString();
  }
}
Model.defaultProps = {
  ...RenderPipeline.defaultProps,
  source: null,
  vs: null,
  fs: null,
  id: 'unnamed',
  handle: undefined,
  userData: {},
  defines: {},
  modules: [],
  moduleSettings: undefined,
  geometry: null,
  indexBuffer: null,
  attributes: {},
  constantAttributes: {},
  varyings: [],
  shaderInputs: undefined,
  pipelineFactory: undefined,
  transformFeedback: undefined,
  shaderAssembler: ShaderAssembler.getDefaultShaderAssembler()
};
function mergeBufferLayouts(layouts1, layouts2) {
  const layouts = [...layouts1];
  for (const attribute of layouts2) {
    const index = layouts.findIndex(attribute2 => attribute2.name === attribute.name);
    if (index < 0) {
      layouts.push(attribute);
    } else {
      layouts[index] = attribute;
    }
  }
  return layouts;
}
export function getPlatformInfo(device) {
  return {
    type: device.info.type,
    shaderLanguage: device.info.shadingLanguage,
    shaderLanguageVersion: device.info.shadingLanguageVersion,
    gpu: device.info.gpu,
    features: device.features
  };
}
function getAttributeNames(bufferLayout) {
  var _bufferLayout$attribu;
  return bufferLayout.attributes ? (_bufferLayout$attribu = bufferLayout.attributes) === null || _bufferLayout$attribu === void 0 ? void 0 : _bufferLayout$attribu.map(layout => layout.attribute) : [bufferLayout.name];
}
//# sourceMappingURL=model.js.map