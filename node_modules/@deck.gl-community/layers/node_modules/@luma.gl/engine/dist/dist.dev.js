(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['luma'] = factory();
  else root['luma'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    AnimationLoop: () => AnimationLoop,
    AnimationLoopTemplate: () => AnimationLoopTemplate,
    BufferTransform: () => BufferTransform,
    ClipSpace: () => ClipSpace,
    ConeGeometry: () => ConeGeometry,
    CubeGeometry: () => CubeGeometry,
    CylinderGeometry: () => CylinderGeometry,
    GPUGeometry: () => GPUGeometry,
    Geometry: () => Geometry,
    GroupNode: () => GroupNode,
    IcoSphereGeometry: () => IcoSphereGeometry,
    KeyFrames: () => KeyFrames,
    Model: () => Model,
    ModelNode: () => ModelNode,
    PipelineFactory: () => PipelineFactory,
    PlaneGeometry: () => PlaneGeometry,
    ScenegraphNode: () => ScenegraphNode,
    SphereGeometry: () => SphereGeometry,
    TextureTransform: () => TextureTransform,
    Timeline: () => Timeline,
    TruncatedConeGeometry: () => TruncatedConeGeometry,
    _ShaderInputs: () => ShaderInputs,
    makeAnimationLoop: () => makeAnimationLoop
  });

  // src/animation/timeline.ts
  var channelHandles = 1;
  var animationHandles = 1;
  var Timeline = class {
    time = 0;
    channels = /* @__PURE__ */ new Map();
    animations = /* @__PURE__ */ new Map();
    playing = false;
    lastEngineTime = -1;
    constructor() {
    }
    addChannel(props) {
      const {
        delay = 0,
        duration = Number.POSITIVE_INFINITY,
        rate = 1,
        repeat = 1
      } = props;
      const channelId = channelHandles++;
      const channel = {
        time: 0,
        delay,
        duration,
        rate,
        repeat
      };
      this._setChannelTime(channel, this.time);
      this.channels.set(channelId, channel);
      return channelId;
    }
    removeChannel(channelId) {
      this.channels.delete(channelId);
      for (const [animationHandle, animation] of this.animations) {
        if (animation.channel === channelId) {
          this.detachAnimation(animationHandle);
        }
      }
    }
    isFinished(channelId) {
      const channel = this.channels.get(channelId);
      if (channel === void 0) {
        return false;
      }
      return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(channelId) {
      if (channelId === void 0) {
        return this.time;
      }
      const channel = this.channels.get(channelId);
      if (channel === void 0) {
        return -1;
      }
      return channel.time;
    }
    setTime(time) {
      this.time = Math.max(0, time);
      const channels = this.channels.values();
      for (const channel of channels) {
        this._setChannelTime(channel, this.time);
      }
      const animations = this.animations.values();
      for (const animationData of animations) {
        const {
          animation,
          channel
        } = animationData;
        animation.setTime(this.getTime(channel));
      }
    }
    play() {
      this.playing = true;
    }
    pause() {
      this.playing = false;
      this.lastEngineTime = -1;
    }
    reset() {
      this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
      const animationHandle = animationHandles++;
      this.animations.set(animationHandle, {
        animation,
        channel: channelHandle
      });
      animation.setTime(this.getTime(channelHandle));
      return animationHandle;
    }
    detachAnimation(channelId) {
      this.animations.delete(channelId);
    }
    update(engineTime) {
      if (this.playing) {
        if (this.lastEngineTime === -1) {
          this.lastEngineTime = engineTime;
        }
        this.setTime(this.time + (engineTime - this.lastEngineTime));
        this.lastEngineTime = engineTime;
      }
    }
    _setChannelTime(channel, time) {
      const offsetTime = time - channel.delay;
      const totalDuration = channel.duration * channel.repeat;
      if (offsetTime >= totalDuration) {
        channel.time = channel.duration * channel.rate;
      } else {
        channel.time = Math.max(0, offsetTime) % channel.duration;
        channel.time *= channel.rate;
      }
    }
  };

  // src/animation/key-frames.ts
  var KeyFrames = class {
    startIndex = -1;
    endIndex = -1;
    factor = 0;
    times = [];
    values = [];
    _lastTime = -1;
    constructor(keyFrames) {
      this.setKeyFrames(keyFrames);
      this.setTime(0);
    }
    setKeyFrames(keyFrames) {
      const numKeys = keyFrames.length;
      this.times.length = numKeys;
      this.values.length = numKeys;
      for (let i = 0; i < numKeys; ++i) {
        this.times[i] = keyFrames[i][0];
        this.values[i] = keyFrames[i][1];
      }
      this._calculateKeys(this._lastTime);
    }
    setTime(time) {
      time = Math.max(0, time);
      if (time !== this._lastTime) {
        this._calculateKeys(time);
        this._lastTime = time;
      }
    }
    getStartTime() {
      return this.times[this.startIndex];
    }
    getEndTime() {
      return this.times[this.endIndex];
    }
    getStartData() {
      return this.values[this.startIndex];
    }
    getEndData() {
      return this.values[this.endIndex];
    }
    _calculateKeys(time) {
      let index2 = 0;
      const numKeys = this.times.length;
      for (index2 = 0; index2 < numKeys - 2; ++index2) {
        if (this.times[index2 + 1] > time) {
          break;
        }
      }
      this.startIndex = index2;
      this.endIndex = index2 + 1;
      const startTime = this.times[this.startIndex];
      const endTime = this.times[this.endIndex];
      this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);
    }
  };

  // src/animation-loop/animation-loop-template.ts
  var AnimationLoopTemplate = class {
    constructor(animationProps) {
    }
    async onInitialize(animationProps) {
      return null;
    }
  };

  // ../../node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    if (userAgent && userAgent.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/env/dist/lib/globals.js
  var self_ = globalThis.self || globalThis.window || globalThis.global;
  var window_ = globalThis.window || globalThis.self || globalThis.global;
  var document_ = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // ../../node_modules/@probe.gl/env/dist/utils/globals.js
  var VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser2 = isBrowser();

  // ../../node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id, defaultConfig) {
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      this.storage = void 0;
      this.id = void 0;
      this.config = void 0;
      this.storage = getStorage(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad(string) {
    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage(image, message, scale2) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale2 = Math.min(scale2, maxWidth / image.width);
    }
    const width = image.width * scale2;
    const height = image.height * scale2;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message, " %c+"), style];
  }

  // ../../node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR2) {
    COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
    COLOR2[COLOR2["RED"] = 31] = "RED";
    COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
    COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
    COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
    COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
    COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
    COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
    COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string, color, background) {
    if (!isBrowser && typeof string === "string") {
      if (color) {
        const colorCode = getColor(color);
        string = "\x1B[".concat(colorCode, "m").concat(string, "\x1B[39m");
      }
      if (background) {
        const colorCode = getColor(background);
        string = "\x1B[".concat(colorCode + BACKGROUND_INCREMENT, "m").concat(string, "\x1B[49m");
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
      const value = object[key];
      if (typeof value === "function") {
        if (!predefined.find((name2) => key === name2)) {
          object[key] = value.bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/assert.js
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (isBrowser() && window_.performance) {
      var _window$performance, _window$performance$n;
      timestamp = window_ === null || window_ === void 0 ? void 0 : (_window$performance = window_.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_) {
      var _process$hrtime;
      const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  var Log = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      this.id = void 0;
      this.VERSION = VERSION;
      this._startTs = getHiResTimestamp();
      this._deltaTs = getHiResTimestamp();
      this._storage = void 0;
      this.userData = {};
      this.LOG_THROTTLE_TIMEOUT = 0;
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_LOG_CONFIGURATION);
      this.timeStamp("".concat(this.id, " started"));
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.setConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.setConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message) {
      assert(condition, message);
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message = "",
        scale: scale2 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }
      return isBrowser() ? logImageInBrowser({
        image,
        message,
        scale: scale2
      }) : logImageInNode({
        image,
        message,
        scale: scale2
      });
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments({
        logLevel,
        message,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({
          logLevel,
          message,
          args,
          opts
        });
        method = method || opts.method;
        assert(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp();
          } else {
            return noop;
          }
        }
        message = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop;
    }
  };
  Log.VERSION = VERSION;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const {
      logLevel,
      message
    } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
      message = addColor(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode(_ref2) {
    let {
      image,
      message = "",
      scale: scale2 = 1
    } = _ref2;
    console.warn("removed");
    return noop;
  }
  function logImageInBrowser(_ref3) {
    let {
      image,
      message = "",
      scale: scale2 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage(img, message, scale2);
        console.log(...args);
      };
      img.src = image;
      return noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage(image, message, scale2));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage(img, message, scale2));
      img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({
    id: "@probe.gl/log"
  });

  // ../core/src/utils/log.ts
  var log = new Log({
    id: "luma.gl"
  });

  // ../../node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/stats/dist/lib/stat.js
  var Stat = class {
    constructor(name2, type) {
      this.name = void 0;
      this.type = void 0;
      this.sampleSize = 1;
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      this.name = name2;
      this.type = type;
      this.reset();
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp2();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp2() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@probe.gl/stats/dist/lib/stats.js
  var Stats = class {
    constructor(options) {
      this.id = void 0;
      this.stats = {};
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name2) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name2,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const stat of Object.values(this.stats)) {
        stat.reset();
      }
      return this;
    }
    forEach(fn) {
      for (const stat of Object.values(this.stats)) {
        fn(stat);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      const {
        name: name2,
        type
      } = stat;
      let result = this.stats[name2];
      if (!result) {
        if (stat instanceof Stat) {
          result = stat;
        } else {
          result = new Stat(name2, type);
        }
        this.stats[name2] = result;
      }
      return result;
    }
  };

  // ../core/src/utils/stats-manager.ts
  var StatsManager = class {
    stats = /* @__PURE__ */ new Map();
    getStats(name2) {
      return this.get(name2);
    }
    get(name2) {
      if (!this.stats.has(name2)) {
        this.stats.set(name2, new Stats({
          id: name2
        }));
      }
      return this.stats.get(name2);
    }
  };
  var lumaStats = new StatsManager();

  // ../core/src/init.ts
  function initializeLuma() {
    const VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "running from source";
    const STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
    if (globalThis.luma && globalThis.luma.VERSION !== VERSION3) {
      throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${VERSION3}`);
    }
    if (!globalThis.luma) {
      if (isBrowser()) {
        log.log(1, `${VERSION3} - ${STARTUP_MESSAGE}`)();
      }
      globalThis.luma = globalThis.luma || {
        VERSION: VERSION3,
        version: VERSION3,
        log,
        stats: lumaStats
      };
    }
    return VERSION3;
  }
  var VERSION2 = initializeLuma();

  // ../core/src/utils/is-array.ts
  function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView) ? value : null;
  }
  function isNumberArray(value) {
    if (Array.isArray(value)) {
      return value.length === 0 || typeof value[0] === "number" ? value : null;
    }
    return isTypedArray(value);
  }

  // ../core/src/utils/utils.ts
  var uidCounters = {};
  function uid(id = "id") {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
  }

  // ../core/src/adapter/resources/resource.ts
  var Resource = class {
    userData = {};
    destroyed = false;
    allocatedBytes = 0;
    _attachedResources = /* @__PURE__ */ new Set();
    constructor(device, props, defaultProps) {
      if (!device) {
        throw new Error("no device");
      }
      this._device = device;
      this.props = selectivelyMerge(props, defaultProps);
      const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
      this.props.id = id;
      this.id = id;
      this.userData = this.props.userData || {};
      this.addStats();
    }
    destroy() {
      this.destroyResource();
    }
    delete() {
      this.destroy();
      return this;
    }
    toString() {
      return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
    }
    getProps() {
      return this.props;
    }
    attachResource(resource) {
      this._attachedResources.add(resource);
    }
    detachResource(resource) {
      this._attachedResources.delete(resource);
    }
    destroyAttachedResource(resource) {
      if (this._attachedResources.delete(resource)) {
        resource.destroy();
      }
    }
    destroyAttachedResources() {
      for (const resource of Object.values(this._attachedResources)) {
        resource.destroy();
      }
      this._attachedResources = /* @__PURE__ */ new Set();
    }
    destroyResource() {
      this.destroyAttachedResources();
      this.removeStats();
      this.destroyed = true;
    }
    removeStats() {
      const stats = this._device.statsManager.getStats("Resource Counts");
      const name2 = this[Symbol.toStringTag];
      stats.get(`${name2}s Active`).decrementCount();
    }
    trackAllocatedMemory(bytes, name2 = this[Symbol.toStringTag]) {
      const stats = this._device.statsManager.getStats("Resource Counts");
      stats.get("GPU Memory").addCount(bytes);
      stats.get(`${name2} Memory`).addCount(bytes);
      this.allocatedBytes = bytes;
    }
    trackDeallocatedMemory(name2 = this[Symbol.toStringTag]) {
      const stats = this._device.statsManager.getStats("Resource Counts");
      stats.get("GPU Memory").subtractCount(this.allocatedBytes);
      stats.get(`${name2} Memory`).subtractCount(this.allocatedBytes);
      this.allocatedBytes = 0;
    }
    addStats() {
      const stats = this._device.statsManager.getStats("Resource Counts");
      const name2 = this[Symbol.toStringTag];
      stats.get("Resources Created").incrementCount();
      stats.get(`${name2}s Created`).incrementCount();
      stats.get(`${name2}s Active`).incrementCount();
    }
  };
  __publicField(Resource, "defaultProps", {
    id: "undefined",
    handle: void 0,
    userData: void 0
  });
  function selectivelyMerge(props, defaultProps) {
    const mergedProps = {
      ...defaultProps
    };
    for (const key in props) {
      if (props[key] !== void 0) {
        mergedProps[key] = props[key];
      }
    }
    return mergedProps;
  }

  // ../core/src/adapter/resources/buffer.ts
  var _Buffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    constructor(device, props) {
      const deducedProps = {
        ...props
      };
      if ((props.usage || 0) & _Buffer.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          deducedProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          deducedProps.indexType = "uint16";
        }
      }
      super(device, deducedProps, _Buffer.defaultProps);
      this.usage = props.usage || 0;
      this.indexType = deducedProps.indexType;
    }
    readSyncWebGL2(byteOffset, byteLength) {
      throw new Error("not implemented");
    }
    debugData = new ArrayBuffer(0);
    _setDebugData(data, byteOffset, byteLength) {
      const buffer = ArrayBuffer.isView(data) ? data.buffer : data;
      const debugDataLength = Math.min(data ? data.byteLength : byteLength, _Buffer.DEBUG_DATA_MAX_LENGTH);
      if (data === null) {
        this.debugData = new ArrayBuffer(debugDataLength);
      } else if (byteOffset === 0 && byteLength === data.byteLength) {
        this.debugData = buffer.slice(0, debugDataLength);
      } else {
        this.debugData = buffer.slice(byteOffset, byteOffset + debugDataLength);
      }
    }
  };
  var Buffer2 = _Buffer;
  __publicField(Buffer2, "defaultProps", {
    ...Resource.defaultProps,
    usage: 0,
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: false
  });
  __publicField(Buffer2, "MAP_READ", 1);
  __publicField(Buffer2, "MAP_WRITE", 2);
  __publicField(Buffer2, "COPY_SRC", 4);
  __publicField(Buffer2, "COPY_DST", 8);
  __publicField(Buffer2, "INDEX", 16);
  __publicField(Buffer2, "VERTEX", 32);
  __publicField(Buffer2, "UNIFORM", 64);
  __publicField(Buffer2, "STORAGE", 128);
  __publicField(Buffer2, "INDIRECT", 256);
  __publicField(Buffer2, "QUERY_RESOLVE", 512);
  __publicField(Buffer2, "DEBUG_DATA_MAX_LENGTH", 32);

  // ../core/src/adapter/device.ts
  var _Device = class {
    get [Symbol.toStringTag]() {
      return "Device";
    }
    constructor(props) {
      this.props = {
        ..._Device.defaultProps,
        ...props
      };
      this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
    }
    statsManager = lumaStats;
    userData = {};
    _lumaData = {};
    loseDevice() {
      return false;
    }
    getCanvasContext() {
      if (!this.canvasContext) {
        throw new Error("Device has no CanvasContext");
      }
      return this.canvasContext;
    }
    createTexture(props) {
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      return this._createTexture(props);
    }
    createCommandEncoder(props = {}) {
      throw new Error("not implemented");
    }
    readPixelsToArrayWebGL(source, options) {
      throw new Error("not implemented");
    }
    readPixelsToBufferWebGL(source, options) {
      throw new Error("not implemented");
    }
    setParametersWebGL(parameters) {
      throw new Error("not implemented");
    }
    getParametersWebGL(parameters) {
      throw new Error("not implemented");
    }
    withParametersWebGL(parameters, func) {
      throw new Error("not implemented");
    }
    clearWebGL(options) {
      throw new Error("not implemented");
    }
    _getBufferProps(props) {
      if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      const newProps = {
        ...props
      };
      if ((props.usage || 0) & Buffer2.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          newProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          newProps.indexType = "uint16";
        } else {
          log.warn("indices buffer content must be of integer type")();
        }
      }
      return newProps;
    }
  };
  var Device = _Device;
  __publicField(Device, "defaultProps", {
    id: null,
    type: "best-available",
    canvas: null,
    container: null,
    webgl2: true,
    webgl1: true,
    manageState: true,
    width: 800,
    height: 600,
    debug: Boolean(log.get("debug")),
    break: [],
    gl: null
  });
  __publicField(Device, "VERSION", VERSION2);

  // ../core/src/utils/assert.ts
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // ../core/src/lib/luma.ts
  var deviceList = /* @__PURE__ */ new Map();
  var luma = class {
    static registerDevices(deviceClasses) {
      for (const deviceClass of deviceClasses) {
        assert2(deviceClass.type && deviceClass.isSupported && deviceClass.create);
        deviceList.set(deviceClass.type, deviceClass);
      }
    }
    static getAvailableDevices() {
      return Array.from(deviceList).map((Device2) => Device2.type);
    }
    static getSupportedDevices() {
      return Array.from(deviceList).filter((Device2) => Device2.isSupported()).map((Device2) => Device2.type);
    }
    static setDefaultDeviceProps(props) {
      Object.assign(Device.defaultProps, props);
    }
    static async createDevice(props = {}) {
      props = {
        ...Device.defaultProps,
        ...props
      };
      if (props.gl) {
        props.type = "webgl";
      }
      let DeviceClass;
      switch (props.type) {
        case "webgpu":
          DeviceClass = deviceList.get("webgpu");
          if (DeviceClass) {
            return await DeviceClass.create(props);
          }
          break;
        case "webgl":
        case "webgl1":
        case "webgl2":
          DeviceClass = deviceList.get("webgl");
          if (DeviceClass) {
            return await DeviceClass.create(props);
          }
          break;
        case "best-available":
          DeviceClass = deviceList.get("webgpu");
          if (DeviceClass && DeviceClass.isSupported()) {
            return await DeviceClass.create(props);
          }
          DeviceClass = deviceList.get("webgl");
          if (DeviceClass && DeviceClass.isSupported()) {
            return await DeviceClass.create(props);
          }
          break;
      }
      throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
    }
  };
  __publicField(luma, "stats", lumaStats);
  __publicField(luma, "log", log);

  // ../core/src/adapter/resources/render-pipeline.ts
  var _RenderPipeline = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPipeline";
    }
    hash = "";
    constructor(device, props) {
      super(device, props, _RenderPipeline.defaultProps);
      this.shaderLayout = this.props.shaderLayout;
      this.bufferLayout = this.props.bufferLayout || [];
    }
  };
  var RenderPipeline = _RenderPipeline;
  __publicField(RenderPipeline, "defaultProps", {
    ...Resource.defaultProps,
    vs: null,
    vsEntryPoint: "",
    vsConstants: {},
    fs: null,
    fsEntryPoint: "",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    vertexCount: 0,
    instanceCount: 0,
    bindings: {},
    uniforms: {}
  });

  // ../core/src/adapter/type-utils/decode-attribute-type.ts
  function decodeShaderAttributeType(attributeType) {
    const [dataType, components] = TYPE_INFO[attributeType];
    const integer = dataType === "i32" || dataType === "u32";
    const signed = dataType !== "u32";
    const byteLength = TYPE_SIZES[dataType] * components;
    const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
    return {
      dataType,
      components,
      defaultVertexFormat,
      byteLength,
      integer,
      signed
    };
  }
  function getCompatibleVertexFormat(dataType, components) {
    let vertexType;
    switch (dataType) {
      case "f32":
        vertexType = "float32";
        break;
      case "i32":
        vertexType = "sint32";
        break;
      case "u32":
        vertexType = "uint32";
        break;
      case "f16":
        return components <= 2 ? "float16x2" : "float16x4";
    }
    if (components === 1) {
      return vertexType;
    }
    return `${vertexType}x${components}`;
  }
  var TYPE_INFO = {
    f32: ["f32", 1],
    "vec2<f32>": ["f32", 2],
    "vec3<f32>": ["f32", 3],
    "vec4<f32>": ["f32", 4],
    f16: ["f16", 1],
    "vec2<f16>": ["f16", 2],
    "vec3<f16>": ["f16", 3],
    "vec4<f16>": ["f16", 4],
    i32: ["i32", 1],
    "vec2<i32>": ["i32", 2],
    "vec3<i32>": ["i32", 3],
    "vec4<i32>": ["i32", 4],
    u32: ["u32", 1],
    "vec2<u32>": ["u32", 2],
    "vec3<u32>": ["u32", 3],
    "vec4<u32>": ["u32", 4]
  };
  var TYPE_SIZES = {
    f32: 4,
    f16: 2,
    i32: 4,
    u32: 4
  };

  // ../core/src/adapter/type-utils/decode-data-type.ts
  function decodeVertexType(type) {
    const dataType = TYPE_MAP[type];
    const bytes = getDataTypeBytes(dataType);
    const normalized = type.includes("norm");
    const integer = !normalized && !type.startsWith("float");
    const signed = type.startsWith("s");
    return {
      dataType: TYPE_MAP[type],
      byteLength: bytes,
      integer,
      signed,
      normalized
    };
  }
  function getDataTypeBytes(type) {
    const bytes = TYPE_SIZES2[type];
    return bytes;
  }
  var TYPE_MAP = {
    uint8: "uint8",
    sint8: "sint8",
    unorm8: "uint8",
    snorm8: "sint8",
    uint16: "uint16",
    sint16: "sint16",
    unorm16: "uint16",
    snorm16: "sint16",
    float16: "float16",
    float32: "float32",
    uint32: "uint32",
    sint32: "sint32"
  };
  var TYPE_SIZES2 = {
    uint8: 1,
    sint8: 1,
    uint16: 2,
    sint16: 2,
    float16: 2,
    float32: 4,
    uint32: 4,
    sint32: 4
  };

  // ../core/src/adapter/type-utils/decode-vertex-format.ts
  function decodeVertexFormat(format) {
    let webglOnly;
    if (format.endsWith("-webgl")) {
      format.replace("-webgl", "");
      webglOnly = true;
    }
    const [type_, count] = format.split("x");
    const type = type_;
    const components = count ? parseInt(count) : 1;
    const decodedType = decodeVertexType(type);
    const result = {
      type,
      components,
      byteLength: decodedType.byteLength * components,
      integer: decodedType.integer,
      signed: decodedType.signed,
      normalized: decodedType.normalized
    };
    if (webglOnly) {
      result.webglOnly = true;
    }
    return result;
  }

  // ../core/src/adapter/attribute-utils/get-attribute-from-layouts.ts
  function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
    const attributeInfos = {};
    for (const attribute of shaderLayout.attributes) {
      attributeInfos[attribute.name] = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
    }
    return attributeInfos;
  }
  function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name2) {
    const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name2);
    const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name2);
    if (!shaderDeclaration) {
      return null;
    }
    const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);
    const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;
    const vertexFormatInfo = decodeVertexFormat(vertexFormat);
    return {
      attributeName: bufferMapping?.attributeName || shaderDeclaration.name,
      bufferName: bufferMapping?.bufferName || shaderDeclaration.name,
      location: shaderDeclaration.location,
      shaderType: shaderDeclaration.type,
      shaderDataType: attributeTypeInfo.dataType,
      shaderComponents: attributeTypeInfo.components,
      vertexFormat,
      bufferDataType: vertexFormatInfo.type,
      bufferComponents: vertexFormatInfo.components,
      normalized: vertexFormatInfo.normalized,
      integer: attributeTypeInfo.integer,
      stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode,
      byteOffset: bufferMapping?.byteOffset || 0,
      byteStride: bufferMapping?.byteStride || 0
    };
  }
  function getAttributeFromShaderLayout(shaderLayout, name2) {
    const attribute = shaderLayout.attributes.find((attr) => attr.name === name2);
    if (!attribute) {
      log.warn(`shader layout attribute "${name2}" not present in shader`);
    }
    return attribute || null;
  }
  function getAttributeFromBufferLayout(bufferLayouts, name2) {
    checkBufferLayouts(bufferLayouts);
    let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name2);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name2);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    log.warn(`layout for attribute "${name2}" not present in buffer layout`);
    return null;
  }
  function checkBufferLayouts(bufferLayouts) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
        log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
      }
    }
  }
  function getAttributeFromShortHand(bufferLayouts, name2) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.format && bufferLayout.name === name2) {
        return {
          attributeName: bufferLayout.name,
          bufferName: name2,
          stepMode: bufferLayout.stepMode,
          vertexFormat: bufferLayout.format,
          byteOffset: 0,
          byteStride: bufferLayout.byteStride || 0
        };
      }
    }
    return null;
  }
  function getAttributeFromAttributesList(bufferLayouts, name2) {
    for (const bufferLayout of bufferLayouts) {
      let byteStride = bufferLayout.byteStride;
      if (typeof bufferLayout.byteStride !== "number") {
        for (const attributeMapping2 of bufferLayout.attributes || []) {
          const info = decodeVertexFormat(attributeMapping2.format);
          byteStride += info.byteLength;
        }
      }
      const attributeMapping = bufferLayout.attributes?.find((mapping) => mapping.attribute === name2);
      if (attributeMapping) {
        return {
          attributeName: attributeMapping.attribute,
          bufferName: bufferLayout.name,
          stepMode: bufferLayout.stepMode,
          vertexFormat: attributeMapping.format,
          byteOffset: attributeMapping.byteOffset,
          byteStride
        };
      }
    }
    return null;
  }

  // ../core/src/adapter/type-utils/decode-shader-types.ts
  var UNIFORM_FORMATS = {
    "f32": {
      type: "f32",
      components: 1
    },
    "i32": {
      type: "i32",
      components: 1
    },
    "u32": {
      type: "u32",
      components: 1
    },
    "vec2<f32>": {
      type: "f32",
      components: 2
    },
    "vec3<f32>": {
      type: "f32",
      components: 3
    },
    "vec4<f32>": {
      type: "f32",
      components: 4
    },
    "vec2<i32>": {
      type: "i32",
      components: 2
    },
    "vec3<i32>": {
      type: "i32",
      components: 3
    },
    "vec4<i32>": {
      type: "i32",
      components: 4
    },
    "vec2<u32>": {
      type: "u32",
      components: 2
    },
    "vec3<u32>": {
      type: "u32",
      components: 3
    },
    "vec4<u32>": {
      type: "u32",
      components: 4
    },
    "mat2x2<f32>": {
      type: "f32",
      components: 4
    },
    "mat2x3<f32>": {
      type: "f32",
      components: 6
    },
    "mat2x4<f32>": {
      type: "f32",
      components: 8
    },
    "mat3x2<f32>": {
      type: "f32",
      components: 6
    },
    "mat3x3<f32>": {
      type: "f32",
      components: 9
    },
    "mat3x4<f32>": {
      type: "f32",
      components: 12
    },
    "mat4x2<f32>": {
      type: "f32",
      components: 8
    },
    "mat4x3<f32>": {
      type: "f32",
      components: 12
    },
    "mat4x4<f32>": {
      type: "f32",
      components: 16
    }
  };
  function decodeShaderUniformType(format) {
    const decoded = UNIFORM_FORMATS[format];
    assert2(format);
    return decoded;
  }
  function alignTo(size, count) {
    switch (count) {
      case 1:
        return size;
      case 2:
        return size + size % 2;
      default:
        return size + (4 - size % 4) % 4;
    }
  }

  // ../core/src/utils/array-utils-flat.ts
  var arrayBuffer;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }

  // ../core/src/lib/uniforms/uniform-buffer-layout.ts
  var minBufferSize = 1024;
  var UniformBufferLayout = class {
    layout = {};
    constructor(uniformTypes) {
      let size = 0;
      for (const [key, uniformType] of Object.entries(uniformTypes)) {
        const typeAndComponents = decodeShaderUniformType(uniformType);
        const {
          type,
          components: count
        } = typeAndComponents;
        size = alignTo(size, count);
        const offset = size;
        size += count;
        this.layout[key] = {
          type,
          size: count,
          offset
        };
      }
      size += (4 - size % 4) % 4;
      const actualByteLength = size * 4;
      this.byteLength = Math.max(actualByteLength, minBufferSize);
    }
    getData(uniformValues) {
      const bufferSize = Math.max(this.byteLength, minBufferSize);
      const arrayBuffer2 = getScratchArrayBuffer(bufferSize);
      const typedArrays = {
        i32: new Int32Array(arrayBuffer2),
        u32: new Uint32Array(arrayBuffer2),
        f32: new Float32Array(arrayBuffer2),
        f16: new Uint16Array(arrayBuffer2)
      };
      for (const [name2, value] of Object.entries(uniformValues)) {
        const uniformLayout = this.layout[name2];
        if (!uniformLayout) {
          log.warn(`Supplied uniform value ${name2} not present in uniform block layout`)();
          continue;
        }
        const {
          type,
          size,
          offset
        } = uniformLayout;
        const typedArray = typedArrays[type];
        if (size === 1) {
          if (typeof value !== "number" && typeof value !== "boolean") {
            log.warn(`Supplied value for single component uniform ${name2} is not a number: ${value}`)();
            continue;
          }
          typedArray[offset] = Number(value);
        } else {
          const numericArray = isNumberArray(value);
          if (!numericArray) {
            log.warn(`Supplied value for multi component / array uniform ${name2} is not a numeric array: ${value}`)();
            continue;
          }
          typedArray.set(numericArray, offset);
        }
      }
      return new Uint8Array(arrayBuffer2);
    }
    has(name2) {
      return Boolean(this.layout[name2]);
    }
    get(name2) {
      const layout = this.layout[name2];
      return layout;
    }
  };

  // ../core/src/utils/array-equal.ts
  function arrayEqual(a, b, limit = 16) {
    if (a !== b) {
      return false;
    }
    const arrayA = isNumberArray(a);
    if (!arrayA) {
      return false;
    }
    const arrayB = isNumberArray(b);
    if (arrayB && arrayA.length === arrayB.length) {
      for (let i = 0; i < arrayA.length; ++i) {
        if (arrayB[i] !== arrayA[i]) {
          return false;
        }
      }
    }
    return true;
  }
  function arrayCopy(a) {
    const numberArray = isNumberArray(a);
    if (numberArray) {
      return numberArray.slice();
    }
    return a;
  }

  // ../core/src/lib/uniforms/uniform-block.ts
  var UniformBlock = class {
    uniforms = {};
    modifiedUniforms = {};
    modified = true;
    bindingLayout = {};
    needsRedraw = "initialized";
    constructor(props) {
      this.name = props?.name;
      if (props?.name && props?.shaderLayout) {
        const binding = props?.shaderLayout.bindings?.find((binding2) => binding2.type === "uniform" && binding2.name === props?.name);
        if (!binding) {
          throw new Error(props?.name);
        }
        const uniformBlock = binding;
        for (const uniform of uniformBlock.uniforms || []) {
          this.bindingLayout[uniform.name] = uniform;
        }
      }
    }
    setUniforms(uniforms) {
      for (const [key, value] of Object.entries(uniforms)) {
        this._setUniform(key, value);
        if (!this.needsRedraw) {
          this.setNeedsRedraw(`${this.name}.${key}=${value}`);
        }
      }
    }
    setNeedsRedraw(reason) {
      this.needsRedraw = this.needsRedraw || reason;
    }
    getAllUniforms() {
      this.modifiedUniforms = {};
      this.needsRedraw = false;
      return this.uniforms || {};
    }
    _setUniform(key, value) {
      if (arrayEqual(this.uniforms[key], value)) {
        return;
      }
      this.uniforms[key] = arrayCopy(value);
      this.modifiedUniforms[key] = true;
      this.modified = true;
    }
  };

  // ../core/src/lib/uniforms/uniform-store.ts
  var UniformStore = class {
    uniformBlocks = /* @__PURE__ */ new Map();
    uniformBufferLayouts = /* @__PURE__ */ new Map();
    uniformBuffers = /* @__PURE__ */ new Map();
    constructor(blocks) {
      for (const [bufferName, block] of Object.entries(blocks)) {
        const uniformBufferName = bufferName;
        const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});
        this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
        const uniformBlock = new UniformBlock({
          name: bufferName
        });
        uniformBlock.setUniforms(block.defaultUniforms || {});
        this.uniformBlocks.set(uniformBufferName, uniformBlock);
      }
    }
    destroy() {
      for (const uniformBuffer of Object.values(this.uniformBuffers)) {
        uniformBuffer.destroy();
      }
    }
    setUniforms(uniforms) {
      for (const [blockName, uniformValues] of Object.entries(uniforms)) {
        this.uniformBlocks.get(blockName).setUniforms(uniformValues);
      }
      this.updateUniformBuffers();
    }
    getUniformBufferByteLength(uniformBufferName) {
      return this.uniformBufferLayouts.get(uniformBufferName).byteLength;
    }
    getUniformBufferData(uniformBufferName) {
      const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();
      return this.uniformBufferLayouts.get(uniformBufferName).getData(uniformValues);
    }
    createUniformBuffer(device, uniformBufferName, uniforms) {
      if (uniforms) {
        this.setUniforms(uniforms);
      }
      const byteLength = this.getUniformBufferByteLength(uniformBufferName);
      const uniformBuffer = device.createBuffer({
        usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
        byteLength
      });
      const uniformBufferData = this.getUniformBufferData(uniformBufferName);
      uniformBuffer.write(uniformBufferData);
      return uniformBuffer;
    }
    getManagedUniformBuffer(device, uniformBufferName) {
      if (!this.uniformBuffers.get(uniformBufferName)) {
        const byteLength = this.getUniformBufferByteLength(uniformBufferName);
        const uniformBuffer = device.createBuffer({
          usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
          byteLength
        });
        this.uniformBuffers.set(uniformBufferName, uniformBuffer);
      }
      return this.uniformBuffers.get(uniformBufferName);
    }
    updateUniformBuffers() {
      let reason = false;
      for (const uniformBufferName of this.uniformBlocks.keys()) {
        const bufferReason = this.updateUniformBuffer(uniformBufferName);
        reason ||= bufferReason;
      }
      if (reason) {
        log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
      }
      return reason;
    }
    updateUniformBuffer(uniformBufferName) {
      const uniformBlock = this.uniformBlocks.get(uniformBufferName);
      const uniformBuffer = this.uniformBuffers.get(uniformBufferName);
      let reason = false;
      if (uniformBuffer && uniformBlock.needsRedraw) {
        reason ||= uniformBlock.needsRedraw;
        const uniformBufferData = this.getUniformBufferData(uniformBufferName);
        const uniformBuffer2 = this.uniformBuffers.get(uniformBufferName);
        uniformBuffer2.write(uniformBufferData);
        const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();
        log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
      }
      return reason;
    }
  };

  // ../core/src/adapter/type-utils/vertex-format-from-attribute.ts
  function getDataTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return "float32";
      case Uint16Array:
        return "uint16";
      case Uint32Array:
        return "uint32";
      case Uint8Array:
      case Uint8ClampedArray:
        return "uint8";
      case Int8Array:
        return "sint8";
      case Int16Array:
        return "sint16";
      case Int32Array:
        return "sint32";
      default:
        throw new Error(type.constructor.name);
    }
  }
  function getTypedArrayFromDataType(dataType) {
    switch (dataType) {
      case "float32":
        return Float32Array;
      case "uint32":
        return Uint32Array;
      case "sint32":
        return Int32Array;
      case "uint16":
      case "unorm16":
        return Uint16Array;
      case "sint16":
      case "snorm16":
        return Int16Array;
      case "uint8":
      case "unorm8":
        return Uint8Array;
      case "sint8":
      case "snorm8":
        return Int8Array;
      default:
        throw new Error(dataType);
    }
  }
  function getVertexFormatFromAttribute(typedArray, size, normalized) {
    if (!size || size > 4) {
      throw new Error(`size ${size}`);
    }
    const components = size;
    let dataType = getDataTypeFromTypedArray(typedArray);
    if (dataType === "uint8" || dataType === "sint8") {
      if (components === 1 || components === 3) {
        throw new Error(`size: ${size}`);
      }
      if (normalized) {
        dataType = dataType.replace("int", "norm");
      }
      return `${dataType}x${components}`;
    }
    if (dataType === "uint16" || dataType === "sint16") {
      if (components === 1 || components === 3) {
        throw new Error(`size: ${size}`);
      }
      if (normalized) {
        dataType = dataType.replace("int", "norm");
      }
      return `${dataType}x${components}`;
    }
    if (components === 1) {
      return dataType;
    }
    return `${dataType}x${components}`;
  }

  // ../core/src/lib/uniforms/uniform.ts
  function isUniformValue(value) {
    return isNumberArray(value) !== null || typeof value === "number" || typeof value === "boolean";
  }
  function splitUniformsAndBindings(uniforms) {
    const result = {
      bindings: {},
      uniforms: {}
    };
    Object.keys(uniforms).forEach((name2) => {
      const uniform = uniforms[name2];
      if (isUniformValue(uniform)) {
        result.uniforms[name2] = uniform;
      } else {
        result.bindings[name2] = uniform;
      }
    });
    return result;
  }

  // ../core/src/utils/deep-equal.ts
  function deepEqual(a, b, depth) {
    if (a === b) {
      return true;
    }
    if (!depth || !a || !b) {
      return false;
    }
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b[i], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b)) {
      return false;
    }
    if (typeof a === "object" && typeof b === "object") {
      const aKeys = Object.keys(a);
      const bKeys = Object.keys(b);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual(a[key], b[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../core/src/utils/request-animation-frame.ts
  function requestAnimationFrame(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
  }
  function cancelAnimationFrame(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
  }

  // ../core/src/index.ts
  var glsl = (x) => `${x}`;

  // src/animation-loop/animation-loop.ts
  var statIdCounter = 0;
  var DEFAULT_ANIMATION_LOOP_PROPS = {
    device: null,
    onAddHTML: () => "",
    onInitialize: async () => {
      return null;
    },
    onRender: () => {
    },
    onFinalize: () => {
    },
    onError: (error) => console.error(error),
    stats: luma.stats.get(`animation-loop-${statIdCounter++}`),
    useDevicePixels: true,
    autoResizeViewport: false,
    autoResizeDrawingBuffer: false
  };
  var AnimationLoop = class {
    device = null;
    canvas = null;
    animationProps = null;
    timeline = null;
    needsRedraw = "initialized";
    _initialized = false;
    _running = false;
    _animationFrameId = null;
    _nextFramePromise = null;
    _resolveNextFrame = null;
    _cpuStartTime = 0;
    constructor(props) {
      this.props = {
        ...DEFAULT_ANIMATION_LOOP_PROPS,
        ...props
      };
      props = this.props;
      if (!props.device) {
        throw new Error("No device provided");
      }
      const {
        useDevicePixels = true
      } = this.props;
      this.stats = props.stats || new Stats({
        id: "animation-loop-stats"
      });
      this.cpuTime = this.stats.get("CPU Time");
      this.gpuTime = this.stats.get("GPU Time");
      this.frameRate = this.stats.get("Frame Rate");
      this.setProps({
        autoResizeViewport: props.autoResizeViewport,
        autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
        useDevicePixels
      });
      this.start = this.start.bind(this);
      this.stop = this.stop.bind(this);
      this._onMousemove = this._onMousemove.bind(this);
      this._onMouseleave = this._onMouseleave.bind(this);
    }
    destroy() {
      this.stop();
      this._setDisplay(null);
    }
    delete() {
      this.destroy();
    }
    setNeedsRedraw(reason) {
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
    setProps(props) {
      if ("autoResizeViewport" in props) {
        this.props.autoResizeViewport = props.autoResizeViewport || false;
      }
      if ("autoResizeDrawingBuffer" in props) {
        this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
      }
      if ("useDevicePixels" in props) {
        this.props.useDevicePixels = props.useDevicePixels || false;
      }
      return this;
    }
    async start() {
      if (this._running) {
        return this;
      }
      this._running = true;
      try {
        let appContext;
        if (!this._initialized) {
          this._initialized = true;
          await this._initDevice();
          this._initialize();
          await this.props.onInitialize(this._getAnimationProps());
        }
        if (!this._running) {
          return null;
        }
        if (appContext !== false) {
          this._cancelAnimationFrame();
          this._requestAnimationFrame();
        }
        return this;
      } catch (err) {
        const error = err instanceof Error ? err : new Error("Unknown error");
        this.props.onError(error);
        throw error;
      }
    }
    stop() {
      if (this._running) {
        if (this.animationProps) {
          this.props.onFinalize(this.animationProps);
        }
        this._cancelAnimationFrame();
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._running = false;
      }
      return this;
    }
    redraw() {
      if (this.device?.isLost) {
        return this;
      }
      this._beginFrameTimers();
      this._setupFrame();
      this._updateAnimationProps();
      this._renderFrame(this._getAnimationProps());
      this._clearNeedsRedraw();
      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }
      this._endFrameTimers();
      return this;
    }
    attachTimeline(timeline) {
      this.timeline = timeline;
      return this.timeline;
    }
    detachTimeline() {
      this.timeline = null;
    }
    waitForRender() {
      this.setNeedsRedraw("waitForRender");
      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise((resolve) => {
          this._resolveNextFrame = resolve;
        });
      }
      return this._nextFramePromise;
    }
    async toDataURL() {
      this.setNeedsRedraw("toDataURL");
      await this.waitForRender();
      if (this.canvas instanceof HTMLCanvasElement) {
        return this.canvas.toDataURL();
      }
      throw new Error("OffscreenCanvas");
    }
    _initialize() {
      this._startEventHandling();
      this._initializeAnimationProps();
      this._updateAnimationProps();
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
    }
    _setDisplay(display) {
      if (this.display) {
        this.display.destroy();
        this.display.animationLoop = null;
      }
      if (display) {
        display.animationLoop = this;
      }
      this.display = display;
    }
    _requestAnimationFrame() {
      if (!this._running) {
        return;
      }
      this._animationFrameId = requestAnimationFrame(this._animationFrame.bind(this));
    }
    _cancelAnimationFrame() {
      if (this._animationFrameId === null) {
        return;
      }
      cancelAnimationFrame(this._animationFrameId);
      this._animationFrameId = null;
    }
    _animationFrame() {
      if (!this._running) {
        return;
      }
      this.redraw();
      this._requestAnimationFrame();
    }
    _renderFrame(animationProps) {
      if (this.display) {
        this.display._renderFrame(animationProps);
        return;
      }
      this.props.onRender(this._getAnimationProps());
      this.device.submit();
    }
    _clearNeedsRedraw() {
      this.needsRedraw = false;
    }
    _setupFrame() {
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
    }
    _initializeAnimationProps() {
      if (!this.device) {
        throw new Error("loop");
      }
      this.animationProps = {
        animationLoop: this,
        device: this.device,
        canvas: this.device?.canvasContext?.canvas,
        timeline: this.timeline,
        useDevicePixels: this.props.useDevicePixels,
        needsRedraw: false,
        width: 1,
        height: 1,
        aspect: 1,
        time: 0,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        _mousePosition: null
      };
    }
    _getAnimationProps() {
      if (!this.animationProps) {
        throw new Error("animationProps");
      }
      return this.animationProps;
    }
    _updateAnimationProps() {
      if (!this.animationProps) {
        return;
      }
      const {
        width,
        height,
        aspect
      } = this._getSizeAndAspect();
      if (width !== this.animationProps.width || height !== this.animationProps.height) {
        this.setNeedsRedraw("drawing buffer resized");
      }
      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw("drawing buffer aspect changed");
      }
      this.animationProps.width = width;
      this.animationProps.height = height;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw;
      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
      if (this.timeline) {
        this.timeline.update(this.animationProps.engineTime);
      }
      this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
      this.animationProps.tock++;
      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    }
    async _initDevice() {
      this.device = await this.props.device;
      if (!this.device) {
        throw new Error("No device provided");
      }
      this.canvas = this.device.canvasContext?.canvas || null;
    }
    _createInfoDiv() {
      if (this.canvas && this.props.onAddHTML) {
        const wrapperDiv = document.createElement("div");
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = "relative";
        const div = document.createElement("div");
        div.style.position = "absolute";
        div.style.left = "10px";
        div.style.bottom = "10px";
        div.style.width = "300px";
        div.style.background = "white";
        if (this.canvas instanceof HTMLCanvasElement) {
          wrapperDiv.appendChild(this.canvas);
        }
        wrapperDiv.appendChild(div);
        const html = this.props.onAddHTML(div);
        if (html) {
          div.innerHTML = html;
        }
      }
    }
    _getSizeAndAspect() {
      if (!this.device) {
        return {
          width: 1,
          height: 1,
          aspect: 1
        };
      }
      const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];
      let aspect = 1;
      const canvas2 = this.device?.canvasContext?.canvas;
      if (canvas2 && canvas2.clientHeight) {
        aspect = canvas2.clientWidth / canvas2.clientHeight;
      } else if (width > 0 && height > 0) {
        aspect = width / height;
      }
      return {
        width,
        height,
        aspect
      };
    }
    _resizeViewport() {
      if (this.props.autoResizeViewport && this.device.gl) {
        this.device.gl.viewport(0, 0, this.device.gl.drawingBufferWidth, this.device.gl.drawingBufferHeight);
      }
    }
    _resizeCanvasDrawingBuffer() {
      if (this.props.autoResizeDrawingBuffer) {
        this.device?.canvasContext?.resize({
          useDevicePixels: this.props.useDevicePixels
        });
      }
    }
    _beginFrameTimers() {
      this.frameRate.timeEnd();
      this.frameRate.timeStart();
      this.cpuTime.timeStart();
    }
    _endFrameTimers() {
      this.cpuTime.timeEnd();
    }
    _startEventHandling() {
      if (this.canvas) {
        this.canvas.addEventListener("mousemove", this._onMousemove.bind(this));
        this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this));
      }
    }
    _onMousemove(event) {
      if (event instanceof MouseEvent) {
        this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];
      }
    }
    _onMouseleave(event) {
      this._getAnimationProps()._mousePosition = null;
    }
  };

  // src/animation-loop/make-animation-loop.ts
  function makeAnimationLoop(AnimationLoopTemplateCtor, props) {
    let renderLoop = null;
    const device = props?.device || luma.createDevice();
    const animationLoop = new AnimationLoop({
      ...props,
      device,
      async onInitialize(animationProps) {
        renderLoop = new AnimationLoopTemplateCtor(animationProps);
        return await renderLoop?.onInitialize(animationProps);
      },
      onRender: (animationProps) => renderLoop?.onRender(animationProps),
      onFinalize: (animationProps) => renderLoop?.onFinalize(animationProps)
    });
    animationLoop.getInfo = () => {
      return this.AnimationLoopTemplateCtor.info;
    };
    return animationLoop;
  }

  // ../shadertools/src/lib/glsl-utils/highlight.ts
  var glsl2 = (x) => `${x}`;

  // ../shadertools/src/lib/utils/assert.ts
  function assert3(condition, message) {
    if (!condition) {
      throw new Error(message || "shadertools: assertion failed.");
    }
  }

  // ../shadertools/src/lib/filters/prop-types.ts
  var DEFAULT_PROP_VALIDATORS = {
    number: {
      type: "number",
      validate(value, propType) {
        return Number.isFinite(value) && typeof propType === "object" && (propType.max === void 0 || value <= propType.max) && (propType.min === void 0 || value >= propType.min);
      }
    },
    array: {
      type: "array",
      validate(value, propType) {
        return Array.isArray(value) || ArrayBuffer.isView(value);
      }
    }
  };
  function makePropValidators(propTypes) {
    const propValidators = {};
    for (const [name2, propType] of Object.entries(propTypes)) {
      propValidators[name2] = makePropValidator(propType);
    }
    return propValidators;
  }
  function getValidatedProperties(properties, propValidators, errorMessage) {
    const validated = {};
    for (const [key, propsValidator] of Object.entries(propValidators)) {
      if (properties && key in properties && !propsValidator.private) {
        if (propsValidator.validate) {
          assert3(propsValidator.validate(properties[key], propsValidator), `${errorMessage}: invalid ${key}`);
        }
        validated[key] = properties[key];
      } else {
        validated[key] = propsValidator.value;
      }
    }
    return validated;
  }
  function makePropValidator(propType) {
    let type = getTypeOf(propType);
    if (type !== "object") {
      return {
        value: propType,
        ...DEFAULT_PROP_VALIDATORS[type],
        type
      };
    }
    if (typeof propType === "object") {
      if (!propType) {
        return {
          type: "object",
          value: null
        };
      }
      if (propType.type !== void 0) {
        return {
          ...propType,
          ...DEFAULT_PROP_VALIDATORS[propType.type],
          type: propType.type
        };
      }
      if (propType.value === void 0) {
        return {
          type: "object",
          value: propType
        };
      }
      type = getTypeOf(propType.value);
      return {
        ...propType,
        ...DEFAULT_PROP_VALIDATORS[type],
        type
      };
    }
    throw new Error("props");
  }
  function getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return "array";
    }
    return typeof value;
  }

  // ../shadertools/src/module-injectors.ts
  var MODULE_INJECTORS_VS = glsl2`\
#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`;
  var MODULE_INJECTORS_FS = glsl2`\
#ifdef MODULE_MATERIAL
  gl_FragColor = material_filterColor(gl_FragColor);
#endif

#ifdef MODULE_LIGHTING
  gl_FragColor = lighting_filterColor(gl_FragColor);
#endif

#ifdef MODULE_FOG
  gl_FragColor = fog_filterColor(gl_FragColor);
#endif

#ifdef MODULE_PICKING
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`;

  // ../shadertools/src/lib/shader-assembly/shader-injections.ts
  var MODULE_INJECTORS = {
    vertex: MODULE_INJECTORS_VS,
    fragment: MODULE_INJECTORS_FS
  };
  var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
  var fragments = [];
  var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
  function normalizeInjections(injections) {
    const result = {
      vertex: {},
      fragment: {}
    };
    for (const hook in injections) {
      let injection = injections[hook];
      const stage = getHookStage(hook);
      if (typeof injection === "string") {
        injection = {
          order: 0,
          injection
        };
      }
      result[stage][hook] = injection;
    }
    return result;
  }
  function getHookStage(hook) {
    const type = hook.slice(0, 2);
    switch (type) {
      case "vs":
        return "vertex";
      case "fs":
        return "fragment";
      default:
        throw new Error(type);
    }
  }
  function injectShader(source, stage, inject, injectStandardStubs = false) {
    const isVertex = stage === "vertex";
    for (const key in inject) {
      const fragmentData = inject[key];
      fragmentData.sort((a, b) => a.order - b.order);
      fragments.length = fragmentData.length;
      for (let i = 0, len = fragmentData.length; i < len; ++i) {
        fragments[i] = fragmentData[i].injection;
      }
      const fragmentString = `${fragments.join("\n")}
`;
      switch (key) {
        case "vs:#decl":
          if (isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "vs:#main-start":
          if (isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "vs:#main-end":
          if (isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        case "fs:#decl":
          if (!isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "fs:#main-start":
          if (!isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "fs:#main-end":
          if (!isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        default:
          source = source.replace(key, (match) => match + fragmentString);
      }
    }
    source = source.replace(DECLARATION_INJECT_MARKER, "");
    if (injectStandardStubs) {
      source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[stage]);
    }
    return source;
  }

  // ../shadertools/src/lib/shader-module/shader-module-instance.ts
  var index = 1;
  var ShaderModuleInstance = class {
    uniforms = {};
    uniformTypes = {};
    static instantiateModules(modules) {
      return modules.map((module) => {
        if (module instanceof ShaderModuleInstance) {
          return module;
        }
        assert3(typeof module !== "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(module)}' and use it directly.`);
        if (!module.name) {
          console.warn("shader module has no name");
          module.name = `shader-module-${index++}`;
        }
        const moduleObject = new ShaderModuleInstance(module);
        moduleObject.dependencies = ShaderModuleInstance.instantiateModules(module.dependencies || []);
        return moduleObject;
      });
    }
    constructor(props) {
      const {
        name: name2,
        vs,
        fs,
        dependencies = [],
        uniformPropTypes = {},
        getUniforms,
        deprecations = [],
        defines = {},
        inject = {}
      } = props;
      assert3(typeof name2 === "string");
      this.name = name2;
      this.vs = vs;
      this.fs = fs;
      this.getModuleUniforms = getUniforms;
      this.dependencies = ShaderModuleInstance.instantiateModules(dependencies);
      this.deprecations = this._parseDeprecationDefinitions(deprecations);
      this.defines = defines;
      this.injections = normalizeInjections(inject);
      if (uniformPropTypes) {
        this.uniforms = makePropValidators(uniformPropTypes);
      }
    }
    getModuleSource(stage) {
      let moduleSource;
      switch (stage) {
        case "vertex":
          moduleSource = this.vs || "";
          break;
        case "fragment":
          moduleSource = this.fs || "";
          break;
        default:
          assert3(false);
      }
      const moduleName = this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
      return `// ----- MODULE ${this.name} ---------------

#define MODULE_${moduleName}
${moduleSource}

`;
    }
    getUniforms(userProps, uniforms) {
      if (this.getModuleUniforms) {
        return this.getModuleUniforms(userProps, uniforms);
      }
      return getValidatedProperties(userProps, this.uniforms, this.name);
    }
    getDefines() {
      return this.defines;
    }
    checkDeprecations(shaderSource, log2) {
      this.deprecations.forEach((def) => {
        if (def.regex?.test(shaderSource)) {
          if (def.deprecated) {
            log2.deprecated(def.old, def.new)();
          } else {
            log2.removed(def.old, def.new)();
          }
        }
      });
    }
    _parseDeprecationDefinitions(deprecations) {
      deprecations.forEach((def) => {
        switch (def.type) {
          case "function":
            def.regex = new RegExp(`\\b${def.old}\\(`);
            break;
          default:
            def.regex = new RegExp(`${def.type} ${def.old};`);
        }
      });
      return deprecations;
    }
    _defaultGetUniforms(opts = {}) {
      const uniforms = {};
      const propTypes = this.uniforms;
      for (const key in propTypes) {
        const propDef = propTypes[key];
        if (key in opts && !propDef.private) {
          if (propDef.validate) {
            assert3(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);
          }
          uniforms[key] = opts[key];
        } else {
          uniforms[key] = propDef.value;
        }
      }
      return uniforms;
    }
  };

  // ../shadertools/src/lib/shader-assembly/resolve-modules.ts
  function resolveModules(modules) {
    const instances = ShaderModuleInstance.instantiateModules(modules);
    return getShaderDependencies(instances);
  }
  function getShaderDependencies(modules) {
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
      modules,
      level: 0,
      moduleMap,
      moduleDepth
    });
    return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map((name2) => moduleMap[name2]);
  }
  function getDependencyGraph(options) {
    const {
      modules,
      level,
      moduleMap,
      moduleDepth
    } = options;
    if (level >= 5) {
      throw new Error("Possible loop in shader dependency graph");
    }
    for (const module of modules) {
      moduleMap[module.name] = module;
      if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
        moduleDepth[module.name] = level;
      }
    }
    for (const module of modules) {
      if (module.dependencies) {
        getDependencyGraph({
          modules: module.dependencies,
          level: level + 1,
          moduleMap,
          moduleDepth
        });
      }
    }
  }

  // ../shadertools/src/lib/shader-assembly/platform-defines.ts
  function getPlatformShaderDefines(platformInfo) {
    switch (platformInfo?.gpu.toLowerCase()) {
      case "apple":
        return glsl2`\
#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
      case "nvidia":
        return glsl2`\
#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
      case "intel":
        return glsl2`\
#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
      case "amd":
        return glsl2`\
#define AMD_GPU
`;
      default:
        return glsl2`\
#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    }
  }
  function getVersionDefines(platformInfo) {
    let versionDefines = "";
    if (platformInfo.features.has("webgl2")) {
      versionDefines += glsl2`\
# define FEATURE_GLSL_DERIVATIVES
# define FEATURE_GLSL_DRAW_BUFFERS
# define FEATURE_GLSL_FRAG_DEPTH
# define FEATURE_GLSL_TEXTURE_LOD
`;
    }
    if (!platformInfo.features.has("webgl2")) {
      if (platformInfo.features.has("glsl-frag-depth")) {
        versionDefines += glsl2`\

// FEATURE_GLSL_FRAG_DEPTH => gl_FragDepth is available
#ifdef GL_EXT_frag_depth
# extension GL_EXT_frag_depth : enable
# define FEATURE_GLSL_FRAG_DEPTH
# define FRAG_DEPTH
# define gl_FragDepth gl_FragDepthEXT
#endif
`;
      }
      if (platformInfo?.features.has("glsl-derivatives")) {
        versionDefines += glsl2`\

// FEATURE_GLSL_DERIVATIVES => dxdF, dxdY and fwidth are available
#if defined(GL_OES_standard_derivatives) || defined(FEATURE_GLSL_DERIVATIVES)
# extension GL_OES_standard_derivatives : enable
# define FEATURE_GLSL_DERIVATIVES
#endif
`;
      }
      if (platformInfo?.features.has("glsl-frag-data")) {
        versionDefines += glsl2`\

// FEATURE_GLSL_DRAW_BUFFERS => gl_FragData[] is available
#ifdef GL_EXT_draw_buffers
# extension GL_EXT_draw_buffers : require
# define FEATURE_GLSL_DRAW_BUFFERS
#endif
`;
      }
      if (platformInfo?.features.has("glsl-texture-lod")) {
        versionDefines += glsl2`\
// TEXTURE_LOD => texture2DLod etc are available
#ifdef GL_EXT_shader_texture_lod
# extension GL_EXT_shader_texture_lod : enable
# define FEATURE_GLSL_TEXTURE_LOD
# define TEXTURE_LOD
#endif
`;
      }
    }
    return versionDefines;
  }

  // ../shadertools/src/lib/shader-transpiler/transpile-glsl-shader.ts
  function transpileGLSLShader(source, targetGLSLVersion, stage) {
    const sourceGLSLVersion = Number(source.match(/^#version[ \t]+(\d+)/m)?.[1] || 100);
    if (sourceGLSLVersion !== 300) {
      throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
    }
    switch (targetGLSLVersion) {
      case 300:
        switch (stage) {
          case "vertex":
            source = convertShader(source, ES300_VERTEX_REPLACEMENTS);
            return source;
          case "fragment":
            source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
            return source;
          default:
            throw new Error(stage);
        }
      case 100:
        switch (stage) {
          case "vertex":
            source = convertShader(source, ES100_VERTEX_REPLACEMENTS);
            return source;
          case "fragment":
            source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
            source = convertFragmentShaderTo100(source);
            return source;
          default:
            throw new Error(stage);
        }
      default:
        throw new Error(String(targetGLSLVersion));
    }
  }
  var ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
  var ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [makeVariableTextRegExp("attribute"), "in $1"], [makeVariableTextRegExp("varying"), "out $1"]];
  var ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [makeVariableTextRegExp("varying"), "in $1"]];
  var ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
  var ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [makeVariableTextRegExp("in"), "attribute $1"], [makeVariableTextRegExp("out"), "varying $1"]];
  var ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [makeVariableTextRegExp("in"), "varying $1"]];
  var ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
  var ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
  function convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements) {
      source = source.replace(pattern, replacement);
    }
    return source;
  }
  function convertFragmentShaderTo100(source) {
    source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
    const outputMatch = ES300_FRAGMENT_OUTPUT_REGEX.exec(source);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp(`\\b${outputName}\\b`, "g"), ES100_FRAGMENT_OUTPUT_NAME);
    }
    return source;
  }
  function makeVariableTextRegExp(qualifier) {
    return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
  }

  // ../shadertools/src/lib/shader-assembly/shader-hooks.ts
  function getShaderHooks(hookFunctions, hookInjections) {
    let result = "";
    for (const hookName in hookFunctions) {
      const hookFunction = hookFunctions[hookName];
      result += `void ${hookFunction.signature} {
`;
      if (hookFunction.header) {
        result += `  ${hookFunction.header}`;
      }
      if (hookInjections[hookName]) {
        const injections = hookInjections[hookName];
        injections.sort((a, b) => a.order - b.order);
        for (const injection of injections) {
          result += `  ${injection.injection}
`;
        }
      }
      if (hookFunction.footer) {
        result += `  ${hookFunction.footer}`;
      }
      result += "}\n";
    }
    return result;
  }
  function normalizeShaderHooks(hookFunctions) {
    const result = {
      vertex: {},
      fragment: {}
    };
    for (const hookFunction of hookFunctions) {
      let opts;
      let hook;
      if (typeof hookFunction !== "string") {
        opts = hookFunction;
        hook = opts.hook;
      } else {
        opts = {};
        hook = hookFunction;
      }
      hook = hook.trim();
      const [shaderStage, signature] = hook.split(":");
      const name2 = hook.replace(/\(.+/, "");
      const normalizedHook = Object.assign(opts, {
        signature
      });
      switch (shaderStage) {
        case "vs":
          result.vertex[name2] = normalizedHook;
          break;
        case "fs":
          result.fragment[name2] = normalizedHook;
          break;
        default:
          throw new Error(shaderStage);
      }
    }
    return result;
  }

  // ../shadertools/src/lib/glsl-utils/get-shader-info.ts
  function getShaderInfo(source, defaultName) {
    return {
      name: getShaderName(source, defaultName),
      language: "glsl",
      version: getShaderVersion(source)
    };
  }
  function getShaderName(shader, defaultName = "unnamed") {
    const SHADER_NAME_REGEXP = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
  }
  function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words && words.length >= 2 && words[0] === "#version") {
      const parsedVersion = parseInt(words[1], 10);
      if (Number.isFinite(parsedVersion)) {
        version = parsedVersion;
      }
    }
    if (version !== 100 && version !== 300) {
      throw new Error(`Invalid GLSL version ${version}`);
    }
    return version;
  }

  // ../shadertools/src/lib/shader-assembly/assemble-shaders.ts
  var INJECT_SHADER_DECLARATIONS = `

${DECLARATION_INJECT_MARKER}
`;
  var FRAGMENT_SHADER_PROLOGUE = glsl2`\
precision highp float;
`;
  function assembleShaders(options) {
    const {
      vs,
      fs
    } = options;
    const modules = resolveModules(options.modules || []);
    switch (options.platformInfo.shaderLanguage) {
      case "glsl":
        return {
          vs: assembleGLSLShader(options.platformInfo, {
            ...options,
            source: vs,
            stage: "vertex",
            modules
          }),
          fs: assembleGLSLShader(options.platformInfo, {
            ...options,
            source: fs,
            stage: "fragment",
            modules
          }),
          getUniforms: assembleGetUniforms(modules)
        };
      case "wgsl":
        return {
          vs: assembleWGSLShader(options.platformInfo, {
            ...options,
            source: vs,
            stage: "vertex",
            modules
          }),
          fs: assembleWGSLShader(options.platformInfo, {
            ...options,
            source: fs,
            stage: "fragment",
            modules
          }),
          getUniforms: assembleGetUniforms(modules)
        };
    }
  }
  function assembleWGSLShader(platformInfo, options) {
    const {
      source,
      stage,
      modules,
      hookFunctions = [],
      inject = {},
      log: log2
    } = options;
    assert3(typeof source === "string", "shader source must be a string");
    const coreSource = source;
    let assembledSource = "";
    const hookFunctionMap = normalizeShaderHooks(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject) {
      const injection = typeof inject[key] === "string" ? {
        injection: inject[key],
        order: 0
      } : inject[key];
      const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
      if (match) {
        const hash = match[2];
        const name2 = match[3];
        if (hash) {
          if (name2 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    const modulesToInject = platformInfo.type !== "webgpu" ? modules : [];
    for (const module of modulesToInject) {
      if (log2) {
        module.checkDeprecations(coreSource, log2);
      }
      const moduleSource = module.getModuleSource(stage, "wgsl");
      assembledSource += moduleSource;
      const injections = module.injections[stage];
      for (const key in injections) {
        const match = /^(v|f)s:#([\w-]+)$/.exec(key);
        if (match) {
          const name2 = match[2];
          const injectionType = name2 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, stage, declInjections);
    assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, stage, mainInjections);
    return assembledSource;
  }
  function assembleGLSLShader(platformInfo, options) {
    const {
      id,
      source,
      stage,
      language = "glsl",
      modules,
      defines = {},
      hookFunctions = [],
      inject = {},
      prologue = true,
      log: log2
    } = options;
    assert3(typeof source === "string", "shader source must be a string");
    const sourceVersion = language === "glsl" ? getShaderInfo(source).version : -1;
    const targetVersion = platformInfo.shaderLanguageVersion;
    const sourceVersionDirective = sourceVersion === 100 ? "#version 100" : "#version 300 es";
    const sourceLines = source.split("\n");
    const coreSource = sourceLines.slice(1).join("\n");
    const allDefines = {};
    modules.forEach((module) => {
      Object.assign(allDefines, module.getDefines());
    });
    Object.assign(allDefines, defines);
    let assembledSource = "";
    switch (language) {
      case "wgsl":
        break;
      case "glsl":
        assembledSource = prologue ? `${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${getShaderNameDefine({
          id,
          source,
          stage
        })}
${`#define SHADER_TYPE_${stage.toUpperCase()}`}
${getPlatformShaderDefines(platformInfo)}
${getVersionDefines(platformInfo)}
${stage === "fragment" ? FRAGMENT_SHADER_PROLOGUE : ""}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
        break;
    }
    const hookFunctionMap = normalizeShaderHooks(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject) {
      const injection = typeof inject[key] === "string" ? {
        injection: inject[key],
        order: 0
      } : inject[key];
      const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
      if (match) {
        const hash = match[2];
        const name2 = match[3];
        if (hash) {
          if (name2 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    for (const module of modules) {
      if (log2) {
        module.checkDeprecations(coreSource, log2);
      }
      const moduleSource = module.getModuleSource(stage);
      assembledSource += moduleSource;
      const injections = module.injections[stage];
      for (const key in injections) {
        const match = /^(v|f)s:#([\w-]+)$/.exec(key);
        if (match) {
          const name2 = match[2];
          const injectionType = name2 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += "// ----- MAIN SHADER SOURCE -------------------------";
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, stage, declInjections);
    assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, stage, mainInjections);
    if (language === "glsl" && sourceVersion !== targetVersion) {
      assembledSource = transpileGLSLShader(assembledSource, targetVersion, stage);
    }
    return assembledSource.trim();
  }
  function assembleGetUniforms(modules) {
    return function getUniforms(opts) {
      const uniforms = {};
      for (const module of modules) {
        const moduleUniforms = module.getUniforms(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
      return uniforms;
    };
  }
  function getShaderNameDefine(options) {
    const {
      id,
      source,
      stage
    } = options;
    const injectShaderName = id && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? `
#define SHADER_NAME ${id}_${stage}

` : "";
  }
  function getApplicationDefines(defines = {}) {
    let sourceText = "";
    for (const define in defines) {
      const value = defines[define];
      if (value || Number.isFinite(value)) {
        sourceText += `#define ${define.toUpperCase()} ${defines[define]}
`;
      }
    }
    return sourceText;
  }

  // ../shadertools/src/lib/shader-assembly/select-shaders.ts
  function selectShaders(props) {
    if (!props.vs) {
      throw new Error("no vertex shader");
    }
    const vs = getShaderSource(props.platformInfo, props.vs);
    let fs;
    if (props.fs) {
      fs = getShaderSource(props.platformInfo, props.fs);
    }
    return {
      ...props,
      vs,
      fs
    };
  }
  function getShaderSource(platformInfo, shader) {
    if (typeof shader === "string") {
      return shader;
    }
    switch (platformInfo.type) {
      case "webgpu":
        if (shader?.wgsl) {
          return shader.wgsl;
        }
        throw new Error("WebGPU does not support GLSL shaders");
      default:
        if (shader?.glsl) {
          return shader.glsl;
        }
        throw new Error("WebGL does not support WGSL shaders");
    }
  }

  // ../shadertools/src/lib/shader-assembler.ts
  var ShaderAssembler = class {
    _hookFunctions = [];
    _defaultModules = [];
    static getDefaultShaderAssembler() {
      ShaderAssembler.defaultShaderAssembler = ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();
      return ShaderAssembler.defaultShaderAssembler;
    }
    addDefaultModule(module) {
      if (!this._defaultModules.find((m) => m.name === (typeof module === "string" ? module : module.name))) {
        this._defaultModules.push(module);
      }
    }
    removeDefaultModule(module) {
      const moduleName = typeof module === "string" ? module : module.name;
      this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
    }
    addShaderHook(hook, opts) {
      if (opts) {
        hook = Object.assign(opts, {
          hook
        });
      }
      this._hookFunctions.push(hook);
    }
    assembleShaders(props) {
      const modules = this._getModuleList(props.modules);
      const hookFunctions = this._hookFunctions;
      const options = selectShaders(props);
      const assembled = assembleShaders({
        platformInfo: props.platformInfo,
        ...options,
        modules,
        hookFunctions
      });
      return {
        ...assembled,
        modules
      };
    }
    _getModuleList(appModules = []) {
      const modules = new Array(this._defaultModules.length + appModules.length);
      const seen = {};
      let count = 0;
      for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
        const module = this._defaultModules[i];
        const name2 = module.name;
        modules[count++] = module;
        seen[name2] = true;
      }
      for (let i = 0, len = appModules.length; i < len; ++i) {
        const module = appModules[i];
        const name2 = module.name;
        if (!seen[name2]) {
          modules[count++] = module;
          seen[name2] = true;
        }
      }
      modules.length = count;
      return ShaderModuleInstance.instantiateModules(modules);
    }
  };

  // ../shadertools/src/lib/glsl-utils/shader-utils.ts
  var FS100 = glsl2`void main() {gl_FragColor = vec4(0);}`;
  var FS_GLES = glsl2`\
out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`;
  var FS300 = `#version 300 es
${FS_GLES}`;
  function getPassthroughFS(options) {
    const {
      version = 100,
      input,
      inputChannels,
      output
    } = options || {};
    if (!input) {
      if (version === 300) {
        return FS300;
      } else if (version > 300) {
        return `#version ${version}
${FS_GLES}`;
      }
      return FS100;
    }
    if (!inputChannels) {
      throw new Error("inputChannels");
    }
    const inputType = channelCountToType(inputChannels);
    const outputValue = convertToVec4(input, inputChannels);
    if (version >= 300) {
      return `#version ${version} ${version === 300 ? "es" : ""}
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
    }
    return `varying ${inputType} ${input};
void main() {
  gl_FragColor = ${outputValue};
}`;
  }
  function channelCountToType(channels) {
    switch (channels) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error(`invalid channels: ${channels}`);
    }
  }
  function convertToVec4(variable, channels) {
    switch (channels) {
      case 1:
        return `vec4(${variable}, 0.0, 0.0, 1.0)`;
      case 2:
        return `vec4(${variable}, 0.0, 1.0)`;
      case 3:
        return `vec4(${variable}, 1.0)`;
      case 4:
        return variable;
      default:
        throw new Error(`invalid channels: ${channels}`);
    }
  }

  // ../shadertools/src/libs/wgsl-reflect/wgsl_reflect.module.js
  var ParseContext = class {
    constructor() {
      this.constants = /* @__PURE__ */ new Map();
      this.aliases = /* @__PURE__ */ new Map();
      this.structs = /* @__PURE__ */ new Map();
    }
  };
  var Node = class {
    constructor() {
    }
    get isAstNode() {
      return true;
    }
    get astNodeType() {
      return "";
    }
    evaluate(context) {
      throw new Error("Cannot evaluate node");
    }
    evaluateString(context) {
      return this.evaluate(context).toString();
    }
  };
  var Statement = class extends Node {
    constructor() {
      super();
    }
  };
  var Function = class extends Statement {
    constructor(name2, args, returnType, body) {
      super();
      this.name = name2;
      this.args = args;
      this.returnType = returnType;
      this.body = body;
    }
    get astNodeType() {
      return "function";
    }
  };
  var StaticAssert = class extends Statement {
    constructor(expression) {
      super();
      this.expression = expression;
    }
    get astNodeType() {
      return "staticAssert";
    }
  };
  var While = class extends Statement {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "while";
    }
  };
  var Continuing = class extends Statement {
    constructor(body) {
      super();
      this.body = body;
    }
    get astNodeType() {
      return "continuing";
    }
  };
  var For = class extends Statement {
    constructor(init, condition, increment, body) {
      super();
      this.init = init;
      this.condition = condition;
      this.increment = increment;
      this.body = body;
    }
    get astNodeType() {
      return "for";
    }
  };
  var Var = class extends Statement {
    constructor(name2, type, storage, access, value) {
      super();
      this.name = name2;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "var";
    }
  };
  var Override = class extends Statement {
    constructor(name2, type, value) {
      super();
      this.name = name2;
      this.type = type;
      this.value = value;
    }
    get astNodeType() {
      return "override";
    }
  };
  var Let = class extends Statement {
    constructor(name2, type, storage, access, value) {
      super();
      this.name = name2;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "let";
    }
  };
  var Const = class extends Statement {
    constructor(name2, type, storage, access, value) {
      super();
      this.name = name2;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "const";
    }
    evaluate(context) {
      return this.value.evaluate(context);
    }
  };
  var IncrementOperator;
  (function(IncrementOperator2) {
    IncrementOperator2["increment"] = "++";
    IncrementOperator2["decrement"] = "--";
  })(IncrementOperator || (IncrementOperator = {}));
  (function(IncrementOperator2) {
    function parse(val) {
      const key = val;
      if (key == "parse")
        throw new Error("Invalid value for IncrementOperator");
      return IncrementOperator2[key];
    }
    IncrementOperator2.parse = parse;
  })(IncrementOperator || (IncrementOperator = {}));
  var Increment = class extends Statement {
    constructor(operator, variable) {
      super();
      this.operator = operator;
      this.variable = variable;
    }
    get astNodeType() {
      return "increment";
    }
  };
  var AssignOperator;
  (function(AssignOperator2) {
    AssignOperator2["assign"] = "=";
    AssignOperator2["addAssign"] = "+=";
    AssignOperator2["subtractAssin"] = "-=";
    AssignOperator2["multiplyAssign"] = "*=";
    AssignOperator2["divideAssign"] = "/=";
    AssignOperator2["moduloAssign"] = "%=";
    AssignOperator2["andAssign"] = "&=";
    AssignOperator2["orAssign"] = "|=";
    AssignOperator2["xorAssign"] = "^=";
    AssignOperator2["shiftLeftAssign"] = "<<=";
    AssignOperator2["shiftRightAssign"] = ">>=";
  })(AssignOperator || (AssignOperator = {}));
  (function(AssignOperator2) {
    function parse(val) {
      const key = val;
      if (key == "parse")
        throw new Error("Invalid value for AssignOperator");
      return AssignOperator2[key];
    }
    AssignOperator2.parse = parse;
  })(AssignOperator || (AssignOperator = {}));
  var Assign = class extends Statement {
    constructor(operator, variable, value) {
      super();
      this.operator = operator;
      this.variable = variable;
      this.value = value;
    }
    get astNodeType() {
      return "assign";
    }
  };
  var Call = class extends Statement {
    constructor(name2, args) {
      super();
      this.name = name2;
      this.args = args;
    }
    get astNodeType() {
      return "call";
    }
  };
  var Loop = class extends Statement {
    constructor(body, continuing) {
      super();
      this.body = body;
      this.continuing = continuing;
    }
    get astNodeType() {
      return "loop";
    }
  };
  var Switch = class extends Statement {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "body";
    }
  };
  var If = class extends Statement {
    constructor(condition, body, elseif, _else) {
      super();
      this.condition = condition;
      this.body = body;
      this.elseif = elseif;
      this.else = _else;
    }
    get astNodeType() {
      return "if";
    }
  };
  var Return = class extends Statement {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "return";
    }
  };
  var Enable = class extends Statement {
    constructor(name2) {
      super();
      this.name = name2;
    }
    get astNodeType() {
      return "enable";
    }
  };
  var Alias = class extends Statement {
    constructor(name2, type) {
      super();
      this.name = name2;
      this.type = type;
    }
    get astNodeType() {
      return "alias";
    }
  };
  var Discard = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "discard";
    }
  };
  var Break = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "break";
    }
  };
  var Continue = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "continue";
    }
  };
  var Type = class extends Statement {
    constructor(name2) {
      super();
      this.name = name2;
    }
    get astNodeType() {
      return "type";
    }
    get isStruct() {
      return false;
    }
    get isArray() {
      return false;
    }
  };
  var Struct = class extends Type {
    constructor(name2, members) {
      super(name2);
      this.members = members;
    }
    get astNodeType() {
      return "struct";
    }
    get isStruct() {
      return true;
    }
    getMemberIndex(name2) {
      for (let i = 0; i < this.members.length; i++) {
        if (this.members[i].name == name2)
          return i;
      }
      return -1;
    }
  };
  var TemplateType = class extends Type {
    constructor(name2, format, access) {
      super(name2);
      this.format = format;
      this.access = access;
    }
    get astNodeType() {
      return "template";
    }
  };
  var PointerType = class extends Type {
    constructor(name2, storage, type, access) {
      super(name2);
      this.storage = storage;
      this.type = type;
      this.access = access;
    }
    get astNodeType() {
      return "pointer";
    }
  };
  var ArrayType = class extends Type {
    constructor(name2, attributes, format, count) {
      super(name2);
      this.attributes = attributes;
      this.format = format;
      this.count = count;
    }
    get astNodeType() {
      return "array";
    }
    get isArray() {
      return true;
    }
  };
  var SamplerType = class extends Type {
    constructor(name2, format, access) {
      super(name2);
      this.format = format;
      this.access = access;
    }
    get astNodeType() {
      return "sampler";
    }
  };
  var Expression = class extends Node {
    constructor() {
      super();
    }
  };
  var StringExpr = class extends Expression {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "stringExpr";
    }
    toString() {
      return this.value;
    }
    evaluateString() {
      return this.value;
    }
  };
  var CreateExpr = class extends Expression {
    constructor(type, args) {
      super();
      this.type = type;
      this.args = args;
    }
    get astNodeType() {
      return "createExpr";
    }
  };
  var CallExpr = class extends Expression {
    constructor(name2, args) {
      super();
      this.name = name2;
      this.args = args;
    }
    get astNodeType() {
      return "callExpr";
    }
    evaluate(context) {
      switch (this.name) {
        case "abs":
          return Math.abs(this.args[0].evaluate(context));
        case "acos":
          return Math.acos(this.args[0].evaluate(context));
        case "acosh":
          return Math.acosh(this.args[0].evaluate(context));
        case "asin":
          return Math.asin(this.args[0].evaluate(context));
        case "asinh":
          return Math.asinh(this.args[0].evaluate(context));
        case "atan":
          return Math.atan(this.args[0].evaluate(context));
        case "atan2":
          return Math.atan2(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "atanh":
          return Math.atanh(this.args[0].evaluate(context));
        case "ceil":
          return Math.ceil(this.args[0].evaluate(context));
        case "clamp":
          return Math.min(Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context)), this.args[2].evaluate(context));
        case "cos":
          return Math.cos(this.args[0].evaluate(context));
        case "degrees":
          return this.args[0].evaluate(context) * 180 / Math.PI;
        case "distance":
          return Math.sqrt(Math.pow(this.args[0].evaluate(context) - this.args[1].evaluate(context), 2));
        case "dot":
        case "exp":
          return Math.exp(this.args[0].evaluate(context));
        case "exp2":
          return Math.pow(2, this.args[0].evaluate(context));
        case "floor":
          return Math.floor(this.args[0].evaluate(context));
        case "fma":
          return this.args[0].evaluate(context) * this.args[1].evaluate(context) + this.args[2].evaluate(context);
        case "fract":
          return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
        case "inverseSqrt":
          return 1 / Math.sqrt(this.args[0].evaluate(context));
        case "log":
          return Math.log(this.args[0].evaluate(context));
        case "log2":
          return Math.log2(this.args[0].evaluate(context));
        case "max":
          return Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "min":
          return Math.min(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "mix":
          return this.args[0].evaluate(context) * (1 - this.args[2].evaluate(context)) + this.args[1].evaluate(context) * this.args[2].evaluate(context);
        case "modf":
          return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
        case "pow":
          return Math.pow(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "radians":
          return this.args[0].evaluate(context) * Math.PI / 180;
        case "round":
          return Math.round(this.args[0].evaluate(context));
        case "sign":
          return Math.sign(this.args[0].evaluate(context));
        case "sin":
          return Math.sin(this.args[0].evaluate(context));
        case "sinh":
          return Math.sinh(this.args[0].evaluate(context));
        case "saturate":
          return Math.min(Math.max(this.args[0].evaluate(context), 0), 1);
        case "smoothstep":
          return this.args[0].evaluate(context) * this.args[0].evaluate(context) * (3 - 2 * this.args[0].evaluate(context));
        case "sqrt":
          return Math.sqrt(this.args[0].evaluate(context));
        case "step":
          return this.args[0].evaluate(context) < this.args[1].evaluate(context) ? 0 : 1;
        case "tan":
          return Math.tan(this.args[0].evaluate(context));
        case "tanh":
          return Math.tanh(this.args[0].evaluate(context));
        case "trunc":
          return Math.trunc(this.args[0].evaluate(context));
        default:
          throw new Error("Non const function: " + this.name);
      }
    }
  };
  var VariableExpr = class extends Expression {
    constructor(name2) {
      super();
      this.name = name2;
    }
    get astNodeType() {
      return "varExpr";
    }
  };
  var ConstExpr = class extends Expression {
    constructor(name2, initializer) {
      super();
      this.name = name2;
      this.initializer = initializer;
    }
    get astNodeType() {
      return "constExpr";
    }
    evaluate(context) {
      var _a2, _b;
      if (this.initializer instanceof CreateExpr) {
        const property = (_a2 = this.postfix) === null || _a2 === void 0 ? void 0 : _a2.evaluateString(context);
        const type = (_b = this.initializer.type) === null || _b === void 0 ? void 0 : _b.name;
        const struct = context.structs.get(type);
        const memberIndex = struct === null || struct === void 0 ? void 0 : struct.getMemberIndex(property);
        if (memberIndex != -1) {
          const value = this.initializer.args[memberIndex].evaluate(context);
          return value;
        }
        console.log(memberIndex);
      }
      return this.initializer.evaluate(context);
    }
  };
  var LiteralExpr = class extends Expression {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "literalExpr";
    }
    evaluate() {
      return this.value;
    }
  };
  var BitcastExpr = class extends Expression {
    constructor(type, value) {
      super();
      this.type = type;
      this.value = value;
    }
    get astNodeType() {
      return "bitcastExpr";
    }
  };
  var TypecastExpr = class extends Expression {
    constructor(type, args) {
      super();
      this.type = type;
      this.args = args;
    }
    get astNodeType() {
      return "typecastExpr";
    }
    evaluate(context) {
      return this.args[0].evaluate(context);
    }
  };
  var GroupingExpr = class extends Expression {
    constructor(contents) {
      super();
      this.contents = contents;
    }
    get astNodeType() {
      return "groupExpr";
    }
    evaluate(context) {
      return this.contents[0].evaluate(context);
    }
  };
  var Operator = class extends Expression {
    constructor() {
      super();
    }
  };
  var UnaryOperator = class extends Operator {
    constructor(operator, right) {
      super();
      this.operator = operator;
      this.right = right;
    }
    get astNodeType() {
      return "unaryOp";
    }
    evaluate(context) {
      switch (this.operator) {
        case "+":
          return this.right.evaluate(context);
        case "-":
          return -this.right.evaluate(context);
        case "!":
          return this.right.evaluate(context) ? 0 : 1;
        case "~":
          return ~this.right.evaluate(context);
        default:
          throw new Error("Unknown unary operator: " + this.operator);
      }
    }
  };
  var BinaryOperator = class extends Operator {
    constructor(operator, left, right) {
      super();
      this.operator = operator;
      this.left = left;
      this.right = right;
    }
    get astNodeType() {
      return "binaryOp";
    }
    evaluate(context) {
      switch (this.operator) {
        case "+":
          return this.left.evaluate(context) + this.right.evaluate(context);
        case "-":
          return this.left.evaluate(context) - this.right.evaluate(context);
        case "*":
          return this.left.evaluate(context) * this.right.evaluate(context);
        case "/":
          return this.left.evaluate(context) / this.right.evaluate(context);
        case "%":
          return this.left.evaluate(context) % this.right.evaluate(context);
        case "==":
          return this.left.evaluate(context) == this.right.evaluate(context) ? 1 : 0;
        case "!=":
          return this.left.evaluate(context) != this.right.evaluate(context) ? 1 : 0;
        case "<":
          return this.left.evaluate(context) < this.right.evaluate(context) ? 1 : 0;
        case ">":
          return this.left.evaluate(context) > this.right.evaluate(context) ? 1 : 0;
        case "<=":
          return this.left.evaluate(context) <= this.right.evaluate(context) ? 1 : 0;
        case ">=":
          return this.left.evaluate(context) >= this.right.evaluate(context) ? 1 : 0;
        case "&&":
          return this.left.evaluate(context) && this.right.evaluate(context) ? 1 : 0;
        case "||":
          return this.left.evaluate(context) || this.right.evaluate(context) ? 1 : 0;
        default:
          throw new Error(`Unknown operator ${this.operator}`);
      }
    }
  };
  var SwitchCase = class extends Node {
    constructor() {
      super();
    }
  };
  var Case = class extends SwitchCase {
    constructor(selector, body) {
      super();
      this.selector = selector;
      this.body = body;
    }
    get astNodeType() {
      return "case";
    }
  };
  var Default = class extends SwitchCase {
    constructor(body) {
      super();
      this.body = body;
    }
    get astNodeType() {
      return "default";
    }
  };
  var Argument = class extends Node {
    constructor(name2, type, attributes) {
      super();
      this.name = name2;
      this.type = type;
      this.attributes = attributes;
    }
    get astNodeType() {
      return "argument";
    }
  };
  var ElseIf = class extends Node {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "elseif";
    }
  };
  var Member = class extends Node {
    constructor(name2, type, attributes) {
      super();
      this.name = name2;
      this.type = type;
      this.attributes = attributes;
    }
    get astNodeType() {
      return "member";
    }
  };
  var Attribute = class extends Node {
    constructor(name2, value) {
      super();
      this.name = name2;
      this.value = value;
    }
    get astNodeType() {
      return "attribute";
    }
  };
  var _a;
  var TokenClass;
  (function(TokenClass2) {
    TokenClass2[TokenClass2["token"] = 0] = "token";
    TokenClass2[TokenClass2["keyword"] = 1] = "keyword";
    TokenClass2[TokenClass2["reserved"] = 2] = "reserved";
  })(TokenClass || (TokenClass = {}));
  var TokenType = class {
    constructor(name2, type, rule) {
      this.name = name2;
      this.type = type;
      this.rule = rule;
    }
    toString() {
      return this.name;
    }
  };
  var TokenTypes = class {
  };
  _a = TokenTypes;
  TokenTypes.none = new TokenType("", TokenClass.reserved, "");
  TokenTypes.eof = new TokenType("EOF", TokenClass.token, "");
  TokenTypes.reserved = {
    asm: new TokenType("asm", TokenClass.reserved, "asm"),
    bf16: new TokenType("bf16", TokenClass.reserved, "bf16"),
    do: new TokenType("do", TokenClass.reserved, "do"),
    enum: new TokenType("enum", TokenClass.reserved, "enum"),
    f16: new TokenType("f16", TokenClass.reserved, "f16"),
    f64: new TokenType("f64", TokenClass.reserved, "f64"),
    handle: new TokenType("handle", TokenClass.reserved, "handle"),
    i8: new TokenType("i8", TokenClass.reserved, "i8"),
    i16: new TokenType("i16", TokenClass.reserved, "i16"),
    i64: new TokenType("i64", TokenClass.reserved, "i64"),
    mat: new TokenType("mat", TokenClass.reserved, "mat"),
    premerge: new TokenType("premerge", TokenClass.reserved, "premerge"),
    regardless: new TokenType("regardless", TokenClass.reserved, "regardless"),
    typedef: new TokenType("typedef", TokenClass.reserved, "typedef"),
    u8: new TokenType("u8", TokenClass.reserved, "u8"),
    u16: new TokenType("u16", TokenClass.reserved, "u16"),
    u64: new TokenType("u64", TokenClass.reserved, "u64"),
    unless: new TokenType("unless", TokenClass.reserved, "unless"),
    using: new TokenType("using", TokenClass.reserved, "using"),
    vec: new TokenType("vec", TokenClass.reserved, "vec"),
    void: new TokenType("void", TokenClass.reserved, "void")
  };
  TokenTypes.keywords = {
    array: new TokenType("array", TokenClass.keyword, "array"),
    atomic: new TokenType("atomic", TokenClass.keyword, "atomic"),
    bool: new TokenType("bool", TokenClass.keyword, "bool"),
    f32: new TokenType("f32", TokenClass.keyword, "f32"),
    i32: new TokenType("i32", TokenClass.keyword, "i32"),
    mat2x2: new TokenType("mat2x2", TokenClass.keyword, "mat2x2"),
    mat2x3: new TokenType("mat2x3", TokenClass.keyword, "mat2x3"),
    mat2x4: new TokenType("mat2x4", TokenClass.keyword, "mat2x4"),
    mat3x2: new TokenType("mat3x2", TokenClass.keyword, "mat3x2"),
    mat3x3: new TokenType("mat3x3", TokenClass.keyword, "mat3x3"),
    mat3x4: new TokenType("mat3x4", TokenClass.keyword, "mat3x4"),
    mat4x2: new TokenType("mat4x2", TokenClass.keyword, "mat4x2"),
    mat4x3: new TokenType("mat4x3", TokenClass.keyword, "mat4x3"),
    mat4x4: new TokenType("mat4x4", TokenClass.keyword, "mat4x4"),
    ptr: new TokenType("ptr", TokenClass.keyword, "ptr"),
    sampler: new TokenType("sampler", TokenClass.keyword, "sampler"),
    sampler_comparison: new TokenType("sampler_comparison", TokenClass.keyword, "sampler_comparison"),
    struct: new TokenType("struct", TokenClass.keyword, "struct"),
    texture_1d: new TokenType("texture_1d", TokenClass.keyword, "texture_1d"),
    texture_2d: new TokenType("texture_2d", TokenClass.keyword, "texture_2d"),
    texture_2d_array: new TokenType("texture_2d_array", TokenClass.keyword, "texture_2d_array"),
    texture_3d: new TokenType("texture_3d", TokenClass.keyword, "texture_3d"),
    texture_cube: new TokenType("texture_cube", TokenClass.keyword, "texture_cube"),
    texture_cube_array: new TokenType("texture_cube_array", TokenClass.keyword, "texture_cube_array"),
    texture_multisampled_2d: new TokenType("texture_multisampled_2d", TokenClass.keyword, "texture_multisampled_2d"),
    texture_storage_1d: new TokenType("texture_storage_1d", TokenClass.keyword, "texture_storage_1d"),
    texture_storage_2d: new TokenType("texture_storage_2d", TokenClass.keyword, "texture_storage_2d"),
    texture_storage_2d_array: new TokenType("texture_storage_2d_array", TokenClass.keyword, "texture_storage_2d_array"),
    texture_storage_3d: new TokenType("texture_storage_3d", TokenClass.keyword, "texture_storage_3d"),
    texture_depth_2d: new TokenType("texture_depth_2d", TokenClass.keyword, "texture_depth_2d"),
    texture_depth_2d_array: new TokenType("texture_depth_2d_array", TokenClass.keyword, "texture_depth_2d_array"),
    texture_depth_cube: new TokenType("texture_depth_cube", TokenClass.keyword, "texture_depth_cube"),
    texture_depth_cube_array: new TokenType("texture_depth_cube_array", TokenClass.keyword, "texture_depth_cube_array"),
    texture_depth_multisampled_2d: new TokenType("texture_depth_multisampled_2d", TokenClass.keyword, "texture_depth_multisampled_2d"),
    texture_external: new TokenType("texture_external", TokenClass.keyword, "texture_external"),
    u32: new TokenType("u32", TokenClass.keyword, "u32"),
    vec2: new TokenType("vec2", TokenClass.keyword, "vec2"),
    vec3: new TokenType("vec3", TokenClass.keyword, "vec3"),
    vec4: new TokenType("vec4", TokenClass.keyword, "vec4"),
    bitcast: new TokenType("bitcast", TokenClass.keyword, "bitcast"),
    block: new TokenType("block", TokenClass.keyword, "block"),
    break: new TokenType("break", TokenClass.keyword, "break"),
    case: new TokenType("case", TokenClass.keyword, "case"),
    continue: new TokenType("continue", TokenClass.keyword, "continue"),
    continuing: new TokenType("continuing", TokenClass.keyword, "continuing"),
    default: new TokenType("default", TokenClass.keyword, "default"),
    discard: new TokenType("discard", TokenClass.keyword, "discard"),
    else: new TokenType("else", TokenClass.keyword, "else"),
    enable: new TokenType("enable", TokenClass.keyword, "enable"),
    fallthrough: new TokenType("fallthrough", TokenClass.keyword, "fallthrough"),
    false: new TokenType("false", TokenClass.keyword, "false"),
    fn: new TokenType("fn", TokenClass.keyword, "fn"),
    for: new TokenType("for", TokenClass.keyword, "for"),
    function: new TokenType("function", TokenClass.keyword, "function"),
    if: new TokenType("if", TokenClass.keyword, "if"),
    let: new TokenType("let", TokenClass.keyword, "let"),
    const: new TokenType("const", TokenClass.keyword, "const"),
    loop: new TokenType("loop", TokenClass.keyword, "loop"),
    while: new TokenType("while", TokenClass.keyword, "while"),
    private: new TokenType("private", TokenClass.keyword, "private"),
    read: new TokenType("read", TokenClass.keyword, "read"),
    read_write: new TokenType("read_write", TokenClass.keyword, "read_write"),
    return: new TokenType("return", TokenClass.keyword, "return"),
    storage: new TokenType("storage", TokenClass.keyword, "storage"),
    switch: new TokenType("switch", TokenClass.keyword, "switch"),
    true: new TokenType("true", TokenClass.keyword, "true"),
    alias: new TokenType("alias", TokenClass.keyword, "alias"),
    type: new TokenType("type", TokenClass.keyword, "type"),
    uniform: new TokenType("uniform", TokenClass.keyword, "uniform"),
    var: new TokenType("var", TokenClass.keyword, "var"),
    override: new TokenType("override", TokenClass.keyword, "override"),
    workgroup: new TokenType("workgroup", TokenClass.keyword, "workgroup"),
    write: new TokenType("write", TokenClass.keyword, "write"),
    r8unorm: new TokenType("r8unorm", TokenClass.keyword, "r8unorm"),
    r8snorm: new TokenType("r8snorm", TokenClass.keyword, "r8snorm"),
    r8uint: new TokenType("r8uint", TokenClass.keyword, "r8uint"),
    r8sint: new TokenType("r8sint", TokenClass.keyword, "r8sint"),
    r16uint: new TokenType("r16uint", TokenClass.keyword, "r16uint"),
    r16sint: new TokenType("r16sint", TokenClass.keyword, "r16sint"),
    r16float: new TokenType("r16float", TokenClass.keyword, "r16float"),
    rg8unorm: new TokenType("rg8unorm", TokenClass.keyword, "rg8unorm"),
    rg8snorm: new TokenType("rg8snorm", TokenClass.keyword, "rg8snorm"),
    rg8uint: new TokenType("rg8uint", TokenClass.keyword, "rg8uint"),
    rg8sint: new TokenType("rg8sint", TokenClass.keyword, "rg8sint"),
    r32uint: new TokenType("r32uint", TokenClass.keyword, "r32uint"),
    r32sint: new TokenType("r32sint", TokenClass.keyword, "r32sint"),
    r32float: new TokenType("r32float", TokenClass.keyword, "r32float"),
    rg16uint: new TokenType("rg16uint", TokenClass.keyword, "rg16uint"),
    rg16sint: new TokenType("rg16sint", TokenClass.keyword, "rg16sint"),
    rg16float: new TokenType("rg16float", TokenClass.keyword, "rg16float"),
    rgba8unorm: new TokenType("rgba8unorm", TokenClass.keyword, "rgba8unorm"),
    rgba8unorm_srgb: new TokenType("rgba8unorm_srgb", TokenClass.keyword, "rgba8unorm_srgb"),
    rgba8snorm: new TokenType("rgba8snorm", TokenClass.keyword, "rgba8snorm"),
    rgba8uint: new TokenType("rgba8uint", TokenClass.keyword, "rgba8uint"),
    rgba8sint: new TokenType("rgba8sint", TokenClass.keyword, "rgba8sint"),
    bgra8unorm: new TokenType("bgra8unorm", TokenClass.keyword, "bgra8unorm"),
    bgra8unorm_srgb: new TokenType("bgra8unorm_srgb", TokenClass.keyword, "bgra8unorm_srgb"),
    rgb10a2unorm: new TokenType("rgb10a2unorm", TokenClass.keyword, "rgb10a2unorm"),
    rg11b10float: new TokenType("rg11b10float", TokenClass.keyword, "rg11b10float"),
    rg32uint: new TokenType("rg32uint", TokenClass.keyword, "rg32uint"),
    rg32sint: new TokenType("rg32sint", TokenClass.keyword, "rg32sint"),
    rg32float: new TokenType("rg32float", TokenClass.keyword, "rg32float"),
    rgba16uint: new TokenType("rgba16uint", TokenClass.keyword, "rgba16uint"),
    rgba16sint: new TokenType("rgba16sint", TokenClass.keyword, "rgba16sint"),
    rgba16float: new TokenType("rgba16float", TokenClass.keyword, "rgba16float"),
    rgba32uint: new TokenType("rgba32uint", TokenClass.keyword, "rgba32uint"),
    rgba32sint: new TokenType("rgba32sint", TokenClass.keyword, "rgba32sint"),
    rgba32float: new TokenType("rgba32float", TokenClass.keyword, "rgba32float"),
    static_assert: new TokenType("static_assert", TokenClass.keyword, "static_assert")
  };
  TokenTypes.tokens = {
    decimal_float_literal: new TokenType("decimal_float_literal", TokenClass.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
    hex_float_literal: new TokenType("hex_float_literal", TokenClass.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
    int_literal: new TokenType("int_literal", TokenClass.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
    uint_literal: new TokenType("uint_literal", TokenClass.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
    ident: new TokenType("ident", TokenClass.token, /[a-zA-Z][0-9a-zA-Z_]*/),
    and: new TokenType("and", TokenClass.token, "&"),
    and_and: new TokenType("and_and", TokenClass.token, "&&"),
    arrow: new TokenType("arrow ", TokenClass.token, "->"),
    attr: new TokenType("attr", TokenClass.token, "@"),
    attr_left: new TokenType("attr_left", TokenClass.token, "[["),
    attr_right: new TokenType("attr_right", TokenClass.token, "]]"),
    forward_slash: new TokenType("forward_slash", TokenClass.token, "/"),
    bang: new TokenType("bang", TokenClass.token, "!"),
    bracket_left: new TokenType("bracket_left", TokenClass.token, "["),
    bracket_right: new TokenType("bracket_right", TokenClass.token, "]"),
    brace_left: new TokenType("brace_left", TokenClass.token, "{"),
    brace_right: new TokenType("brace_right", TokenClass.token, "}"),
    colon: new TokenType("colon", TokenClass.token, ":"),
    comma: new TokenType("comma", TokenClass.token, ","),
    equal: new TokenType("equal", TokenClass.token, "="),
    equal_equal: new TokenType("equal_equal", TokenClass.token, "=="),
    not_equal: new TokenType("not_equal", TokenClass.token, "!="),
    greater_than: new TokenType("greater_than", TokenClass.token, ">"),
    greater_than_equal: new TokenType("greater_than_equal", TokenClass.token, ">="),
    shift_right: new TokenType("shift_right", TokenClass.token, ">>"),
    less_than: new TokenType("less_than", TokenClass.token, "<"),
    less_than_equal: new TokenType("less_than_equal", TokenClass.token, "<="),
    shift_left: new TokenType("shift_left", TokenClass.token, "<<"),
    modulo: new TokenType("modulo", TokenClass.token, "%"),
    minus: new TokenType("minus", TokenClass.token, "-"),
    minus_minus: new TokenType("minus_minus", TokenClass.token, "--"),
    period: new TokenType("period", TokenClass.token, "."),
    plus: new TokenType("plus", TokenClass.token, "+"),
    plus_plus: new TokenType("plus_plus", TokenClass.token, "++"),
    or: new TokenType("or", TokenClass.token, "|"),
    or_or: new TokenType("or_or", TokenClass.token, "||"),
    paren_left: new TokenType("paren_left", TokenClass.token, "("),
    paren_right: new TokenType("paren_right", TokenClass.token, ")"),
    semicolon: new TokenType("semicolon", TokenClass.token, ";"),
    star: new TokenType("star", TokenClass.token, "*"),
    tilde: new TokenType("tilde", TokenClass.token, "~"),
    underscore: new TokenType("underscore", TokenClass.token, "_"),
    xor: new TokenType("xor", TokenClass.token, "^"),
    plus_equal: new TokenType("plus_equal", TokenClass.token, "+="),
    minus_equal: new TokenType("minus_equal", TokenClass.token, "-="),
    times_equal: new TokenType("times_equal", TokenClass.token, "*="),
    division_equal: new TokenType("division_equal", TokenClass.token, "/="),
    modulo_equal: new TokenType("modulo_equal", TokenClass.token, "%="),
    and_equal: new TokenType("and_equal", TokenClass.token, "&="),
    or_equal: new TokenType("or_equal", TokenClass.token, "|="),
    xor_equal: new TokenType("xor_equal", TokenClass.token, "^="),
    shift_right_equal: new TokenType("shift_right_equal", TokenClass.token, ">>="),
    shift_left_equal: new TokenType("shift_left_equal", TokenClass.token, "<<=")
  };
  TokenTypes.storage_class = [_a.keywords.function, _a.keywords.private, _a.keywords.workgroup, _a.keywords.uniform, _a.keywords.storage];
  TokenTypes.access_mode = [_a.keywords.read, _a.keywords.write, _a.keywords.read_write];
  TokenTypes.sampler_type = [_a.keywords.sampler, _a.keywords.sampler_comparison];
  TokenTypes.sampled_texture_type = [_a.keywords.texture_1d, _a.keywords.texture_2d, _a.keywords.texture_2d_array, _a.keywords.texture_3d, _a.keywords.texture_cube, _a.keywords.texture_cube_array];
  TokenTypes.multisampled_texture_type = [_a.keywords.texture_multisampled_2d];
  TokenTypes.storage_texture_type = [_a.keywords.texture_storage_1d, _a.keywords.texture_storage_2d, _a.keywords.texture_storage_2d_array, _a.keywords.texture_storage_3d];
  TokenTypes.depth_texture_type = [_a.keywords.texture_depth_2d, _a.keywords.texture_depth_2d_array, _a.keywords.texture_depth_cube, _a.keywords.texture_depth_cube_array, _a.keywords.texture_depth_multisampled_2d];
  TokenTypes.texture_external_type = [_a.keywords.texture_external];
  TokenTypes.any_texture_type = [..._a.sampled_texture_type, ..._a.multisampled_texture_type, ..._a.storage_texture_type, ..._a.depth_texture_type, ..._a.texture_external_type];
  TokenTypes.texel_format = [_a.keywords.r8unorm, _a.keywords.r8snorm, _a.keywords.r8uint, _a.keywords.r8sint, _a.keywords.r16uint, _a.keywords.r16sint, _a.keywords.r16float, _a.keywords.rg8unorm, _a.keywords.rg8snorm, _a.keywords.rg8uint, _a.keywords.rg8sint, _a.keywords.r32uint, _a.keywords.r32sint, _a.keywords.r32float, _a.keywords.rg16uint, _a.keywords.rg16sint, _a.keywords.rg16float, _a.keywords.rgba8unorm, _a.keywords.rgba8unorm_srgb, _a.keywords.rgba8snorm, _a.keywords.rgba8uint, _a.keywords.rgba8sint, _a.keywords.bgra8unorm, _a.keywords.bgra8unorm_srgb, _a.keywords.rgb10a2unorm, _a.keywords.rg11b10float, _a.keywords.rg32uint, _a.keywords.rg32sint, _a.keywords.rg32float, _a.keywords.rgba16uint, _a.keywords.rgba16sint, _a.keywords.rgba16float, _a.keywords.rgba32uint, _a.keywords.rgba32sint, _a.keywords.rgba32float];
  TokenTypes.const_literal = [_a.tokens.int_literal, _a.tokens.uint_literal, _a.tokens.decimal_float_literal, _a.tokens.hex_float_literal, _a.keywords.true, _a.keywords.false];
  TokenTypes.literal_or_ident = [_a.tokens.ident, _a.tokens.int_literal, _a.tokens.uint_literal, _a.tokens.decimal_float_literal, _a.tokens.hex_float_literal];
  TokenTypes.element_count_expression = [_a.tokens.int_literal, _a.tokens.uint_literal, _a.tokens.ident];
  TokenTypes.template_types = [_a.keywords.vec2, _a.keywords.vec3, _a.keywords.vec4, _a.keywords.mat2x2, _a.keywords.mat2x3, _a.keywords.mat2x4, _a.keywords.mat3x2, _a.keywords.mat3x3, _a.keywords.mat3x4, _a.keywords.mat4x2, _a.keywords.mat4x3, _a.keywords.mat4x4, _a.keywords.atomic, _a.keywords.bitcast, ..._a.any_texture_type];
  TokenTypes.attribute_name = [_a.tokens.ident, _a.keywords.block];
  TokenTypes.assignment_operators = [_a.tokens.equal, _a.tokens.plus_equal, _a.tokens.minus_equal, _a.tokens.times_equal, _a.tokens.division_equal, _a.tokens.modulo_equal, _a.tokens.and_equal, _a.tokens.or_equal, _a.tokens.xor_equal, _a.tokens.shift_right_equal, _a.tokens.shift_left_equal];
  TokenTypes.increment_operators = [_a.tokens.plus_plus, _a.tokens.minus_minus];
  var Token = class {
    constructor(type, lexeme, line) {
      this.type = type;
      this.lexeme = lexeme;
      this.line = line;
    }
    toString() {
      return this.lexeme;
    }
    isTemplateType() {
      return TokenTypes.template_types.indexOf(this.type) != -1;
    }
    isArrayType() {
      return this.type == TokenTypes.keywords.array;
    }
    isArrayOrTemplateType() {
      return this.isArrayType() || this.isTemplateType();
    }
  };
  var WgslScanner = class {
    constructor(source) {
      this._tokens = [];
      this._start = 0;
      this._current = 0;
      this._line = 1;
      this._source = source !== null && source !== void 0 ? source : "";
    }
    scanTokens() {
      while (!this._isAtEnd()) {
        this._start = this._current;
        if (!this.scanToken())
          throw `Invalid syntax at line ${this._line}`;
      }
      this._tokens.push(new Token(TokenTypes.eof, "", this._line));
      return this._tokens;
    }
    scanToken() {
      let lexeme = this._advance();
      if (lexeme == "\n") {
        this._line++;
        return true;
      }
      if (this._isWhitespace(lexeme)) {
        return true;
      }
      if (lexeme == "/") {
        if (this._peekAhead() == "/") {
          while (lexeme != "\n") {
            if (this._isAtEnd())
              return true;
            lexeme = this._advance();
          }
          this._line++;
          return true;
        } else if (this._peekAhead() == "*") {
          this._advance();
          let commentLevel = 1;
          while (commentLevel > 0) {
            if (this._isAtEnd())
              return true;
            lexeme = this._advance();
            if (lexeme == "\n") {
              this._line++;
            } else if (lexeme == "*") {
              if (this._peekAhead() == "/") {
                this._advance();
                commentLevel--;
                if (commentLevel == 0) {
                  return true;
                }
              }
            } else if (lexeme == "/") {
              if (this._peekAhead() == "*") {
                this._advance();
                commentLevel++;
              }
            }
          }
          return true;
        }
      }
      let matchType = TokenTypes.none;
      for (; ; ) {
        let matchedType = this._findType(lexeme);
        const nextLexeme = this._peekAhead();
        if (lexeme == ">" && (nextLexeme == ">" || nextLexeme == "=")) {
          let foundLessThan = false;
          let ti = this._tokens.length - 1;
          for (let count = 0; count < 5 && ti >= 0; ++count, --ti) {
            if (this._tokens[ti].type === TokenTypes.tokens.less_than) {
              if (ti > 0 && this._tokens[ti - 1].isArrayOrTemplateType()) {
                foundLessThan = true;
              }
              break;
            }
          }
          if (foundLessThan) {
            this._addToken(matchedType);
            return true;
          }
        }
        if (matchedType === TokenTypes.none) {
          let lookAheadLexeme = lexeme;
          let lookAhead = 0;
          const maxLookAhead = 2;
          for (let li = 0; li < maxLookAhead; ++li) {
            lookAheadLexeme += this._peekAhead(li);
            matchedType = this._findType(lookAheadLexeme);
            if (matchedType !== TokenTypes.none) {
              lookAhead = li;
              break;
            }
          }
          if (matchedType === TokenTypes.none) {
            if (matchType === TokenTypes.none)
              return false;
            this._current--;
            this._addToken(matchType);
            return true;
          }
          lexeme = lookAheadLexeme;
          this._current += lookAhead + 1;
        }
        matchType = matchedType;
        if (this._isAtEnd())
          break;
        lexeme += this._advance();
      }
      if (matchType === TokenTypes.none)
        return false;
      this._addToken(matchType);
      return true;
    }
    _findType(lexeme) {
      for (const name2 in TokenTypes.keywords) {
        const type = TokenTypes.keywords[name2];
        if (this._match(lexeme, type.rule)) {
          return type;
        }
      }
      for (const name2 in TokenTypes.tokens) {
        const type = TokenTypes.tokens[name2];
        if (this._match(lexeme, type.rule)) {
          return type;
        }
      }
      return TokenTypes.none;
    }
    _match(lexeme, rule) {
      if (typeof rule === "string") {
        if (rule == lexeme) {
          return true;
        }
      } else {
        const match = rule.exec(lexeme);
        if (match && match.index == 0 && match[0] == lexeme)
          return true;
      }
      return false;
    }
    _isAtEnd() {
      return this._current >= this._source.length;
    }
    _isWhitespace(c) {
      return c == " " || c == "	" || c == "\r";
    }
    _advance(amount = 0) {
      let c = this._source[this._current];
      amount = amount || 0;
      amount++;
      this._current += amount;
      return c;
    }
    _peekAhead(offset = 0) {
      offset = offset || 0;
      if (this._current + offset >= this._source.length)
        return "\0";
      return this._source[this._current + offset];
    }
    _addToken(type) {
      const text = this._source.substring(this._start, this._current);
      this._tokens.push(new Token(type, text, this._line));
    }
  };
  var WgslParser = class {
    constructor() {
      this._tokens = [];
      this._current = 0;
      this._context = new ParseContext();
    }
    parse(tokensOrCode) {
      this._initialize(tokensOrCode);
      let statements = [];
      while (!this._isAtEnd()) {
        const statement = this._global_decl_or_directive();
        if (!statement)
          break;
        statements.push(statement);
      }
      return statements;
    }
    _initialize(tokensOrCode) {
      if (tokensOrCode) {
        if (typeof tokensOrCode == "string") {
          const scanner = new WgslScanner(tokensOrCode);
          this._tokens = scanner.scanTokens();
        } else {
          this._tokens = tokensOrCode;
        }
      } else {
        this._tokens = [];
      }
      this._current = 0;
    }
    _error(token, message) {
      console.error(token, message);
      return {
        token,
        message,
        toString: function() {
          return `${message}`;
        }
      };
    }
    _isAtEnd() {
      return this._current >= this._tokens.length || this._peek().type == TokenTypes.eof;
    }
    _match(types) {
      if (types instanceof TokenType) {
        if (this._check(types)) {
          this._advance();
          return true;
        }
        return false;
      }
      for (let i = 0, l = types.length; i < l; ++i) {
        const type = types[i];
        if (this._check(type)) {
          this._advance();
          return true;
        }
      }
      return false;
    }
    _consume(types, message) {
      if (this._check(types))
        return this._advance();
      throw this._error(this._peek(), message);
    }
    _check(types) {
      if (this._isAtEnd())
        return false;
      const tk = this._peek();
      if (types instanceof Array) {
        let t = tk.type;
        let index2 = types.indexOf(t);
        return index2 != -1;
      }
      return tk.type == types;
    }
    _advance() {
      if (!this._isAtEnd())
        this._current++;
      return this._previous();
    }
    _peek() {
      return this._tokens[this._current];
    }
    _previous() {
      return this._tokens[this._current - 1];
    }
    _global_decl_or_directive() {
      while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
        ;
      if (this._match(TokenTypes.keywords.alias)) {
        const type = this._type_alias();
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return type;
      }
      if (this._match(TokenTypes.keywords.enable)) {
        const enable = this._enable_directive();
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return enable;
      }
      const attrs = this._attribute();
      if (this._check(TokenTypes.keywords.var)) {
        const _var = this._global_variable_decl();
        if (_var != null)
          _var.attributes = attrs;
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _var;
      }
      if (this._check(TokenTypes.keywords.override)) {
        const _override = this._override_variable_decl();
        if (_override != null)
          _override.attributes = attrs;
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _override;
      }
      if (this._check(TokenTypes.keywords.let)) {
        const _let = this._global_let_decl();
        if (_let != null)
          _let.attributes = attrs;
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _let;
      }
      if (this._check(TokenTypes.keywords.const)) {
        const _const = this._global_const_decl();
        if (_const != null)
          _const.attributes = attrs;
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _const;
      }
      if (this._check(TokenTypes.keywords.struct)) {
        const _struct = this._struct_decl();
        if (_struct != null)
          _struct.attributes = attrs;
        return _struct;
      }
      if (this._check(TokenTypes.keywords.fn)) {
        const _fn = this._function_decl();
        if (_fn != null)
          _fn.attributes = attrs;
        return _fn;
      }
      return null;
    }
    _function_decl() {
      if (!this._match(TokenTypes.keywords.fn))
        return null;
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected function name.").toString();
      this._consume(TokenTypes.tokens.paren_left, "Expected '(' for function arguments.");
      const args = [];
      if (!this._check(TokenTypes.tokens.paren_right)) {
        do {
          if (this._check(TokenTypes.tokens.paren_right))
            break;
          const argAttrs = this._attribute();
          const name3 = this._consume(TokenTypes.tokens.ident, "Expected argument name.").toString();
          this._consume(TokenTypes.tokens.colon, "Expected ':' for argument type.");
          const typeAttrs = this._attribute();
          const type = this._type_decl();
          if (type != null) {
            type.attributes = typeAttrs;
            args.push(new Argument(name3, type, argAttrs));
          }
        } while (this._match(TokenTypes.tokens.comma));
      }
      this._consume(TokenTypes.tokens.paren_right, "Expected ')' after function arguments.");
      let _return = null;
      if (this._match(TokenTypes.tokens.arrow)) {
        const attrs = this._attribute();
        _return = this._type_decl();
        if (_return != null)
          _return.attributes = attrs;
      }
      const body = this._compound_statement();
      return new Function(name2, args, _return, body);
    }
    _compound_statement() {
      const statements = [];
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for block.");
      while (!this._check(TokenTypes.tokens.brace_right)) {
        const statement = this._statement();
        if (statement !== null)
          statements.push(statement);
      }
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for block.");
      return statements;
    }
    _statement() {
      while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
        ;
      if (this._check(TokenTypes.keywords.if))
        return this._if_statement();
      if (this._check(TokenTypes.keywords.switch))
        return this._switch_statement();
      if (this._check(TokenTypes.keywords.loop))
        return this._loop_statement();
      if (this._check(TokenTypes.keywords.for))
        return this._for_statement();
      if (this._check(TokenTypes.keywords.while))
        return this._while_statement();
      if (this._check(TokenTypes.keywords.continuing))
        return this._continuing_statement();
      if (this._check(TokenTypes.keywords.static_assert))
        return this._static_assert_statement();
      if (this._check(TokenTypes.tokens.brace_left))
        return this._compound_statement();
      let result = null;
      if (this._check(TokenTypes.keywords.return))
        result = this._return_statement();
      else if (this._check([TokenTypes.keywords.var, TokenTypes.keywords.let, TokenTypes.keywords.const]))
        result = this._variable_statement();
      else if (this._match(TokenTypes.keywords.discard))
        result = new Discard();
      else if (this._match(TokenTypes.keywords.break))
        result = new Break();
      else if (this._match(TokenTypes.keywords.continue))
        result = new Continue();
      else
        result = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
      if (result != null)
        this._consume(TokenTypes.tokens.semicolon, "Expected ';' after statement.");
      return result;
    }
    _static_assert_statement() {
      if (!this._match(TokenTypes.keywords.static_assert))
        return null;
      let expression = this._optional_paren_expression();
      return new StaticAssert(expression);
    }
    _while_statement() {
      if (!this._match(TokenTypes.keywords.while))
        return null;
      let condition = this._optional_paren_expression();
      const block = this._compound_statement();
      return new While(condition, block);
    }
    _continuing_statement() {
      if (!this._match(TokenTypes.keywords.continuing))
        return null;
      const block = this._compound_statement();
      return new Continuing(block);
    }
    _for_statement() {
      if (!this._match(TokenTypes.keywords.for))
        return null;
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      const init = !this._check(TokenTypes.tokens.semicolon) ? this._for_init() : null;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      const condition = !this._check(TokenTypes.tokens.semicolon) ? this._short_circuit_or_expression() : null;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      const increment = !this._check(TokenTypes.tokens.paren_right) ? this._for_increment() : null;
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      const body = this._compound_statement();
      return new For(init, condition, increment, body);
    }
    _for_init() {
      return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
    }
    _for_increment() {
      return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
    }
    _variable_statement() {
      if (this._check(TokenTypes.keywords.var)) {
        const _var = this._variable_decl();
        if (_var === null)
          throw this._error(this._peek(), "Variable declaration expected.");
        let value = null;
        if (this._match(TokenTypes.tokens.equal))
          value = this._short_circuit_or_expression();
        return new Var(_var.name, _var.type, _var.storage, _var.access, value);
      }
      if (this._match(TokenTypes.keywords.let)) {
        const name2 = this._consume(TokenTypes.tokens.ident, "Expected name for let.").toString();
        let type = null;
        if (this._match(TokenTypes.tokens.colon)) {
          const typeAttrs = this._attribute();
          type = this._type_decl();
          if (type != null)
            type.attributes = typeAttrs;
        }
        this._consume(TokenTypes.tokens.equal, "Expected '=' for let.");
        const value = this._short_circuit_or_expression();
        return new Let(name2, type, null, null, value);
      }
      if (this._match(TokenTypes.keywords.const)) {
        const name2 = this._consume(TokenTypes.tokens.ident, "Expected name for const.").toString();
        let type = null;
        if (this._match(TokenTypes.tokens.colon)) {
          const typeAttrs = this._attribute();
          type = this._type_decl();
          if (type != null)
            type.attributes = typeAttrs;
        }
        this._consume(TokenTypes.tokens.equal, "Expected '=' for const.");
        const value = this._short_circuit_or_expression();
        return new Const(name2, type, null, null, value);
      }
      return null;
    }
    _increment_decrement_statement() {
      const savedPos = this._current;
      const _var = this._unary_expression();
      if (_var == null)
        return null;
      if (!this._check(TokenTypes.increment_operators)) {
        this._current = savedPos;
        return null;
      }
      const token = this._consume(TokenTypes.increment_operators, "Expected increment operator");
      return new Increment(token.type === TokenTypes.tokens.plus_plus ? IncrementOperator.increment : IncrementOperator.decrement, _var);
    }
    _assignment_statement() {
      let _var = null;
      if (this._check(TokenTypes.tokens.brace_right))
        return null;
      let isUnderscore = this._match(TokenTypes.tokens.underscore);
      if (!isUnderscore)
        _var = this._unary_expression();
      if (!isUnderscore && _var == null)
        return null;
      const type = this._consume(TokenTypes.assignment_operators, "Expected assignment operator.");
      const value = this._short_circuit_or_expression();
      return new Assign(AssignOperator.parse(type.lexeme), _var, value);
    }
    _func_call_statement() {
      if (!this._check(TokenTypes.tokens.ident))
        return null;
      const savedPos = this._current;
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected function name.");
      const args = this._argument_expression_list();
      if (args === null) {
        this._current = savedPos;
        return null;
      }
      return new Call(name2.lexeme, args);
    }
    _loop_statement() {
      if (!this._match(TokenTypes.keywords.loop))
        return null;
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for loop.");
      const statements = [];
      let statement = this._statement();
      while (statement !== null) {
        if (Array.isArray(statement)) {
          for (let s of statement) {
            statements.push(s);
          }
        } else {
          statements.push(statement);
        }
        statement = this._statement();
      }
      let continuing = null;
      if (this._match(TokenTypes.keywords.continuing))
        continuing = this._compound_statement();
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for loop.");
      return new Loop(statements, continuing);
    }
    _switch_statement() {
      if (!this._match(TokenTypes.keywords.switch))
        return null;
      const condition = this._optional_paren_expression();
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for switch.");
      const body = this._switch_body();
      if (body == null || body.length == 0)
        throw this._error(this._previous(), "Expected 'case' or 'default'.");
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for switch.");
      return new Switch(condition, body);
    }
    _switch_body() {
      const cases = [];
      if (this._match(TokenTypes.keywords.case)) {
        const selector = this._case_selectors();
        this._match(TokenTypes.tokens.colon);
        this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch case.");
        const body = this._case_body();
        this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch case.");
        cases.push(new Case(selector, body));
      }
      if (this._match(TokenTypes.keywords.default)) {
        this._match(TokenTypes.tokens.colon);
        this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch default.");
        const body = this._case_body();
        this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch default.");
        cases.push(new Default(body));
      }
      if (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {
        const _cases = this._switch_body();
        cases.push(_cases[0]);
      }
      return cases;
    }
    _case_selectors() {
      var _a2, _b, _c, _d;
      const selectors = [(_b = (_a2 = this._shift_expression()) === null || _a2 === void 0 ? void 0 : _a2.evaluate(this._context).toString()) !== null && _b !== void 0 ? _b : ""];
      while (this._match(TokenTypes.tokens.comma)) {
        selectors.push((_d = (_c = this._shift_expression()) === null || _c === void 0 ? void 0 : _c.evaluate(this._context).toString()) !== null && _d !== void 0 ? _d : "");
      }
      return selectors;
    }
    _case_body() {
      if (this._match(TokenTypes.keywords.fallthrough)) {
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return [];
      }
      let statement = this._statement();
      if (statement == null)
        return [];
      if (!(statement instanceof Array)) {
        statement = [statement];
      }
      const nextStatement = this._case_body();
      if (nextStatement.length == 0)
        return statement;
      return [...statement, nextStatement[0]];
    }
    _if_statement() {
      if (!this._match(TokenTypes.keywords.if))
        return null;
      const condition = this._optional_paren_expression();
      const block = this._compound_statement();
      let elseif = [];
      if (this._match_elseif()) {
        elseif = this._elseif_statement(elseif);
      }
      let _else = null;
      if (this._match(TokenTypes.keywords.else))
        _else = this._compound_statement();
      return new If(condition, block, elseif, _else);
    }
    _match_elseif() {
      if (this._tokens[this._current].type === TokenTypes.keywords.else && this._tokens[this._current + 1].type === TokenTypes.keywords.if) {
        this._advance();
        this._advance();
        return true;
      }
      return false;
    }
    _elseif_statement(elseif = []) {
      const condition = this._optional_paren_expression();
      const block = this._compound_statement();
      elseif.push(new ElseIf(condition, block));
      if (this._match_elseif()) {
        this._elseif_statement(elseif);
      }
      return elseif;
    }
    _return_statement() {
      if (!this._match(TokenTypes.keywords.return))
        return null;
      const value = this._short_circuit_or_expression();
      return new Return(value);
    }
    _short_circuit_or_expression() {
      let expr = this._short_circuit_and_expr();
      while (this._match(TokenTypes.tokens.or_or)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._short_circuit_and_expr());
      }
      return expr;
    }
    _short_circuit_and_expr() {
      let expr = this._inclusive_or_expression();
      while (this._match(TokenTypes.tokens.and_and)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._inclusive_or_expression());
      }
      return expr;
    }
    _inclusive_or_expression() {
      let expr = this._exclusive_or_expression();
      while (this._match(TokenTypes.tokens.or)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._exclusive_or_expression());
      }
      return expr;
    }
    _exclusive_or_expression() {
      let expr = this._and_expression();
      while (this._match(TokenTypes.tokens.xor)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._and_expression());
      }
      return expr;
    }
    _and_expression() {
      let expr = this._equality_expression();
      while (this._match(TokenTypes.tokens.and)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._equality_expression());
      }
      return expr;
    }
    _equality_expression() {
      const expr = this._relational_expression();
      if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {
        return new BinaryOperator(this._previous().toString(), expr, this._relational_expression());
      }
      return expr;
    }
    _relational_expression() {
      let expr = this._shift_expression();
      while (this._match([TokenTypes.tokens.less_than, TokenTypes.tokens.greater_than, TokenTypes.tokens.less_than_equal, TokenTypes.tokens.greater_than_equal])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._shift_expression());
      }
      return expr;
    }
    _shift_expression() {
      let expr = this._additive_expression();
      while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._additive_expression());
      }
      return expr;
    }
    _additive_expression() {
      let expr = this._multiplicative_expression();
      while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._multiplicative_expression());
      }
      return expr;
    }
    _multiplicative_expression() {
      let expr = this._unary_expression();
      while (this._match([TokenTypes.tokens.star, TokenTypes.tokens.forward_slash, TokenTypes.tokens.modulo])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._unary_expression());
      }
      return expr;
    }
    _unary_expression() {
      if (this._match([TokenTypes.tokens.minus, TokenTypes.tokens.bang, TokenTypes.tokens.tilde, TokenTypes.tokens.star, TokenTypes.tokens.and])) {
        return new UnaryOperator(this._previous().toString(), this._unary_expression());
      }
      return this._singular_expression();
    }
    _singular_expression() {
      const expr = this._primary_expression();
      const p = this._postfix_expression();
      if (p)
        expr.postfix = p;
      return expr;
    }
    _postfix_expression() {
      if (this._match(TokenTypes.tokens.bracket_left)) {
        const expr = this._short_circuit_or_expression();
        this._consume(TokenTypes.tokens.bracket_right, "Expected ']'.");
        const p = this._postfix_expression();
        if (p)
          expr.postfix = p;
        return expr;
      }
      if (this._match(TokenTypes.tokens.period)) {
        const name2 = this._consume(TokenTypes.tokens.ident, "Expected member name.");
        const p = this._postfix_expression();
        const expr = new StringExpr(name2.lexeme);
        if (p)
          expr.postfix = p;
        return expr;
      }
      return null;
    }
    _getStruct(name2) {
      if (this._context.aliases.has(name2)) {
        const alias = this._context.aliases.get(name2).type;
        return alias;
      }
      if (this._context.structs.has(name2)) {
        const struct = this._context.structs.get(name2);
        return struct;
      }
      return null;
    }
    _primary_expression() {
      if (this._match(TokenTypes.tokens.ident)) {
        const name2 = this._previous().toString();
        if (this._check(TokenTypes.tokens.paren_left)) {
          const args2 = this._argument_expression_list();
          const struct = this._getStruct(name2);
          if (struct != null) {
            return new CreateExpr(struct, args2);
          }
          return new CallExpr(name2, args2);
        }
        if (this._context.constants.has(name2)) {
          const c = this._context.constants.get(name2);
          return new ConstExpr(name2, c.value);
        }
        return new VariableExpr(name2);
      }
      if (this._match(TokenTypes.const_literal)) {
        return new LiteralExpr(parseFloat(this._previous().toString()));
      }
      if (this._check(TokenTypes.tokens.paren_left)) {
        return this._paren_expression();
      }
      if (this._match(TokenTypes.keywords.bitcast)) {
        this._consume(TokenTypes.tokens.less_than, "Expected '<'.");
        const type2 = this._type_decl();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
        const value = this._paren_expression();
        return new BitcastExpr(type2, value);
      }
      const type = this._type_decl();
      const args = this._argument_expression_list();
      return new TypecastExpr(type, args);
    }
    _argument_expression_list() {
      if (!this._match(TokenTypes.tokens.paren_left))
        return null;
      const args = [];
      do {
        if (this._check(TokenTypes.tokens.paren_right))
          break;
        const arg = this._short_circuit_or_expression();
        args.push(arg);
      } while (this._match(TokenTypes.tokens.comma));
      this._consume(TokenTypes.tokens.paren_right, "Expected ')' for agument list");
      return args;
    }
    _optional_paren_expression() {
      this._match(TokenTypes.tokens.paren_left);
      const expr = this._short_circuit_or_expression();
      this._match(TokenTypes.tokens.paren_right);
      return new GroupingExpr([expr]);
    }
    _paren_expression() {
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      const expr = this._short_circuit_or_expression();
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      return new GroupingExpr([expr]);
    }
    _struct_decl() {
      if (!this._match(TokenTypes.keywords.struct))
        return null;
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected name for struct.").toString();
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for struct body.");
      const members = [];
      while (!this._check(TokenTypes.tokens.brace_right)) {
        const memberAttrs = this._attribute();
        const memberName = this._consume(TokenTypes.tokens.ident, "Expected variable name.").toString();
        this._consume(TokenTypes.tokens.colon, "Expected ':' for struct member type.");
        const typeAttrs = this._attribute();
        const memberType = this._type_decl();
        if (memberType != null)
          memberType.attributes = typeAttrs;
        if (!this._check(TokenTypes.tokens.brace_right))
          this._consume(TokenTypes.tokens.comma, "Expected ',' for struct member.");
        else
          this._match(TokenTypes.tokens.comma);
        members.push(new Member(memberName, memberType, memberAttrs));
      }
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' after struct body.");
      const structNode = new Struct(name2, members);
      this._context.structs.set(name2, structNode);
      return structNode;
    }
    _global_variable_decl() {
      const _var = this._variable_decl();
      if (_var && this._match(TokenTypes.tokens.equal))
        _var.value = this._const_expression();
      return _var;
    }
    _override_variable_decl() {
      const _override = this._override_decl();
      if (_override && this._match(TokenTypes.tokens.equal))
        _override.value = this._const_expression();
      return _override;
    }
    _global_const_decl() {
      if (!this._match(TokenTypes.keywords.const))
        return null;
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = attrs;
      }
      let value = null;
      if (this._match(TokenTypes.tokens.equal)) {
        const valueExpr = this._short_circuit_or_expression();
        if (valueExpr instanceof CreateExpr) {
          value = valueExpr;
        } else if (valueExpr instanceof ConstExpr && valueExpr.initializer instanceof CreateExpr) {
          value = valueExpr.initializer;
        } else {
          try {
            const constValue = valueExpr.evaluate(this._context);
            value = new LiteralExpr(constValue);
          } catch (_a2) {
            value = valueExpr;
          }
        }
      }
      const c = new Const(name2.toString(), type, "", "", value);
      this._context.constants.set(c.name, c);
      return c;
    }
    _global_let_decl() {
      if (!this._match(TokenTypes.keywords.let))
        return null;
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = attrs;
      }
      let value = null;
      if (this._match(TokenTypes.tokens.equal)) {
        value = this._const_expression();
      }
      return new Let(name2.toString(), type, "", "", value);
    }
    _const_expression() {
      if (this._match(TokenTypes.const_literal))
        return new StringExpr(this._previous().toString());
      const type = this._type_decl();
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      let args = [];
      while (!this._check(TokenTypes.tokens.paren_right)) {
        args.push(this._const_expression());
        if (!this._check(TokenTypes.tokens.comma))
          break;
        this._advance();
      }
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      return new CreateExpr(type, args);
    }
    _variable_decl() {
      if (!this._match(TokenTypes.keywords.var))
        return null;
      let storage = "";
      let access = "";
      if (this._match(TokenTypes.tokens.less_than)) {
        storage = this._consume(TokenTypes.storage_class, "Expected storage_class.").toString();
        if (this._match(TokenTypes.tokens.comma))
          access = this._consume(TokenTypes.access_mode, "Expected access_mode.").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
      }
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = attrs;
      }
      return new Var(name2.toString(), type, storage, access, null);
    }
    _override_decl() {
      if (!this._match(TokenTypes.keywords.override))
        return null;
      const name2 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = attrs;
      }
      return new Override(name2.toString(), type, null);
    }
    _enable_directive() {
      const name2 = this._consume(TokenTypes.tokens.ident, "identity expected.");
      return new Enable(name2.toString());
    }
    _type_alias() {
      const name2 = this._consume(TokenTypes.tokens.ident, "identity expected.");
      this._consume(TokenTypes.tokens.equal, "Expected '=' for type alias.");
      let aliasType = this._type_decl();
      if (aliasType === null) {
        throw this._error(this._peek(), "Expected Type for Alias.");
      }
      if (this._context.aliases.has(aliasType.name)) {
        aliasType = this._context.aliases.get(aliasType.name).type;
      }
      const aliasNode = new Alias(name2.toString(), aliasType);
      this._context.aliases.set(aliasNode.name, aliasNode);
      return aliasNode;
    }
    _type_decl() {
      if (this._check([TokenTypes.tokens.ident, ...TokenTypes.texel_format, TokenTypes.keywords.bool, TokenTypes.keywords.f32, TokenTypes.keywords.i32, TokenTypes.keywords.u32])) {
        const type2 = this._advance();
        const typeName = type2.toString();
        if (this._context.structs.has(typeName)) {
          return this._context.structs.get(typeName);
        }
        if (this._context.aliases.has(typeName)) {
          return this._context.aliases.get(typeName).type;
        }
        return new Type(type2.toString());
      }
      let type = this._texture_sampler_types();
      if (type)
        return type;
      if (this._check(TokenTypes.template_types)) {
        let type2 = this._advance().toString();
        let format = null;
        let access = null;
        if (this._match(TokenTypes.tokens.less_than)) {
          format = this._type_decl();
          access = null;
          if (this._match(TokenTypes.tokens.comma))
            access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
          this._consume(TokenTypes.tokens.greater_than, "Expected '>' for type.");
        }
        return new TemplateType(type2, format, access);
      }
      if (this._match(TokenTypes.keywords.ptr)) {
        let pointer = this._previous().toString();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for pointer.");
        const storage = this._consume(TokenTypes.storage_class, "Expected storage_class for pointer");
        this._consume(TokenTypes.tokens.comma, "Expected ',' for pointer.");
        const decl = this._type_decl();
        let access = null;
        if (this._match(TokenTypes.tokens.comma))
          access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for pointer.");
        return new PointerType(pointer, storage.toString(), decl, access);
      }
      const attrs = this._attribute();
      if (this._match(TokenTypes.keywords.array)) {
        let format = null;
        let countInt = -1;
        const array = this._previous();
        if (this._match(TokenTypes.tokens.less_than)) {
          format = this._type_decl();
          if (this._context.aliases.has(format.name)) {
            format = this._context.aliases.get(format.name).type;
          }
          let count = "";
          if (this._match(TokenTypes.tokens.comma)) {
            let c = this._shift_expression();
            count = c.evaluate(this._context).toString();
          }
          this._consume(TokenTypes.tokens.greater_than, "Expected '>' for array.");
          countInt = count ? parseInt(count) : 0;
        }
        return new ArrayType(array.toString(), attrs, format, countInt);
      }
      return null;
    }
    _texture_sampler_types() {
      if (this._match(TokenTypes.sampler_type))
        return new SamplerType(this._previous().toString(), null, null);
      if (this._match(TokenTypes.depth_texture_type))
        return new SamplerType(this._previous().toString(), null, null);
      if (this._match(TokenTypes.sampled_texture_type) || this._match(TokenTypes.multisampled_texture_type)) {
        const sampler = this._previous();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
        const format = this._type_decl();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
        return new SamplerType(sampler.toString(), format, null);
      }
      if (this._match(TokenTypes.storage_texture_type)) {
        const sampler = this._previous();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
        const format = this._consume(TokenTypes.texel_format, "Invalid texel format.").toString();
        this._consume(TokenTypes.tokens.comma, "Expected ',' after texel format.");
        const access = this._consume(TokenTypes.access_mode, "Expected access mode for storage texture type.").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
        return new SamplerType(sampler.toString(), format, access);
      }
      return null;
    }
    _attribute() {
      let attributes = [];
      while (this._match(TokenTypes.tokens.attr)) {
        const name2 = this._consume(TokenTypes.attribute_name, "Expected attribute name");
        const attr = new Attribute(name2.toString(), null);
        if (this._match(TokenTypes.tokens.paren_left)) {
          attr.value = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
          if (this._check(TokenTypes.tokens.comma)) {
            this._advance();
            do {
              const v = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
              if (!(attr.value instanceof Array)) {
                attr.value = [attr.value];
              }
              attr.value.push(v);
            } while (this._match(TokenTypes.tokens.comma));
          }
          this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
        }
        attributes.push(attr);
      }
      while (this._match(TokenTypes.tokens.attr_left)) {
        if (!this._check(TokenTypes.tokens.attr_right)) {
          do {
            const name2 = this._consume(TokenTypes.attribute_name, "Expected attribute name");
            const attr = new Attribute(name2.toString(), null);
            if (this._match(TokenTypes.tokens.paren_left)) {
              attr.value = [this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString()];
              if (this._check(TokenTypes.tokens.comma)) {
                this._advance();
                do {
                  const v = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
                  attr.value.push(v);
                } while (this._match(TokenTypes.tokens.comma));
              }
              this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
            }
            attributes.push(attr);
          } while (this._match(TokenTypes.tokens.comma));
        }
        this._consume(TokenTypes.tokens.attr_right, "Expected ']]' after attribute declarations");
      }
      if (attributes.length == 0)
        return null;
      return attributes;
    }
  };
  var TypeInfo = class {
    constructor(name2, attributes) {
      this.name = name2;
      this.attributes = attributes;
      this.size = 0;
    }
    get isArray() {
      return false;
    }
    get isStruct() {
      return false;
    }
    get isTemplate() {
      return false;
    }
  };
  var MemberInfo = class {
    constructor(name2, type, attributes) {
      this.name = name2;
      this.type = type;
      this.attributes = attributes;
      this.offset = 0;
      this.size = 0;
    }
    get isArray() {
      return this.type.isArray;
    }
    get isStruct() {
      return this.type.isStruct;
    }
    get isTemplate() {
      return this.type.isTemplate;
    }
    get align() {
      return this.type.isStruct ? this.type.align : 0;
    }
    get members() {
      return this.type.isStruct ? this.type.members : null;
    }
    get format() {
      return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
    }
    get count() {
      return this.type.isArray ? this.type.count : 0;
    }
    get stride() {
      return this.type.isArray ? this.type.stride : this.size;
    }
  };
  var StructInfo = class extends TypeInfo {
    constructor(name2, attributes) {
      super(name2, attributes);
      this.members = [];
      this.align = 0;
    }
    get isStruct() {
      return true;
    }
  };
  var ArrayInfo = class extends TypeInfo {
    constructor(name2, attributes) {
      super(name2, attributes);
      this.count = 0;
      this.stride = 0;
    }
    get isArray() {
      return true;
    }
  };
  var TemplateInfo = class extends TypeInfo {
    constructor(name2, format, attributes, access) {
      super(name2, attributes);
      this.format = format;
      this.access = access;
    }
    get isTemplate() {
      return true;
    }
  };
  var ResourceType;
  (function(ResourceType2) {
    ResourceType2[ResourceType2["Uniform"] = 0] = "Uniform";
    ResourceType2[ResourceType2["Storage"] = 1] = "Storage";
    ResourceType2[ResourceType2["Texture"] = 2] = "Texture";
    ResourceType2[ResourceType2["Sampler"] = 3] = "Sampler";
    ResourceType2[ResourceType2["StorageTexture"] = 4] = "StorageTexture";
  })(ResourceType || (ResourceType = {}));
  var VariableInfo = class {
    constructor(name2, type, group, binding, attributes, resourceType, access) {
      this.name = name2;
      this.type = type;
      this.group = group;
      this.binding = binding;
      this.attributes = attributes;
      this.resourceType = resourceType;
      this.access = access;
    }
    get isArray() {
      return this.type.isArray;
    }
    get isStruct() {
      return this.type.isStruct;
    }
    get isTemplate() {
      return this.type.isTemplate;
    }
    get size() {
      return this.type.size;
    }
    get align() {
      return this.type.isStruct ? this.type.align : 0;
    }
    get members() {
      return this.type.isStruct ? this.type.members : null;
    }
    get format() {
      return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
    }
    get count() {
      return this.type.isArray ? this.type.count : 0;
    }
    get stride() {
      return this.type.isArray ? this.type.stride : this.size;
    }
  };
  var AliasInfo = class {
    constructor(name2, type) {
      this.name = name2;
      this.type = type;
    }
  };
  var _TypeSize = class {
    constructor(align, size) {
      this.align = align;
      this.size = size;
    }
  };
  var InputInfo = class {
    constructor(name2, type, locationType, location) {
      this.name = name2;
      this.type = type;
      this.locationType = locationType;
      this.location = location;
      this.interpolation = null;
    }
  };
  var OutputInfo = class {
    constructor(name2, type, locationType, location) {
      this.name = name2;
      this.type = type;
      this.locationType = locationType;
      this.location = location;
    }
  };
  var FunctionInfo = class {
    constructor(name2, stage = null) {
      this.stage = null;
      this.inputs = [];
      this.outputs = [];
      this.name = name2;
      this.stage = stage;
    }
  };
  var EntryFunctions = class {
    constructor() {
      this.vertex = [];
      this.fragment = [];
      this.compute = [];
    }
  };
  var OverrideInfo = class {
    constructor(name2, type, attributes, id) {
      this.name = name2;
      this.type = type;
      this.attributes = attributes;
      this.id = id;
    }
  };
  var WgslReflect = class {
    constructor(code) {
      this.uniforms = [];
      this.storage = [];
      this.textures = [];
      this.samplers = [];
      this.aliases = [];
      this.overrides = [];
      this.structs = [];
      this.entry = new EntryFunctions();
      this._types = /* @__PURE__ */ new Map();
      if (code) {
        this.update(code);
      }
    }
    _isStorageTexture(type) {
      return type.name == "texture_storage_1d" || type.name == "texture_storage_2d" || type.name == "texture_storage_2d_array" || type.name == "texture_storage_3d";
    }
    update(code) {
      const parser = new WgslParser();
      const ast = parser.parse(code);
      for (const node of ast) {
        if (node instanceof Struct) {
          const info = this._getTypeInfo(node, null);
          if (info instanceof StructInfo) {
            this.structs.push(info);
          }
          continue;
        }
        if (node instanceof Alias) {
          this.aliases.push(this._getAliasInfo(node));
          continue;
        }
        if (node instanceof Override) {
          const v = node;
          const id = this._getAttributeNum(v.attributes, "id", 0);
          const type = v.type != null ? this._getTypeInfo(v.type, v.attributes) : null;
          this.overrides.push(new OverrideInfo(v.name, type, v.attributes, id));
          continue;
        }
        if (this._isUniformVar(node)) {
          const v = node;
          const g = this._getAttributeNum(v.attributes, "group", 0);
          const b = this._getAttributeNum(v.attributes, "binding", 0);
          const type = this._getTypeInfo(v.type, v.attributes);
          const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Uniform, v.access);
          this.uniforms.push(varInfo);
          continue;
        }
        if (this._isStorageVar(node)) {
          const v = node;
          const g = this._getAttributeNum(v.attributes, "group", 0);
          const b = this._getAttributeNum(v.attributes, "binding", 0);
          const type = this._getTypeInfo(v.type, v.attributes);
          const isStorageTexture = this._isStorageTexture(type);
          const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Storage, v.access);
          this.storage.push(varInfo);
          continue;
        }
        if (this._isTextureVar(node)) {
          const v = node;
          const g = this._getAttributeNum(v.attributes, "group", 0);
          const b = this._getAttributeNum(v.attributes, "binding", 0);
          const type = this._getTypeInfo(v.type, v.attributes);
          const isStorageTexture = this._isStorageTexture(type);
          const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Texture, v.access);
          if (isStorageTexture) {
            this.storage.push(varInfo);
          } else {
            this.textures.push(varInfo);
          }
          continue;
        }
        if (this._isSamplerVar(node)) {
          const v = node;
          const g = this._getAttributeNum(v.attributes, "group", 0);
          const b = this._getAttributeNum(v.attributes, "binding", 0);
          const type = this._getTypeInfo(v.type, v.attributes);
          const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Sampler, v.access);
          this.samplers.push(varInfo);
          continue;
        }
        if (node instanceof Function) {
          const vertexStage = this._getAttribute(node, "vertex");
          const fragmentStage = this._getAttribute(node, "fragment");
          const computeStage = this._getAttribute(node, "compute");
          const stage = vertexStage || fragmentStage || computeStage;
          if (stage) {
            const fn = new FunctionInfo(node.name, stage.name);
            fn.inputs = this._getInputs(node.args);
            fn.outputs = this._getOutputs(node.returnType);
            this.entry[stage.name].push(fn);
          }
          continue;
        }
      }
    }
    getBindGroups() {
      const groups = [];
      function _makeRoom(group, binding) {
        if (group >= groups.length)
          groups.length = group + 1;
        if (groups[group] === void 0)
          groups[group] = [];
        if (binding >= groups[group].length)
          groups[group].length = binding + 1;
      }
      for (const u of this.uniforms) {
        _makeRoom(u.group, u.binding);
        const group = groups[u.group];
        group[u.binding] = u;
      }
      for (const u of this.storage) {
        _makeRoom(u.group, u.binding);
        const group = groups[u.group];
        group[u.binding] = u;
      }
      for (const t of this.textures) {
        _makeRoom(t.group, t.binding);
        const group = groups[t.group];
        group[t.binding] = t;
      }
      for (const t of this.samplers) {
        _makeRoom(t.group, t.binding);
        const group = groups[t.group];
        group[t.binding] = t;
      }
      return groups;
    }
    _getOutputs(type, outputs = void 0) {
      if (outputs === void 0)
        outputs = [];
      if (type instanceof Struct) {
        this._getStructOutputs(type, outputs);
      } else {
        const output = this._getOutputInfo(type);
        if (output !== null)
          outputs.push(output);
      }
      return outputs;
    }
    _getStructOutputs(struct, outputs) {
      for (const m of struct.members) {
        if (m.type instanceof Struct) {
          this._getStructOutputs(m.type, outputs);
        } else {
          const location = this._getAttribute(m, "location") || this._getAttribute(m, "builtin");
          if (location !== null) {
            const typeInfo = this._getTypeInfo(m.type, m.type.attributes);
            const locationValue = this._parseInt(location.value);
            const info = new OutputInfo(m.name, typeInfo, location.name, locationValue);
            outputs.push(info);
          }
        }
      }
    }
    _getOutputInfo(type) {
      const location = this._getAttribute(type, "location") || this._getAttribute(type, "builtin");
      if (location !== null) {
        const typeInfo = this._getTypeInfo(type, type.attributes);
        const locationValue = this._parseInt(location.value);
        const info = new OutputInfo("", typeInfo, location.name, locationValue);
        return info;
      }
      return null;
    }
    _getInputs(args, inputs = void 0) {
      if (inputs === void 0)
        inputs = [];
      for (const arg of args) {
        if (arg.type instanceof Struct) {
          this._getStructInputs(arg.type, inputs);
        } else {
          const input = this._getInputInfo(arg);
          if (input !== null)
            inputs.push(input);
        }
      }
      return inputs;
    }
    _getStructInputs(struct, inputs) {
      for (const m of struct.members) {
        if (m.type instanceof Struct) {
          this._getStructInputs(m.type, inputs);
        } else {
          const input = this._getInputInfo(m);
          if (input !== null)
            inputs.push(input);
        }
      }
    }
    _getInputInfo(node) {
      const location = this._getAttribute(node, "location") || this._getAttribute(node, "builtin");
      if (location !== null) {
        const interpolation = this._getAttribute(node, "interpolation");
        const type = this._getTypeInfo(node.type, node.attributes);
        const locationValue = this._parseInt(location.value);
        const info = new InputInfo(node.name, type, location.name, locationValue);
        if (interpolation !== null) {
          info.interpolation = this._parseString(interpolation.value);
        }
        return info;
      }
      return null;
    }
    _parseString(s) {
      if (s instanceof Array) {
        s = s[0];
      }
      return s;
    }
    _parseInt(s) {
      if (s instanceof Array) {
        s = s[0];
      }
      const n = parseInt(s);
      return isNaN(n) ? s : n;
    }
    _getAlias(name2) {
      for (const a of this.aliases) {
        if (a.name == name2)
          return a.type;
      }
      return null;
    }
    _getAliasInfo(node) {
      return new AliasInfo(node.name, this._getTypeInfo(node.type, null));
    }
    _getTypeInfo(type, attributes) {
      if (this._types.has(type)) {
        return this._types.get(type);
      }
      if (type instanceof ArrayType) {
        const a = type;
        const t = this._getTypeInfo(a.format, a.attributes);
        const info2 = new ArrayInfo(a.name, attributes);
        info2.format = t;
        info2.count = a.count;
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof Struct) {
        const s = type;
        const info2 = new StructInfo(s.name, attributes);
        for (const m of s.members) {
          const t = this._getTypeInfo(m.type, m.attributes);
          info2.members.push(new MemberInfo(m.name, t, m.attributes));
        }
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof SamplerType) {
        const s = type;
        const formatIsType = s.format instanceof Type;
        const format = s.format ? formatIsType ? this._getTypeInfo(s.format, null) : new TypeInfo(s.format, null) : null;
        const info2 = new TemplateInfo(s.name, format, attributes, s.access);
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof TemplateType) {
        const t = type;
        const format = t.format ? this._getTypeInfo(t.format, null) : null;
        const info2 = new TemplateInfo(t.name, format, attributes, t.access);
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      const info = new TypeInfo(type.name, attributes);
      this._types.set(type, info);
      this._updateTypeInfo(info);
      return info;
    }
    _updateTypeInfo(type) {
      var _a2, _b;
      const typeSize = this._getTypeSize(type);
      type.size = (_a2 = typeSize === null || typeSize === void 0 ? void 0 : typeSize.size) !== null && _a2 !== void 0 ? _a2 : 0;
      if (type instanceof ArrayInfo) {
        const formatInfo = this._getTypeSize(type["format"]);
        type.stride = (_b = formatInfo === null || formatInfo === void 0 ? void 0 : formatInfo.size) !== null && _b !== void 0 ? _b : 0;
        this._updateTypeInfo(type["format"]);
      }
      if (type instanceof StructInfo) {
        this._updateStructInfo(type);
      }
    }
    _updateStructInfo(struct) {
      var _a2;
      let offset = 0;
      let lastSize = 0;
      let lastOffset = 0;
      let structAlign = 0;
      for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {
        const member = struct.members[mi];
        const sizeInfo = this._getTypeSize(member);
        if (!sizeInfo)
          continue;
        (_a2 = this._getAlias(member.type.name)) !== null && _a2 !== void 0 ? _a2 : member.type;
        const align = sizeInfo.align;
        const size = sizeInfo.size;
        offset = this._roundUp(align, offset + lastSize);
        lastSize = size;
        lastOffset = offset;
        structAlign = Math.max(structAlign, align);
        member.offset = offset;
        member.size = size;
        this._updateTypeInfo(member.type);
      }
      struct.size = this._roundUp(structAlign, lastOffset + lastSize);
      struct.align = structAlign;
    }
    _getTypeSize(type) {
      var _a2;
      if (type === null || type === void 0)
        return null;
      const explicitSize = this._getAttributeNum(type.attributes, "size", 0);
      const explicitAlign = this._getAttributeNum(type.attributes, "align", 0);
      if (type instanceof MemberInfo)
        type = type.type;
      if (type instanceof TypeInfo) {
        const alias = this._getAlias(type.name);
        if (alias !== null) {
          type = alias;
        }
      }
      {
        const info = WgslReflect._typeInfo[type.name];
        if (info !== void 0) {
          const divisor = type["format"] === "f16" ? 2 : 1;
          return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
        }
      }
      {
        const info = WgslReflect._typeInfo[type.name.substring(0, type.name.length - 1)];
        if (info) {
          const divisor = type.name[type.name.length - 1] === "h" ? 2 : 1;
          return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
        }
      }
      if (type instanceof ArrayInfo) {
        let arrayType = type;
        let align = 8;
        let size = 8;
        const E = this._getTypeSize(arrayType.format);
        if (E !== null) {
          size = E.size;
          align = E.align;
        }
        const N = arrayType.count;
        const stride = this._getAttributeNum((_a2 = type === null || type === void 0 ? void 0 : type.attributes) !== null && _a2 !== void 0 ? _a2 : null, "stride", this._roundUp(align, size));
        size = N * stride;
        if (explicitSize)
          size = explicitSize;
        return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));
      }
      if (type instanceof StructInfo) {
        let align = 0;
        let size = 0;
        let offset = 0;
        let lastSize = 0;
        let lastOffset = 0;
        for (const m of type.members) {
          const mi = this._getTypeSize(m.type);
          if (mi !== null) {
            align = Math.max(mi.align, align);
            offset = this._roundUp(mi.align, offset + lastSize);
            lastSize = mi.size;
            lastOffset = offset;
          }
        }
        size = this._roundUp(align, lastOffset + lastSize);
        return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));
      }
      return null;
    }
    _isUniformVar(node) {
      return node instanceof Var && node.storage == "uniform";
    }
    _isStorageVar(node) {
      return node instanceof Var && node.storage == "storage";
    }
    _isTextureVar(node) {
      return node instanceof Var && node.type !== null && WgslReflect._textureTypes.indexOf(node.type.name) != -1;
    }
    _isSamplerVar(node) {
      return node instanceof Var && node.type !== null && WgslReflect._samplerTypes.indexOf(node.type.name) != -1;
    }
    _getAttribute(node, name2) {
      const obj = node;
      if (!obj || !obj["attributes"])
        return null;
      const attrs = obj["attributes"];
      for (let a of attrs) {
        if (a.name == name2)
          return a;
      }
      return null;
    }
    _getAttributeNum(attributes, name2, defaultValue) {
      if (attributes === null)
        return defaultValue;
      for (let a of attributes) {
        if (a.name == name2) {
          let v = a !== null && a.value !== null ? a.value : defaultValue;
          if (v instanceof Array) {
            v = v[0];
          }
          if (typeof v === "number") {
            return v;
          }
          if (typeof v === "string") {
            return parseInt(v);
          }
          return defaultValue;
        }
      }
      return defaultValue;
    }
    _roundUp(k, n) {
      return Math.ceil(n / k) * k;
    }
  };
  WgslReflect._typeInfo = {
    f16: {
      align: 2,
      size: 2
    },
    i32: {
      align: 4,
      size: 4
    },
    u32: {
      align: 4,
      size: 4
    },
    f32: {
      align: 4,
      size: 4
    },
    atomic: {
      align: 4,
      size: 4
    },
    vec2: {
      align: 8,
      size: 8
    },
    vec3: {
      align: 16,
      size: 12
    },
    vec4: {
      align: 16,
      size: 16
    },
    mat2x2: {
      align: 8,
      size: 16
    },
    mat3x2: {
      align: 8,
      size: 24
    },
    mat4x2: {
      align: 8,
      size: 32
    },
    mat2x3: {
      align: 16,
      size: 32
    },
    mat3x3: {
      align: 16,
      size: 48
    },
    mat4x3: {
      align: 16,
      size: 64
    },
    mat2x4: {
      align: 16,
      size: 32
    },
    mat3x4: {
      align: 16,
      size: 48
    },
    mat4x4: {
      align: 16,
      size: 64
    }
  };
  WgslReflect._textureTypes = TokenTypes.any_texture_type.map((t) => {
    return t.name;
  });
  WgslReflect._samplerTypes = TokenTypes.sampler_type.map((t) => {
    return t.name;
  });

  // ../shadertools/src/lib/wgsl/get-shader-layout-wgsl.ts
  function getShaderLayoutFromWGSL(source) {
    const shaderLayout = {
      attributes: [],
      bindings: []
    };
    const parsedWGSL = parseWGSL(source);
    for (const uniform of parsedWGSL.uniforms) {
      const members = [];
      for (const member of uniform.type.members) {
        members.push({
          name: member.name,
          type: getType(member.type)
        });
      }
      shaderLayout.bindings.push({
        type: "uniform",
        name: uniform.name,
        location: uniform.binding,
        group: uniform.group,
        members
      });
    }
    const vertex = parsedWGSL.entry.vertex[0];
    const attributeCount = vertex.inputs.length;
    for (let i = 0; i < attributeCount; i++) {
      const wgslAttribute = vertex.inputs[i];
      if (wgslAttribute.locationType === "location") {
        const type = getType(wgslAttribute.type);
        shaderLayout.attributes.push({
          name: wgslAttribute.name,
          location: wgslAttribute.location,
          type
        });
      }
    }
    return shaderLayout;
  }
  function getType(type) {
    return type.format ? `${type.name}<${type.format.name}>` : type.name;
  }
  function parseWGSL(source) {
    try {
      return new WgslReflect(source);
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      let message = "WGSL parse error";
      if (typeof error === "object" && error?.message) {
        message += `: ${error.message} `;
      }
      if (typeof error === "object" && error?.token) {
        message += error.token.line || "";
      }
      throw new Error(message, {
        cause: error
      });
    }
  }

  // ../../node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || {
    config: {
      ...DEFAULT_CONFIG
    }
  };
  var config = globalThis.mathgl.config;
  function formatValue(value, {
    precision = config.precision
  } = {}) {
    value = round(value);
    return "".concat(parseFloat(value.toPrecision(precision)));
  }
  function isArray(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function equals(a, b, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a === b) {
        return true;
      }
      if (isArray(a) && isArray(b)) {
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; ++i) {
          if (!equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a && a.equals) {
        return a.equals(b);
      }
      if (b && b.equals) {
        return b.equals(a);
      }
      if (typeof a === "number" && typeof b === "number") {
        return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/math-array.js
  function _extendableBuiltin(cls) {
    function ExtendableBuiltin() {
      var instance = Reflect.construct(cls, Array.from(arguments));
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
      return instance;
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype, {
      constructor: {
        value: cls,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ExtendableBuiltin, cls);
    } else {
      ExtendableBuiltin.__proto__ = cls;
    }
    return ExtendableBuiltin;
  }
  var MathArray = class extends _extendableBuiltin(Array) {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        targetArray[offset + i] = this[i];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
      return target ? this.to(target) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    formatString(opts) {
      let string = "";
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += (i > 0 ? ", " : "") + formatValue(this[i], opts);
      }
      return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        if (!equals(this[i], array[i])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
    negate() {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = -this[i];
      }
      return this.check();
    }
    lerp(a, b, t) {
      if (t === void 0) {
        return this.lerp(this, a, b);
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        const ai = a[i];
        const endValue = typeof b === "number" ? b : b[i];
        this[i] = ai + t * (endValue - ai);
      }
      return this.check();
    }
    min(vector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(vector[i], this[i]);
      }
      return this.check();
    }
    max(vector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.max(vector[i], this[i]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] += vector[i];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] -= vector[i];
        }
      }
      return this.check();
    }
    scale(scale2) {
      if (typeof scale2 === "number") {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scale2;
        }
      } else {
        for (let i = 0; i < this.ELEMENTS && i < scale2.length; ++i) {
          this[i] *= scale2[i];
        }
      }
      return this.check();
    }
    multiplyByScalar(scalar) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }
      return this.check();
    }
    check() {
      if (config.debug && !this.validate()) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }
      return this;
    }
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(this[i]);
      }
      return valid;
    }
    sub(a) {
      return this.subtract(a);
    }
    setScalar(a) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = a;
      }
      return this.check();
    }
    addScalar(a) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += a;
      }
      return this.check();
    }
    subScalar(a) {
      return this.addScalar(-a);
    }
    multiplyScalar(scalar) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }
      return this.check();
    }
    divideScalar(a) {
      return this.multiplyByScalar(1 / a);
    }
    clampScalar(min, max) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], min), max);
      }
      return this.check();
    }
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector(v, length) {
    if (v.length !== length) {
      return false;
    }
    for (let i = 0; i < v.length; ++i) {
      if (!Number.isFinite(v[i])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error("Invalid number ".concat(JSON.stringify(value)));
    }
    return value;
  }
  function checkVector(v, length, callerName = "") {
    if (config.debug && !validateVector(v, length)) {
      throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    }
    return v;
  }

  // ../../node_modules/@math.gl/core/dist/lib/assert.js
  function assert4(condition, message) {
    if (!condition) {
      throw new Error("math.gl assertion ".concat(message));
    }
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector = class extends MathArray {
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let length = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        length += this[i] * this[i];
      }
      return length;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        const dist = this[i] - mathArray[i];
        length += dist * dist;
      }
      return checkNumber(length);
    }
    dot(mathArray) {
      let product = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        product += this[i] * mathArray[i];
      }
      return checkNumber(product);
    }
    normalize() {
      const length = this.magnitude();
      if (length !== 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= length;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= vector[i];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= vector[i];
        }
      }
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i) {
      assert4(i >= 0 && i < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i]);
    }
    setComponent(i, value) {
      assert4(i >= 0 && i < this.ELEMENTS, "index is out of range");
      this[i] = value;
      return this.check();
    }
    addVectors(a, b) {
      return this.copy(a).add(b);
    }
    subVectors(a, b) {
      return this.copy(a).subtract(b);
    }
    multiplyVectors(a, b) {
      return this.copy(a).multiply(b);
    }
    addScaledVector(a, b) {
      return this.add(new this.constructor(a).multiplyScalar(b));
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create() {
    const out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat4(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  var forEach = function() {
    const vec = create();
    return function(a, stride, offset, count, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a, m) {
    const x = a[0];
    const y = a[1];
    const w = m[3] * x + m[7] * y || 1;
    out[0] = (m[0] * x + m[4] * y) / w;
    out[1] = (m[1] * x + m[5] * y) / w;
    return out;
  }
  function vec3_transformMat4AsVector(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = m[3] * x + m[7] * y + m[11] * z || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
  }
  function vec3_transformMat2(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a[2];
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  function create2() {
    const out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    const ax = a[0];
    const ay = a[1];
    const az = a[2];
    const bx = b[0];
    const by = b[1];
    const bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat42(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    let w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat3(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a, q) {
    const qx = q[0];
    const qy = q[1];
    const qz = q[2];
    const qw = q[3];
    const x = a[0];
    const y = a[1];
    const z = a[2];
    let uvx = qy * z - qz * y;
    let uvy = qz * x - qx * z;
    let uvz = qx * y - qy * x;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX(out, a, b, rad) {
    const p = [];
    const r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY(out, a, b, rad) {
    const p = [];
    const r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ(out, a, b, rad) {
    const p = [];
    const r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a, b) {
    const ax = a[0];
    const ay = a[1];
    const az = a[2];
    const bx = b[0];
    const by = b[1];
    const bz = b[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var forEach2 = function() {
    const vec = create2();
    return function(a, stride, offset, count, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN = [0, 0, 0];
  var ZERO;
  var Vector3 = class extends Vector {
    static get ZERO() {
      if (!ZERO) {
        ZERO = new Vector3(0, 0, 0);
        Object.freeze(ZERO);
      }
      return ZERO;
    }
    constructor(x = 0, y = 0, z = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray(x)) {
        this.copy(x);
      } else {
        if (config.debug) {
          checkNumber(x);
          checkNumber(y);
          checkNumber(z);
        }
        this[0] = x;
        this[1] = y;
        this[2] = z;
      }
    }
    set(x, y, z) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    angle(vector) {
      return angle(this, vector);
    }
    cross(vector) {
      cross(this, this, vector);
      return this.check();
    }
    rotateX({
      radians,
      origin = ORIGIN
    }) {
      rotateX(this, this, origin, radians);
      return this.check();
    }
    rotateY({
      radians,
      origin = ORIGIN
    }) {
      rotateY(this, this, origin, radians);
      return this.check();
    }
    rotateZ({
      radians,
      origin = ORIGIN
    }) {
      rotateZ(this, this, origin, radians);
      return this.check();
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion) {
      transformQuat(this, this, quaternion);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix = class extends MathArray {
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += " ".concat(this[col * this.RANK + row]);
          }
        }
      } else {
        string += "column-major:";
        for (let i = 0; i < this.ELEMENTS; ++i) {
          string += " ".concat(this[i]);
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i = 0; i < this.RANK; ++i) {
        result[i] = this[firstIndex + i];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i = 0; i < this.RANK; ++i) {
        this[firstIndex + i] = columnVector[i];
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a12 = a[6];
      const a13 = a[7];
      const a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert(out, a) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant(a) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate(out, a, rad, axis) {
    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x * x + y * y + z * z);
    let c;
    let s;
    let t;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len < EPSILON) {
      return null;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX2(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY2(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ2(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function fromQuat(out, q) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const yx = y * x2;
    const yy = y * y2;
    const zx = z * x2;
    const zy = z * y2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function orthoNO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function lookAt(out, eye, center, up) {
    let len;
    let x0;
    let x1;
    let x2;
    let y0;
    let y1;
    let y2;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  function create3() {
    const out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function transformMat43(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  var forEach3 = function() {
    const vec = create3();
    return function(a, stride, offset, count, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/matrix4.js
  var INDICES;
  (function(INDICES2) {
    INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES2[INDICES2["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES2[INDICES2["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES2[INDICES2["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES2[INDICES2["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES2[INDICES2["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES2[INDICES2["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES2[INDICES2["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES2[INDICES2["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES2[INDICES2["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES2[INDICES2["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES2[INDICES2["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES2[INDICES2["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES2[INDICES2["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES || (INDICES = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(quaternion) {
      fromQuat(this, quaternion);
      return this.check();
    }
    frustum(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    lookAt(view) {
      const {
        eye,
        center = [0, 0, 0],
        up = [0, 1, 0]
      } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    ortho(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    orthographic(view) {
      const {
        fovy = DEFAULT_FOVY,
        aspect = DEFAULT_ASPECT,
        focalDistance = 1,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    perspective(view) {
      const {
        fovy = 45 * Math.PI / 180,
        aspect = 1,
        near = 0.1,
        far = 500
      } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    determinant() {
      return determinant(this);
    }
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale2 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale2[0];
      const inverseScale1 = 1 / scale2[1];
      const inverseScale2 = 1 / scale2[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale2 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale2[0];
      const inverseScale1 = 1 / scale2[1];
      const inverseScale2 = 1 / scale2[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    multiplyLeft(a) {
      multiply(this, a, this);
      return this.check();
    }
    multiplyRight(a) {
      multiply(this, this, a);
      return this.check();
    }
    rotateX(radians) {
      rotateX2(this, this, radians);
      return this.check();
    }
    rotateY(radians) {
      rotateY2(this, this, radians);
      return this.check();
    }
    rotateZ(radians) {
      rotateZ2(this, this, radians);
      return this.check();
    }
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians, axis) {
      rotate(this, this, radians, axis);
      return this.check();
    }
    scale(factor) {
      scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    translate(vector) {
      translate(this, this, vector);
      return this.check();
    }
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
      const {
        length
      } = vector;
      let out;
      switch (length) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    makeRotationX(radians) {
      return this.identity().rotateX(radians);
    }
    makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  };
  var ZERO2;
  var IDENTITY;
  function getZeroMatrix() {
    if (!ZERO2) {
      ZERO2 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO2);
    }
    return ZERO2;
  }
  function getIdentityMatrix() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // src/shader-inputs.ts
  var ShaderInputs = class {
    constructor(modules) {
      const allModules = resolveModules(Object.values(modules));
      log.log(1, "Creating ShaderInputs with modules", allModules.map((m) => m.name))();
      this.modules = modules;
      this.moduleUniforms = {};
      this.moduleBindings = {};
      for (const [name2, module] of Object.entries(modules)) {
        const moduleName = name2;
        this.moduleUniforms[moduleName] = module.defaultUniforms || {};
        this.moduleBindings[moduleName] = {};
      }
    }
    destroy() {
    }
    setProps(props) {
      for (const name2 of Object.keys(props)) {
        const moduleName = name2;
        const moduleProps = props[moduleName];
        const module = this.modules[moduleName];
        if (!module) {
          log.warn(`Module ${name2} not found`)();
          continue;
        }
        const oldUniforms = this.moduleUniforms[moduleName];
        const uniforms = module.getUniforms?.(moduleProps, this.moduleUniforms[moduleName]) || moduleProps;
        this.moduleUniforms[moduleName] = {
          ...oldUniforms,
          ...uniforms
        };
      }
    }
    getModules() {
      return Object.values(this.modules);
    }
    getUniformValues() {
      return this.moduleUniforms;
    }
    getBindings() {
      const bindings = {};
      for (const moduleBindings of Object.values(this.moduleBindings)) {
        Object.assign(bindings, moduleBindings);
      }
      return bindings;
    }
    getDebugTable() {
      const table = {};
      for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {
        for (const [key, value] of Object.entries(module)) {
          table[`${moduleName}.${key}`] = {
            type: this.modules[moduleName].uniformTypes?.[key],
            value: String(value)
          };
        }
      }
      return table;
    }
  };

  // src/geometry/gpu-geometry.ts
  var GPUGeometry = class {
    userData = {};
    bufferLayout = [];
    constructor(props) {
      this.id = props.id || uid("geometry");
      this.topology = props.topology;
      this.indices = props.indices || null;
      this.attributes = props.attributes;
      this.vertexCount = props.vertexCount;
      this.bufferLayout = props.bufferLayout || [];
      if (this.indices) {
        assert2(this.indices.usage === Buffer2.INDEX);
      }
    }
    destroy() {
      this.indices.destroy();
      this.attributes.positions.destroy();
      this.attributes.normals.destroy();
      this.attributes.texCoords.destroy();
      this.attributes.colors?.destroy();
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getIndexes() {
      return this.indices;
    }
    _calculateVertexCount(positions) {
      const vertexCount = positions.byteLength / 12;
      return vertexCount;
    }
  };
  function makeGPUGeometry(device, geometry) {
    if (geometry instanceof GPUGeometry) {
      return geometry;
    }
    const indices = getIndexBufferFromGeometry(device, geometry);
    const {
      attributes,
      bufferLayout
    } = getAttributeBuffersFromGeometry(device, geometry);
    return new GPUGeometry({
      topology: geometry.topology || "triangle-list",
      bufferLayout,
      vertexCount: geometry.vertexCount,
      indices,
      attributes
    });
  }
  function getIndexBufferFromGeometry(device, geometry) {
    if (!geometry.indices) {
      return void 0;
    }
    const data = geometry.indices.value;
    return device.createBuffer({
      usage: Buffer2.INDEX,
      data
    });
  }
  function getAttributeBuffersFromGeometry(device, geometry) {
    const bufferLayout = [];
    const attributes = {};
    for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {
      let name2 = attributeName;
      switch (attributeName) {
        case "POSITION":
          name2 = "positions";
          break;
        case "NORMAL":
          name2 = "normals";
          break;
        case "TEXCOORD_0":
          name2 = "texCoords";
          break;
        case "COLOR_0":
          name2 = "colors";
          break;
      }
      attributes[name2] = device.createBuffer({
        data: attribute.value,
        id: `${attributeName}-buffer`
      });
      const {
        value,
        size,
        normalized
      } = attribute;
      bufferLayout.push({
        name: name2,
        format: getVertexFormatFromAttribute(value, size, normalized)
      });
    }
    const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);
    return {
      attributes,
      bufferLayout,
      vertexCount
    };
  }

  // src/lib/pipeline-factory.ts
  var _PipelineFactory = class {
    _hashCounter = 0;
    _hashes = {};
    _useCounts = {};
    _pipelineCache = {};
    static getDefaultPipelineFactory(device) {
      device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new _PipelineFactory(device);
      return device._lumaData.defaultPipelineFactory;
    }
    constructor(device) {
      this.device = device;
    }
    createRenderPipeline(options) {
      const props = {
        ..._PipelineFactory.defaultProps,
        ...options
      };
      const hash = this._hashRenderPipeline({
        ...props
      });
      if (!this._pipelineCache[hash]) {
        const pipeline = this.device.createRenderPipeline({
          ...props,
          vs: this.device.createShader({
            stage: "vertex",
            source: props.vs
          }),
          fs: props.fs ? this.device.createShader({
            stage: "fragment",
            source: props.fs
          }) : null
        });
        pipeline.hash = hash;
        this._pipelineCache[hash] = pipeline;
        this._useCounts[hash] = 0;
      }
      this._useCounts[hash]++;
      return this._pipelineCache[hash];
    }
    release(pipeline) {
      const hash = pipeline.hash;
      this._useCounts[hash]--;
      if (this._useCounts[hash] === 0) {
        this._pipelineCache[hash].destroy();
        delete this._pipelineCache[hash];
        delete this._useCounts[hash];
      }
    }
    _hashRenderPipeline(props) {
      const vsHash = this._getHash(props.vs);
      const fsHash = props.fs ? this._getHash(props.fs) : 0;
      const varyingHash = "-";
      switch (this.device.info.type) {
        case "webgpu":
          const parameterHash = this._getHash(JSON.stringify(props.parameters));
          const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
          return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}}`;
        default:
          return `${vsHash}/${fsHash}V${varyingHash}`;
      }
    }
    _getHash(key) {
      if (this._hashes[key] === void 0) {
        this._hashes[key] = this._hashCounter++;
      }
      return this._hashes[key];
    }
  };
  var PipelineFactory = _PipelineFactory;
  __publicField(PipelineFactory, "defaultProps", {
    ...RenderPipeline.defaultProps,
    vs: void 0,
    fs: void 0
  });

  // src/debug/debug-shader-layout.ts
  function getDebugTableForShaderLayout(layout, name2) {
    const table = {};
    const header = "Values";
    if (layout.attributes.length === 0 && !layout.varyings?.length) {
      return {
        "No attributes or varyings": {
          [header]: "N/A"
        }
      };
    }
    for (const attributeDeclaration of layout.attributes) {
      if (attributeDeclaration) {
        const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
        table[`in ${glslDeclaration}`] = {
          [header]: attributeDeclaration.stepMode || "vertex"
        };
      }
    }
    for (const varyingDeclaration of layout.varyings || []) {
      const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
      table[`out ${glslDeclaration}`] = {
        [header]: JSON.stringify(varyingDeclaration.accessor)
      };
    }
    return table;
  }

  // src/debug/debug-framebuffer.ts
  var canvas = null;
  var ctx = null;
  function debugFramebuffer(fbo, {
    id,
    minimap,
    opaque,
    top = "0",
    left = "0",
    rgbaScale = 1
  }) {
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.id = id;
      canvas.title = id;
      canvas.style.zIndex = "100";
      canvas.style.position = "absolute";
      canvas.style.top = top;
      canvas.style.left = left;
      canvas.style.border = "blue 1px solid";
      canvas.style.transform = "scaleY(-1)";
      document.body.appendChild(canvas);
      ctx = canvas.getContext("2d");
    }
    if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
      canvas.width = fbo.width / 2;
      canvas.height = fbo.height / 2;
      canvas.style.width = "400px";
      canvas.style.height = "400px";
    }
    const color = fbo.device.readPixelsToArrayWebGL(fbo);
    const imageData = ctx.createImageData(fbo.width, fbo.height);
    const offset = 0;
    for (let i = 0; i < color.length; i += 4) {
      imageData.data[offset + i + 0] = color[i + 0] * rgbaScale;
      imageData.data[offset + i + 1] = color[i + 1] * rgbaScale;
      imageData.data[offset + i + 2] = color[i + 2] * rgbaScale;
      imageData.data[offset + i + 3] = opaque ? 255 : color[i + 3] * rgbaScale;
    }
    ctx.putImageData(imageData, 0, 0);
  }

  // src/model/model.ts
  var LOG_DRAW_PRIORITY = 2;
  var LOG_DRAW_TIMEOUT = 1e4;
  var _Model = class {
    userData = {};
    instanceCount = 0;
    indexBuffer = null;
    bufferAttributes = {};
    constantAttributes = {};
    bindings = {};
    uniforms = {};
    transformFeedback = null;
    _pipelineNeedsUpdate = "newly created";
    _attributeInfos = {};
    _gpuGeometry = null;
    constructor(device, props) {
      this.props = {
        ..._Model.defaultProps,
        ...props
      };
      props = this.props;
      this.id = props.id || uid("model");
      this.device = device;
      Object.assign(this.userData, props.userData);
      const moduleMap = Object.fromEntries(this.props.modules?.map((module) => [module.name, module]) || []);
      this.setShaderInputs(props.shaderInputs || new ShaderInputs(moduleMap));
      const isWebGPU = this.device.info.type === "webgpu";
      if (this.props.source) {
        if (isWebGPU) {
          this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);
        }
        this.props.fs = this.props.source;
        this.props.vs = this.props.source;
      }
      if (isWebGPU && typeof this.props.vs !== "string") {
        this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.vs.wgsl);
      }
      const platformInfo = getPlatformInfo(device);
      const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
      const {
        vs,
        fs,
        getUniforms
      } = this.props.shaderAssembler.assembleShaders({
        platformInfo,
        ...this.props,
        modules
      });
      this.vs = vs;
      this.fs = fs;
      this._getModuleUniforms = getUniforms;
      this.vertexCount = this.props.vertexCount;
      this.instanceCount = this.props.instanceCount;
      this.topology = this.props.topology;
      this.bufferLayout = this.props.bufferLayout;
      this.parameters = this.props.parameters;
      if (props.geometry) {
        this._gpuGeometry = this.setGeometry(props.geometry);
      }
      this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
      this.pipeline = this._updatePipeline();
      this.vertexArray = device.createVertexArray({
        renderPipeline: this.pipeline
      });
      if (this._gpuGeometry) {
        this._setGeometryAttributes(this._gpuGeometry);
      }
      if (props.vertexCount) {
        this.setVertexCount(props.vertexCount);
      }
      if (props.instanceCount) {
        this.setInstanceCount(props.instanceCount);
      }
      if (props.indices) {
        throw new Error("Model.props.indices removed. Use props.indexBuffer");
      }
      if (props.indexBuffer) {
        this.setIndexBuffer(props.indexBuffer);
      }
      if (props.attributes) {
        this.setAttributes(props.attributes);
      }
      if (props.constantAttributes) {
        this.setConstantAttributes(props.constantAttributes);
      }
      if (props.bindings) {
        this.setBindings(props.bindings);
      }
      if (props.uniforms) {
        this.setUniforms(props.uniforms);
      }
      if (props.moduleSettings) {
        log.warn("Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()")();
        this.updateModuleSettings(props.moduleSettings);
      }
      if (props.transformFeedback) {
        this.transformFeedback = props.transformFeedback;
      }
      Object.seal(this);
    }
    destroy() {
      this.pipelineFactory.release(this.pipeline);
      this._uniformStore.destroy();
    }
    predraw() {
      this.updateShaderInputs();
    }
    draw(renderPass) {
      this.predraw();
      try {
        this._logDrawCallStart();
        this.pipeline = this._updatePipeline();
        this.pipeline.setBindings(this.bindings);
        this.pipeline.setUniforms(this.uniforms);
        const {
          indexBuffer
        } = this.vertexArray;
        const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === "uint32" ? 4 : 2) : void 0;
        this.pipeline.draw({
          renderPass,
          vertexArray: this.vertexArray,
          vertexCount: this.vertexCount,
          instanceCount: this.instanceCount,
          indexCount,
          transformFeedback: this.transformFeedback
        });
      } finally {
        this._logDrawCallEnd();
      }
      this._logFramebuffer(renderPass);
    }
    setGeometry(geometry) {
      const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);
      this.setTopology(gpuGeometry.topology || "triangle-list");
      this.bufferLayout = mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
      if (this.vertexArray) {
        this._setGeometryAttributes(gpuGeometry);
      }
      return gpuGeometry;
    }
    _setGeometryAttributes(gpuGeometry) {
      const attributes = {
        ...gpuGeometry.attributes
      };
      for (const [attributeName] of Object.entries(attributes)) {
        if (!this.pipeline.shaderLayout.attributes.find((layout) => layout.name === attributeName) && attributeName !== "positions") {
          delete attributes[attributeName];
        }
      }
      this.vertexCount = gpuGeometry.vertexCount;
      this.setIndexBuffer(gpuGeometry.indices);
      this.setAttributes(gpuGeometry.attributes, "ignore-unknown");
      this.setAttributes(attributes);
    }
    setTopology(topology) {
      if (topology !== this.topology) {
        this.topology = topology;
        this._setPipelineNeedsUpdate("topology");
      }
    }
    setBufferLayout(bufferLayout) {
      this.bufferLayout = this._gpuGeometry ? mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
      this._setPipelineNeedsUpdate("bufferLayout");
      this.pipeline = this._updatePipeline();
      this.vertexArray = this.device.createVertexArray({
        renderPipeline: this.pipeline
      });
      if (this._gpuGeometry) {
        this._setGeometryAttributes(this._gpuGeometry);
      }
    }
    setParameters(parameters) {
      if (!deepEqual(parameters, this.parameters, 2)) {
        this.parameters = parameters;
        this._setPipelineNeedsUpdate("parameters");
      }
    }
    setVertexCount(vertexCount) {
      this.vertexCount = vertexCount;
    }
    setInstanceCount(instanceCount) {
      this.instanceCount = instanceCount;
    }
    setShaderInputs(shaderInputs) {
      this.shaderInputs = shaderInputs;
      this._uniformStore = new UniformStore(this.shaderInputs.modules);
      for (const moduleName of Object.keys(this.shaderInputs.modules)) {
        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
      }
    }
    setShaderModuleProps(props) {
      const uniforms = this._getModuleUniforms(props);
      const keys = Object.keys(uniforms).filter((k) => {
        const uniform = uniforms[k];
        return !isNumberArray(uniform) && typeof uniform !== "number" && typeof uniform !== "boolean";
      });
      const bindings = {};
      for (const k of keys) {
        bindings[k] = uniforms[k];
        delete uniforms[k];
      }
    }
    updateShaderInputs() {
      this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
    }
    updateModuleSettings(props) {
      log.warn("Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()")();
      const {
        bindings,
        uniforms
      } = splitUniformsAndBindings(this._getModuleUniforms(props));
      Object.assign(this.bindings, bindings);
      Object.assign(this.uniforms, uniforms);
    }
    setBindings(bindings) {
      Object.assign(this.bindings, bindings);
    }
    setUniforms(uniforms) {
      this.pipeline.setUniforms(uniforms);
      Object.assign(this.uniforms, uniforms);
    }
    setIndexBuffer(indexBuffer) {
      this.vertexArray.setIndexBuffer(indexBuffer);
    }
    setTransformFeedback(transformFeedback) {
      this.transformFeedback = transformFeedback;
    }
    setAttributes(buffers, _option) {
      if (buffers.indices) {
        log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
      }
      for (const [bufferName, buffer] of Object.entries(buffers)) {
        const bufferLayout = this.bufferLayout.find((layout) => getAttributeNames(layout).includes(bufferName));
        if (!bufferLayout) {
          log.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
          continue;
        }
        const attributeNames = getAttributeNames(bufferLayout);
        let set = false;
        for (const attributeName of attributeNames) {
          const attributeInfo = this._attributeInfos[attributeName];
          if (attributeInfo) {
            this.vertexArray.setBuffer(attributeInfo.location, buffer);
            set = true;
          }
        }
        if (!set && _option !== "ignore-unknown") {
          log.warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
        }
      }
    }
    setConstantAttributes(attributes) {
      for (const [attributeName, value] of Object.entries(attributes)) {
        const attributeInfo = this._attributeInfos[attributeName];
        if (attributeInfo) {
          this.vertexArray.setConstant(attributeInfo.location, value);
        } else {
          log.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
        }
      }
    }
    _setPipelineNeedsUpdate(reason) {
      this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;
    }
    _updatePipeline() {
      if (this._pipelineNeedsUpdate) {
        if (this.pipeline) {
          log.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
        }
        this._pipelineNeedsUpdate = false;
        const vs = this.device.createShader({
          id: `${this.id}-vertex`,
          stage: "vertex",
          source: this.vs
        });
        const fs = this.fs ? this.device.createShader({
          id: `${this.id}-fragment`,
          stage: "fragment",
          source: this.fs
        }) : null;
        this.pipeline = this.device.createRenderPipeline({
          ...this.props,
          bufferLayout: this.bufferLayout,
          topology: this.topology,
          parameters: this.parameters,
          vs,
          fs
        });
        this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
      }
      return this.pipeline;
    }
    _lastLogTime = 0;
    _logOpen = false;
    _logDrawCallStart() {
      const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
      if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
        return;
      }
      this._lastLogTime = Date.now();
      this._logOpen = true;
      log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {
        collapsed: log.level <= 2
      })();
    }
    _logDrawCallEnd() {
      if (this._logOpen) {
        const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
        log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
        const uniformTable = this.shaderInputs.getDebugTable();
        for (const [name2, value] of Object.entries(this.uniforms)) {
          uniformTable[name2] = {
            value
          };
        }
        log.table(LOG_DRAW_PRIORITY, uniformTable)();
        const attributeTable = this._getAttributeDebugTable();
        log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
        log.table(LOG_DRAW_PRIORITY, attributeTable)();
        log.groupEnd(LOG_DRAW_PRIORITY)();
        this._logOpen = false;
      }
    }
    _drawCount = 0;
    _logFramebuffer(renderPass) {
      const debugFramebuffers = log.get("framebuffer");
      this._drawCount++;
      if (!debugFramebuffers || this._drawCount++ > 3 && this._drawCount % 60) {
        return;
      }
      const framebuffer = renderPass.props.framebuffer;
      if (framebuffer) {
        debugFramebuffer(framebuffer, {
          id: framebuffer.id,
          minimap: true
        });
      }
    }
    _getAttributeDebugTable() {
      const table = {};
      for (const [name2, attributeInfo] of Object.entries(this._attributeInfos)) {
        table[attributeInfo.location] = {
          name: name2,
          type: attributeInfo.shaderType,
          values: this._getBufferOrConstantValues(this.vertexArray.attributes[attributeInfo.location], attributeInfo.bufferDataType)
        };
      }
      if (this.vertexArray.indexBuffer) {
        const {
          indexBuffer
        } = this.vertexArray;
        const values = indexBuffer.indexType === "uint32" ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
        table.indices = {
          name: "indices",
          type: indexBuffer.indexType,
          values: values.toString()
        };
      }
      return table;
    }
    _getBufferOrConstantValues(attribute, dataType) {
      const TypedArrayConstructor = getTypedArrayFromDataType(dataType);
      const typedArray = attribute instanceof Buffer2 ? new TypedArrayConstructor(attribute.debugData) : attribute;
      return typedArray.toString();
    }
  };
  var Model = _Model;
  __publicField(Model, "defaultProps", {
    ...RenderPipeline.defaultProps,
    source: null,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    moduleSettings: void 0,
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    shaderInputs: void 0,
    pipelineFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler()
  });
  function mergeBufferLayouts(layouts1, layouts2) {
    const layouts = [...layouts1];
    for (const attribute of layouts2) {
      const index2 = layouts.findIndex((attribute2) => attribute2.name === attribute.name);
      if (index2 < 0) {
        layouts.push(attribute);
      } else {
        layouts[index2] = attribute;
      }
    }
    return layouts;
  }
  function getPlatformInfo(device) {
    return {
      type: device.info.type,
      shaderLanguage: device.info.shadingLanguage,
      shaderLanguageVersion: device.info.shadingLanguageVersion,
      gpu: device.info.gpu,
      features: device.features
    };
  }
  function getAttributeNames(bufferLayout) {
    return bufferLayout.attributes ? bufferLayout.attributes?.map((layout) => layout.attribute) : [bufferLayout.name];
  }

  // src/transform/buffer-transform.ts
  var BufferTransform = class {
    static isSupported(device) {
      return device.features.has("transform-feedback-webgl2");
    }
    constructor(device, props = Model.defaultProps) {
      assert2(device.features.has("transform-feedback-webgl2"), "Device must support transform feedback");
      this.device = device;
      this.model = new Model(this.device, {
        id: props.id || "buffer-transform-model",
        fs: props.fs || getPassthroughFS({
          version: 300
        }),
        topology: props.topology || "point-list",
        ...props
      });
      this.transformFeedback = this.device.createTransformFeedback({
        layout: this.model.pipeline.shaderLayout,
        buffers: props.feedbackBuffers
      });
      this.model.setTransformFeedback(this.transformFeedback);
      Object.seal(this);
    }
    destroy() {
      if (this.model) {
        this.model.destroy();
      }
    }
    delete() {
      this.destroy();
    }
    run(options) {
      const renderPass = this.device.beginRenderPass(options);
      this.model.draw(renderPass);
      renderPass.end();
    }
    update(...args) {
      console.warn("TextureTransform#update() not implemented");
    }
    getBuffer(varyingName) {
      return this.transformFeedback.getBuffer(varyingName);
    }
    readAsync(varyingName) {
      const result = this.getBuffer(varyingName);
      if (result instanceof Buffer2) {
        return result.readAsync();
      }
      const {
        buffer,
        byteOffset = 0,
        byteLength = buffer.byteLength
      } = result;
      return buffer.readAsync(byteOffset, byteLength);
    }
  };

  // src/transform/texture-transform.ts
  var FS_OUTPUT_VARIABLE = "transform_output";
  var TextureTransform = class {
    currentIndex = 0;
    samplerTextureMap = null;
    bindings = [];
    resources = {};
    constructor(device, props) {
      this.device = device;
      this.sampler = device.createSampler({
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge",
        minFilter: "nearest",
        magFilter: "nearest",
        mipmapFilter: "nearest"
      });
      this.model = new Model(this.device, {
        id: props.id || "texture-transform-model",
        fs: props.fs || getPassthroughFS({
          version: 300,
          input: props.targetTextureVarying,
          inputChannels: props.targetTextureChannels,
          output: FS_OUTPUT_VARIABLE
        }),
        vertexCount: props.vertexCount,
        ...props
      });
      this._initialize(props);
      Object.seal(this);
    }
    destroy() {
    }
    delete() {
      this.destroy();
    }
    run(options) {
      const {
        framebuffer
      } = this.bindings[this.currentIndex];
      const renderPass = this.device.beginRenderPass({
        framebuffer,
        ...options
      });
      this.model.draw(renderPass);
      renderPass.end();
    }
    update(...args) {
      console.warn("TextureTransform#update() not implemented");
    }
    getData({
      packed = false
    } = {}) {
      throw new Error("getData() not implemented");
    }
    getTargetTexture() {
      const {
        targetTexture
      } = this.bindings[this.currentIndex];
      return targetTexture;
    }
    getFramebuffer() {
      const currentResources = this.bindings[this.currentIndex];
      return currentResources.framebuffer;
    }
    _initialize(props) {
      this._updateBindings(props);
    }
    _updateBindings(props) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);
    }
    _updateBinding(binding, {
      sourceBuffers,
      sourceTextures,
      targetTexture
    }) {
      if (!binding) {
        binding = {
          sourceBuffers: {},
          sourceTextures: {},
          targetTexture: null
        };
      }
      Object.assign(binding.sourceTextures, sourceTextures);
      Object.assign(binding.sourceBuffers, sourceBuffers);
      if (targetTexture) {
        binding.targetTexture = targetTexture;
        const {
          width,
          height
        } = targetTexture;
        if (binding.framebuffer) {
          binding.framebuffer.destroy();
        }
        binding.framebuffer = this.device.createFramebuffer({
          id: "transform-framebuffer",
          width,
          height,
          colorAttachments: [targetTexture]
        });
        binding.framebuffer.resize({
          width,
          height
        });
      }
      return binding;
    }
    _setSourceTextureParameters() {
      const index2 = this.currentIndex;
      const {
        sourceTextures
      } = this.bindings[index2];
      for (const name2 in sourceTextures) {
        sourceTextures[name2].sampler = this.sampler;
      }
    }
  };

  // src/geometry/geometry.ts
  var Geometry = class {
    userData = {};
    constructor(props) {
      const {
        attributes = {},
        indices = null,
        vertexCount = null
      } = props;
      this.id = props.id || uid("geometry");
      this.topology = props.topology;
      if (indices) {
        this.indices = ArrayBuffer.isView(indices) ? {
          value: indices,
          size: 1
        } : indices;
      }
      this.attributes = {};
      for (const [attributeName, attributeValue] of Object.entries(attributes)) {
        const attribute = ArrayBuffer.isView(attributeValue) ? {
          value: attributeValue
        } : attributeValue;
        assert2(ArrayBuffer.isView(attribute.value), `${this._print(attributeName)}: must be typed array or object with value as typed array`);
        if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
          attribute.size = 3;
        }
        if (attributeName === "indices") {
          assert2(!this.indices);
          this.indices = attribute;
        } else {
          this.attributes[attributeName] = attribute;
        }
      }
      if (this.indices && this.indices.isIndexed !== void 0) {
        this.indices = Object.assign({}, this.indices);
        delete this.indices.isIndexed;
      }
      this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.indices ? {
        indices: this.indices,
        ...this.attributes
      } : this.attributes;
    }
    _print(attributeName) {
      return `Geometry ${this.id} attribute ${attributeName}`;
    }
    _setAttributes(attributes, indices) {
      return this;
    }
    _calculateVertexCount(attributes, indices) {
      if (indices) {
        return indices.value.length;
      }
      let vertexCount = Infinity;
      for (const attribute of Object.values(attributes)) {
        const {
          value,
          size,
          constant
        } = attribute;
        if (!constant && value && size >= 1) {
          vertexCount = Math.min(vertexCount, value.length / size);
        }
      }
      assert2(Number.isFinite(vertexCount));
      return vertexCount;
    }
  };

  // src/lib/clip-space.ts
  var CLIPSPACE_VERTEX_SHADER = glsl`\
#version 300 es
in vec2 aClipSpacePosition;
in vec2 aTexCoord;
in vec2 aCoordinate;

out vec2 position;
out vec2 coordinate;
out vec2 uv;

void main(void) {
  gl_Position = vec4(aClipSpacePosition, 0., 1.);
  position = aClipSpacePosition;
  coordinate = aCoordinate;
  uv = aTexCoord;
}
`;
  var POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
  var ClipSpace = class extends Model {
    constructor(device, opts) {
      const TEX_COORDS = POSITIONS.map((coord) => coord === -1 ? 0 : coord);
      super(device, {
        ...opts,
        vs: CLIPSPACE_VERTEX_SHADER,
        vertexCount: 4,
        geometry: new Geometry({
          topology: "triangle-strip",
          vertexCount: 4,
          attributes: {
            aClipSpacePosition: {
              size: 2,
              value: new Float32Array(POSITIONS)
            },
            aTexCoord: {
              size: 2,
              value: new Float32Array(TEX_COORDS)
            },
            aCoordinate: {
              size: 2,
              value: new Float32Array(TEX_COORDS)
            }
          }
        })
      });
    }
  };

  // src/scenegraph/scenegraph-node.ts
  var ScenegraphNode = class {
    matrix = new Matrix4();
    display = true;
    position = new Vector3();
    rotation = new Vector3();
    scale = new Vector3(1, 1, 1);
    userData = {};
    props = {};
    constructor(props = {}) {
      const {
        id
      } = props;
      this.id = id || uid(this.constructor.name);
      this._setScenegraphNodeProps(props);
    }
    getBounds() {
      return null;
    }
    destroy() {
    }
    delete() {
      this.destroy();
    }
    setProps(props) {
      this._setScenegraphNodeProps(props);
      return this;
    }
    toString() {
      return `{type: ScenegraphNode, id: ${this.id})}`;
    }
    setPosition(position) {
      assert2(position.length === 3, "setPosition requires vector argument");
      this.position = position;
      return this;
    }
    setRotation(rotation) {
      assert2(rotation.length === 3, "setRotation requires vector argument");
      this.rotation = rotation;
      return this;
    }
    setScale(scale2) {
      assert2(scale2.length === 3, "setScale requires vector argument");
      this.scale = scale2;
      return this;
    }
    setMatrix(matrix, copyMatrix = true) {
      if (copyMatrix) {
        this.matrix.copy(matrix);
      } else {
        this.matrix = matrix;
      }
    }
    setMatrixComponents(components) {
      const {
        position,
        rotation,
        scale: scale2,
        update = true
      } = components;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale2) {
        this.setScale(scale2);
      }
      if (update) {
        this.updateMatrix();
      }
      return this;
    }
    updateMatrix() {
      const pos = this.position;
      const rot = this.rotation;
      const scale2 = this.scale;
      this.matrix.identity();
      this.matrix.translate(pos);
      this.matrix.rotateXYZ(rot);
      this.matrix.scale(scale2);
      return this;
    }
    update(options = {}) {
      const {
        position,
        rotation,
        scale: scale2
      } = options;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale2) {
        this.setScale(scale2);
      }
      this.updateMatrix();
      return this;
    }
    getCoordinateUniforms(viewMatrix, modelMatrix) {
      assert2(viewMatrix);
      modelMatrix = modelMatrix || this.matrix;
      const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);
      const worldInverse = worldMatrix.invert();
      const worldInverseTranspose = worldInverse.transpose();
      return {
        viewMatrix,
        modelMatrix,
        objectMatrix: modelMatrix,
        worldMatrix,
        worldInverseMatrix: worldInverse,
        worldInverseTransposeMatrix: worldInverseTranspose
      };
    }
    _setScenegraphNodeProps(props) {
      if ("display" in props) {
        this.display = props.display;
      }
      if ("position" in props) {
        this.setPosition(props.position);
      }
      if ("rotation" in props) {
        this.setRotation(props.rotation);
      }
      if ("scale" in props) {
        this.setScale(props.scale);
      }
      if ("matrix" in props) {
        this.setMatrix(props.matrix);
      }
      Object.assign(this.props, props);
    }
  };

  // src/scenegraph/group-node.ts
  var GroupNode = class extends ScenegraphNode {
    constructor(props = {}) {
      props = Array.isArray(props) ? {
        children: props
      } : props;
      const {
        children = []
      } = props;
      log.assert(children.every((child) => child instanceof ScenegraphNode), "every child must an instance of ScenegraphNode");
      super(props);
      this.children = children;
    }
    getBounds() {
      const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
      this.traverse((node, {
        worldMatrix
      }) => {
        const bounds = node.getBounds();
        if (!bounds) {
          return;
        }
        const [min, max] = bounds;
        const center = new Vector3(min).add(max).divide([2, 2, 2]);
        worldMatrix.transformAsPoint(center, center);
        const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);
        worldMatrix.transformAsVector(halfSize, halfSize);
        for (let v = 0; v < 8; v++) {
          const position = new Vector3(v & 1 ? -1 : 1, v & 2 ? -1 : 1, v & 4 ? -1 : 1).multiply(halfSize).add(center);
          for (let i = 0; i < 3; i++) {
            result[0][i] = Math.min(result[0][i], position[i]);
            result[1][i] = Math.max(result[1][i], position[i]);
          }
        }
      });
      if (!Number.isFinite(result[0][0])) {
        return null;
      }
      return result;
    }
    destroy() {
      this.children.forEach((child) => child.destroy());
      this.removeAll();
      super.destroy();
    }
    add(...children) {
      for (const child of children) {
        if (Array.isArray(child)) {
          this.add(...child);
        } else {
          this.children.push(child);
        }
      }
      return this;
    }
    remove(child) {
      const children = this.children;
      const indexOf = children.indexOf(child);
      if (indexOf > -1) {
        children.splice(indexOf, 1);
      }
      return this;
    }
    removeAll() {
      this.children = [];
      return this;
    }
    traverse(visitor, {
      worldMatrix = new Matrix4()
    } = {}) {
      const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);
      for (const child of this.children) {
        if (child instanceof GroupNode) {
          child.traverse(visitor, {
            worldMatrix: modelMatrix
          });
        } else {
          visitor(child, {
            worldMatrix: modelMatrix
          });
        }
      }
    }
  };

  // src/scenegraph/model-node.ts
  var ModelNode = class extends ScenegraphNode {
    bounds = null;
    constructor(props) {
      super(props);
      this.model = props.model;
      this.managedResources = props.managedResources || [];
      this.bounds = props.bounds || null;
      this.setProps(props);
    }
    getBounds() {
      return this.bounds;
    }
    destroy() {
      if (this.model) {
        this.model.destroy();
        this.model = null;
      }
      this.managedResources.forEach((resource) => resource.destroy());
      this.managedResources = [];
    }
    draw(renderPass) {
      return this.model.draw(renderPass);
    }
  };

  // src/geometries/truncated-cone-geometry.ts
  var INDEX_OFFSETS = {
    x: [2, 0, 1],
    y: [0, 1, 2],
    z: [1, 2, 0]
  };
  var TruncatedConeGeometry = class extends Geometry {
    constructor(props = {}) {
      const {
        id = uid("truncated-code-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselateTruncatedCone(props);
      super({
        ...props,
        id,
        topology: "triangle-list",
        indices,
        attributes: {
          POSITION: {
            size: 3,
            value: attributes.POSITION
          },
          NORMAL: {
            size: 3,
            value: attributes.NORMAL
          },
          TEXCOORD_0: {
            size: 2,
            value: attributes.TEXCOORD_0
          },
          ...props.attributes
        }
      });
    }
  };
  function tesselateTruncatedCone(props = {}) {
    const {
      bottomRadius = 0,
      topRadius = 0,
      height = 1,
      nradial = 10,
      nvertical = 10,
      verticalAxis = "y",
      topCap = false,
      bottomCap = false
    } = props;
    const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
    const numVertices = (nradial + 1) * (nvertical + 1 + extra);
    const slant = Math.atan2(bottomRadius - topRadius, height);
    const msin = Math.sin;
    const mcos = Math.cos;
    const mpi = Math.PI;
    const cosSlant = mcos(slant);
    const sinSlant = msin(slant);
    const start = topCap ? -2 : 0;
    const end = nvertical + (bottomCap ? 2 : 0);
    const vertsAroundEdge = nradial + 1;
    const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
    const indexOffset = INDEX_OFFSETS[verticalAxis];
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const texCoords = new Float32Array(numVertices * 2);
    let i3 = 0;
    let i2 = 0;
    for (let i = start; i <= end; i++) {
      let v = i / nvertical;
      let y = height * v;
      let ringRadius;
      if (i < 0) {
        y = 0;
        v = 1;
        ringRadius = bottomRadius;
      } else if (i > nvertical) {
        y = height;
        v = 1;
        ringRadius = topRadius;
      } else {
        ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
      }
      if (i === -2 || i === nvertical + 2) {
        ringRadius = 0;
        v = 0;
      }
      y -= height / 2;
      for (let j = 0; j < vertsAroundEdge; j++) {
        const sin = msin(j * mpi * 2 / nradial);
        const cos = mcos(j * mpi * 2 / nradial);
        positions[i3 + indexOffset[0]] = sin * ringRadius;
        positions[i3 + indexOffset[1]] = y;
        positions[i3 + indexOffset[2]] = cos * ringRadius;
        normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
        normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
        normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;
        texCoords[i2 + 0] = j / nradial;
        texCoords[i2 + 1] = v;
        i2 += 2;
        i3 += 3;
      }
    }
    for (let i = 0; i < nvertical + extra; i++) {
      for (let j = 0; j < nradial; j++) {
        const index2 = (i * nradial + j) * 6;
        indices[index2 + 0] = vertsAroundEdge * (i + 0) + 0 + j;
        indices[index2 + 1] = vertsAroundEdge * (i + 0) + 1 + j;
        indices[index2 + 2] = vertsAroundEdge * (i + 1) + 1 + j;
        indices[index2 + 3] = vertsAroundEdge * (i + 0) + 0 + j;
        indices[index2 + 4] = vertsAroundEdge * (i + 1) + 1 + j;
        indices[index2 + 5] = vertsAroundEdge * (i + 1) + 0 + j;
      }
    }
    return {
      indices,
      attributes: {
        POSITION: positions,
        NORMAL: normals,
        TEXCOORD_0: texCoords
      }
    };
  }

  // src/geometries/cone-geometry.ts
  var ConeGeometry = class extends TruncatedConeGeometry {
    constructor(props = {}) {
      const {
        id = uid("cone-geometry"),
        radius = 1,
        cap = true
      } = props;
      super({
        ...props,
        id,
        topRadius: 0,
        topCap: Boolean(cap),
        bottomCap: Boolean(cap),
        bottomRadius: radius
      });
    }
  };

  // src/geometries/cube-geometry.ts
  var CubeGeometry = class extends Geometry {
    constructor(props = {}) {
      const {
        id = uid("cube-geometry"),
        indices = true
      } = props;
      super(indices ? {
        ...props,
        id,
        topology: "triangle-list",
        indices: {
          size: 1,
          value: CUBE_INDICES
        },
        attributes: {
          ...ATTRIBUTES,
          ...props.attributes
        }
      } : {
        ...props,
        id,
        topology: "triangle-list",
        indices: void 0,
        attributes: {
          ...NON_INDEXED_ATTRIBUTES,
          ...props.attributes
        }
      });
    }
  };
  var CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
  var CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
  var CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
  var CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
  var CUBE_NON_INDEXED_POSITIONS = new Float32Array([1, -1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1]);
  var CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0]);
  var CUBE_NON_INDEXED_COLORS = new Float32Array([1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1]);
  var ATTRIBUTES = {
    POSITION: {
      size: 3,
      value: CUBE_POSITIONS
    },
    NORMAL: {
      size: 3,
      value: CUBE_NORMALS
    },
    TEXCOORD_0: {
      size: 2,
      value: CUBE_TEX_COORDS
    }
  };
  var NON_INDEXED_ATTRIBUTES = {
    POSITION: {
      size: 3,
      value: CUBE_NON_INDEXED_POSITIONS
    },
    TEXCOORD_0: {
      size: 2,
      value: CUBE_NON_INDEXED_TEX_COORDS
    },
    COLOR_0: {
      size: 3,
      value: CUBE_NON_INDEXED_COLORS
    }
  };

  // src/geometries/cylinder-geometry.ts
  var CylinderGeometry = class extends TruncatedConeGeometry {
    constructor(props = {}) {
      const {
        id = uid("cylinder-geometry"),
        radius = 1
      } = props;
      super({
        ...props,
        id,
        bottomRadius: radius,
        topRadius: radius
      });
    }
  };

  // src/geometries/ico-sphere-geometry.ts
  var ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
  var ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];
  var IcoSphereGeometry = class extends Geometry {
    constructor(props = {}) {
      const {
        id = uid("ico-sphere-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselateIcosaHedron(props);
      super({
        ...props,
        id,
        topology: "triangle-list",
        indices,
        attributes: {
          ...attributes,
          ...props.attributes
        }
      });
    }
  };
  function tesselateIcosaHedron(props) {
    const {
      iterations = 0
    } = props;
    const PI = Math.PI;
    const PI2 = PI * 2;
    const positions = [...ICO_POSITIONS];
    let indices = [...ICO_INDICES];
    positions.push();
    indices.push();
    const getMiddlePoint = (() => {
      const pointMemo = {};
      return (i1, i2) => {
        i1 *= 3;
        i2 *= 3;
        const mini = i1 < i2 ? i1 : i2;
        const maxi = i1 > i2 ? i1 : i2;
        const key = `${mini}|${maxi}`;
        if (key in pointMemo) {
          return pointMemo[key];
        }
        const x1 = positions[i1];
        const y1 = positions[i1 + 1];
        const z1 = positions[i1 + 2];
        const x2 = positions[i2];
        const y2 = positions[i2 + 1];
        const z2 = positions[i2 + 2];
        let xm = (x1 + x2) / 2;
        let ym = (y1 + y2) / 2;
        let zm = (z1 + z2) / 2;
        const len = Math.sqrt(xm * xm + ym * ym + zm * zm);
        xm /= len;
        ym /= len;
        zm /= len;
        positions.push(xm, ym, zm);
        return pointMemo[key] = positions.length / 3 - 1;
      };
    })();
    for (let i = 0; i < iterations; i++) {
      const indices2 = [];
      for (let j = 0; j < indices.length; j += 3) {
        const a = getMiddlePoint(indices[j + 0], indices[j + 1]);
        const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
        const c = getMiddlePoint(indices[j + 2], indices[j + 0]);
        indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
      }
      indices = indices2;
    }
    const normals = new Array(positions.length);
    const texCoords = new Array(positions.length / 3 * 2);
    const l = indices.length;
    for (let i = l - 3; i >= 0; i -= 3) {
      const i1 = indices[i + 0];
      const i2 = indices[i + 1];
      const i3 = indices[i + 2];
      const in1 = i1 * 3;
      const in2 = i2 * 3;
      const in3 = i3 * 3;
      const iu1 = i1 * 2;
      const iu2 = i2 * 2;
      const iu3 = i3 * 2;
      const x1 = positions[in1 + 0];
      const y1 = positions[in1 + 1];
      const z1 = positions[in1 + 2];
      const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
      const phi1 = Math.atan2(y1, x1) + PI;
      const v1 = theta1 / PI;
      const u1 = 1 - phi1 / PI2;
      const x2 = positions[in2 + 0];
      const y2 = positions[in2 + 1];
      const z2 = positions[in2 + 2];
      const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
      const phi2 = Math.atan2(y2, x2) + PI;
      const v2 = theta2 / PI;
      const u2 = 1 - phi2 / PI2;
      const x3 = positions[in3 + 0];
      const y3 = positions[in3 + 1];
      const z3 = positions[in3 + 2];
      const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
      const phi3 = Math.atan2(y3, x3) + PI;
      const v3 = theta3 / PI;
      const u3 = 1 - phi3 / PI2;
      const vec1 = [x3 - x2, y3 - y2, z3 - z2];
      const vec2 = [x1 - x2, y1 - y2, z1 - z2];
      const normal = new Vector3(vec1).cross(vec2).normalize();
      let newIndex;
      if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
        positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v1;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;
        positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v2;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;
        positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v3;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;
      }
      normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
      normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
      normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
      texCoords[iu1 + 0] = u1;
      texCoords[iu1 + 1] = v1;
      texCoords[iu2 + 0] = u2;
      texCoords[iu2 + 1] = v2;
      texCoords[iu3 + 0] = u3;
      texCoords[iu3 + 1] = v3;
    }
    return {
      indices: {
        size: 1,
        value: new Uint16Array(indices)
      },
      attributes: {
        POSITION: {
          size: 3,
          value: new Float32Array(positions)
        },
        NORMAL: {
          size: 3,
          value: new Float32Array(normals)
        },
        TEXCOORD_0: {
          size: 2,
          value: new Float32Array(texCoords)
        }
      }
    };
  }

  // src/geometry/geometry-utils.ts
  function unpackIndexedGeometry(geometry) {
    const {
      indices,
      attributes
    } = geometry;
    if (!indices) {
      return geometry;
    }
    const vertexCount = indices.value.length;
    const unpackedAttributes = {};
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const {
        constant,
        value,
        size
      } = attribute;
      if (constant || !size) {
        continue;
      }
      const unpackedValue = new value.constructor(vertexCount * size);
      for (let x = 0; x < vertexCount; ++x) {
        const index2 = indices.value[x];
        for (let i = 0; i < size; i++) {
          unpackedValue[x * size + i] = value[index2 * size + i];
        }
      }
      unpackedAttributes[attributeName] = {
        size,
        value: unpackedValue
      };
    }
    return {
      attributes: Object.assign({}, attributes, unpackedAttributes)
    };
  }

  // src/geometries/plane-geometry.ts
  var PlaneGeometry = class extends Geometry {
    constructor(props = {}) {
      const {
        id = uid("plane-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselatePlane(props);
      super({
        ...props,
        id,
        topology: "triangle-list",
        indices,
        attributes: {
          ...attributes,
          ...props.attributes
        }
      });
    }
  };
  function tesselatePlane(props) {
    const {
      type = "x,y",
      offset = 0,
      flipCull = false,
      unpack = false
    } = props;
    const coords = type.split(",");
    let c1len = props[`${coords[0]}len`] || 1;
    const c2len = props[`${coords[1]}len`] || 1;
    const subdivisions1 = props[`n${coords[0]}`] || 1;
    const subdivisions2 = props[`n${coords[1]}`] || 1;
    const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const texCoords = new Float32Array(numVertices * 2);
    if (flipCull) {
      c1len = -c1len;
    }
    let i2 = 0;
    let i3 = 0;
    for (let z = 0; z <= subdivisions2; z++) {
      for (let x = 0; x <= subdivisions1; x++) {
        const u = x / subdivisions1;
        const v = z / subdivisions2;
        texCoords[i2 + 0] = flipCull ? 1 - u : u;
        texCoords[i2 + 1] = v;
        switch (type) {
          case "x,y":
            positions[i3 + 0] = c1len * u - c1len * 0.5;
            positions[i3 + 1] = c2len * v - c2len * 0.5;
            positions[i3 + 2] = offset;
            normals[i3 + 0] = 0;
            normals[i3 + 1] = 0;
            normals[i3 + 2] = flipCull ? 1 : -1;
            break;
          case "x,z":
            positions[i3 + 0] = c1len * u - c1len * 0.5;
            positions[i3 + 1] = offset;
            positions[i3 + 2] = c2len * v - c2len * 0.5;
            normals[i3 + 0] = 0;
            normals[i3 + 1] = flipCull ? 1 : -1;
            normals[i3 + 2] = 0;
            break;
          case "y,z":
            positions[i3 + 0] = offset;
            positions[i3 + 1] = c1len * u - c1len * 0.5;
            positions[i3 + 2] = c2len * v - c2len * 0.5;
            normals[i3 + 0] = flipCull ? 1 : -1;
            normals[i3 + 1] = 0;
            normals[i3 + 2] = 0;
            break;
          default:
            throw new Error("PlaneGeometry: unknown type");
        }
        i2 += 2;
        i3 += 3;
      }
    }
    const numVertsAcross = subdivisions1 + 1;
    const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);
    for (let z = 0; z < subdivisions2; z++) {
      for (let x = 0; x < subdivisions1; x++) {
        const index2 = (z * subdivisions1 + x) * 6;
        indices[index2 + 0] = (z + 0) * numVertsAcross + x;
        indices[index2 + 1] = (z + 1) * numVertsAcross + x;
        indices[index2 + 2] = (z + 0) * numVertsAcross + x + 1;
        indices[index2 + 3] = (z + 1) * numVertsAcross + x;
        indices[index2 + 4] = (z + 1) * numVertsAcross + x + 1;
        indices[index2 + 5] = (z + 0) * numVertsAcross + x + 1;
      }
    }
    const geometry = {
      indices: {
        size: 1,
        value: indices
      },
      attributes: {
        POSITION: {
          size: 3,
          value: positions
        },
        NORMAL: {
          size: 3,
          value: normals
        },
        TEXCOORD_0: {
          size: 2,
          value: texCoords
        }
      }
    };
    return unpack ? unpackIndexedGeometry(geometry) : geometry;
  }

  // src/geometries/sphere-geometry.ts
  var SphereGeometry = class extends Geometry {
    constructor(props = {}) {
      const {
        id = uid("sphere-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselateSphere(props);
      super({
        ...props,
        id,
        topology: "triangle-list",
        indices,
        attributes: {
          ...attributes,
          ...props.attributes
        }
      });
    }
  };
  function tesselateSphere(props) {
    const {
      nlat = 10,
      nlong = 10
    } = props;
    const startLat = 0;
    const endLat = Math.PI;
    const latRange = endLat - startLat;
    const startLong = 0;
    const endLong = 2 * Math.PI;
    const longRange = endLong - startLong;
    const numVertices = (nlat + 1) * (nlong + 1);
    const radius = (n1, n2, n3, u, v) => props.radius || 1;
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const texCoords = new Float32Array(numVertices * 2);
    const IndexType = numVertices > 65535 ? Uint32Array : Uint16Array;
    const indices = new IndexType(nlat * nlong * 6);
    for (let y = 0; y <= nlat; y++) {
      for (let x = 0; x <= nlong; x++) {
        const u = x / nlong;
        const v = y / nlat;
        const index2 = x + y * (nlong + 1);
        const i2 = index2 * 2;
        const i3 = index2 * 3;
        const theta = longRange * u;
        const phi = latRange * v;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const sinPhi = Math.sin(phi);
        const cosPhi = Math.cos(phi);
        const ux = cosTheta * sinPhi;
        const uy = cosPhi;
        const uz = sinTheta * sinPhi;
        const r = radius(ux, uy, uz, u, v);
        positions[i3 + 0] = r * ux;
        positions[i3 + 1] = r * uy;
        positions[i3 + 2] = r * uz;
        normals[i3 + 0] = ux;
        normals[i3 + 1] = uy;
        normals[i3 + 2] = uz;
        texCoords[i2 + 0] = u;
        texCoords[i2 + 1] = 1 - v;
      }
    }
    const numVertsAround = nlong + 1;
    for (let x = 0; x < nlong; x++) {
      for (let y = 0; y < nlat; y++) {
        const index2 = (x * nlat + y) * 6;
        indices[index2 + 0] = y * numVertsAround + x;
        indices[index2 + 1] = y * numVertsAround + x + 1;
        indices[index2 + 2] = (y + 1) * numVertsAround + x;
        indices[index2 + 3] = (y + 1) * numVertsAround + x;
        indices[index2 + 4] = y * numVertsAround + x + 1;
        indices[index2 + 5] = (y + 1) * numVertsAround + x + 1;
      }
    }
    return {
      indices: {
        size: 1,
        value: indices
      },
      attributes: {
        POSITION: {
          size: 3,
          value: positions
        },
        NORMAL: {
          size: 3,
          value: normals
        },
        TEXCOORD_0: {
          size: 2,
          value: texCoords
        }
      }
    };
  }
  return __toCommonJS(src_exports);
})();
      return __exports__;
      });
