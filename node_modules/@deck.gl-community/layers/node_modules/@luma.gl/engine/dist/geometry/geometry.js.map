{"version":3,"file":"geometry.js","names":["uid","assert","Geometry","constructor","props","id","topology","vertexCount","indices","attributes","userData","ArrayBuffer","isView","value","size","attributeName","attributeValue","Object","entries","attribute","_print","isIndexed","undefined","assign","_calculateVertexCount","getVertexCount","getAttributes","_setAttributes","length","Infinity","values","constant","Math","min","Number","isFinite"],"sources":["../../src/geometry/geometry.ts"],"sourcesContent":["// luma.gl, MIT license\nimport type {PrimitiveTopology, TypedArray} from '@luma.gl/core';\nimport {uid, assert} from '@luma.gl/core';\n\nexport type GeometryProps = {\n  id?: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology:\n    | 'point-list'\n    | 'line-list'\n    | 'line-strip'\n    | 'line-loop-webgl'\n    | 'triangle-list'\n    | 'triangle-strip'\n    | 'triangle-fan-webgl';\n  /** Auto calculated from attributes if not provided */\n  vertexCount?: number;\n  attributes?: Record<string, GeometryAttribute | TypedArray>;\n  indices?: GeometryAttribute | TypedArray;\n};\n\nexport type GeometryAttributes = {\n  POSITION: GeometryAttribute;\n  NORMAL: GeometryAttribute;\n  TEXCOORD_0: GeometryAttribute;\n  COLOR_0?: GeometryAttribute;\n  indices?: GeometryAttribute & {size: 1; value: Uint32Array | Uint16Array};\n};\n\nexport type GeometryAttribute = {\n  size?: number;\n  value: TypedArray;\n  [key: string]: any;\n};\n\nexport class Geometry {\n  readonly id: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  readonly topology?: PrimitiveTopology;\n  readonly vertexCount: number;\n  readonly indices?: GeometryAttribute;\n  readonly attributes: {\n    POSITION: GeometryAttribute;\n    NORMAL: GeometryAttribute;\n    TEXCOORD_0: GeometryAttribute;\n    COLOR_0?: GeometryAttribute;\n    [key: string]: GeometryAttribute | undefined;\n  };\n\n  userData: Record<string, unknown> = {};\n\n  constructor(props: GeometryProps) {\n    const {attributes = {}, indices = null, vertexCount = null} = props;\n\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    // @ts-expect-error\n    this.attributes = {};\n\n    for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      const attribute: GeometryAttribute = ArrayBuffer.isView(attributeValue)\n        ? {value: attributeValue}\n        : attributeValue;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n  }\n\n  getVertexCount(): number {\n    return this.vertexCount;\n  }\n\n  /** \n   * Return an object with all attributes plus indices added as a field.\n   * TODO Geometry types are a mess\n   */\n  getAttributes(): GeometryAttributes {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName: string): string {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  /**\n   * GeometryAttribute\n   * value: typed array\n   * type: indices, vertices, uvs\n   * size: elements per vertex\n   * target: WebGL buffer type (string or constant)\n   * \n   * @param attributes \n   * @param indices \n   * @returns \n   */\n  _setAttributes(attributes: Record<string, GeometryAttribute>, indices: any): this {\n    return this;\n  }\n\n  _calculateVertexCount(attributes: GeometryAttributes, indices: GeometryAttribute): number {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attribute of Object.values(attributes)) {\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n"],"mappings":"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"}