import { uid, assert } from '@luma.gl/core';
export class Geometry {
  constructor(props) {
    this.id = void 0;
    this.topology = void 0;
    this.vertexCount = void 0;
    this.indices = void 0;
    this.attributes = void 0;
    this.userData = {};
    const {
      attributes = {},
      indices = null,
      vertexCount = null
    } = props;
    this.id = props.id || uid('geometry');
    this.topology = props.topology;
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? {
        value: indices,
        size: 1
      } : indices;
    }
    this.attributes = {};
    for (const [attributeName, attributeValue] of Object.entries(attributes)) {
      const attribute = ArrayBuffer.isView(attributeValue) ? {
        value: attributeValue
      } : attributeValue;
      assert(ArrayBuffer.isView(attribute.value), `${this._print(attributeName)}: must be typed array or object with value as typed array`);
      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
        attribute.size = 3;
      }
      if (attributeName === 'indices') {
        assert(!this.indices);
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }
    if (this.indices && this.indices.isIndexed !== undefined) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }
    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  _print(attributeName) {
    return `Geometry ${this.id} attribute ${attributeName}`;
  }
  _setAttributes(attributes, indices) {
    return this;
  }
  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }
    let vertexCount = Infinity;
    for (const attribute of Object.values(attributes)) {
      const {
        value,
        size,
        constant
      } = attribute;
      if (!constant && value && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }
    assert(Number.isFinite(vertexCount));
    return vertexCount;
  }
}
//# sourceMappingURL=geometry.js.map