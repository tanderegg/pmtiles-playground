{"version":3,"file":"gpu-geometry.js","names":["Buffer","uid","assert","getVertexFormatFromAttribute","GPUGeometry","constructor","props","id","userData","topology","bufferLayout","vertexCount","indices","attributes","usage","INDEX","destroy","_this$attributes$colo","positions","normals","texCoords","colors","getVertexCount","getAttributes","getIndexes","_calculateVertexCount","byteLength","makeGPUGeometry","device","geometry","getIndexBufferFromGeometry","getAttributeBuffersFromGeometry","undefined","data","value","createBuffer","attributeName","attribute","Object","entries","name","size","normalized","push","format"],"sources":["../../src/geometry/gpu-geometry.ts"],"sourcesContent":["import type {PrimitiveTopology, BufferLayout} from '@luma.gl/core';\nimport {Device, Buffer, uid, assert, getVertexFormatFromAttribute} from '@luma.gl/core';\nimport type {Geometry} from '../geometry/geometry';\n\nexport type GPUGeometryProps = {\n  id?: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology:\n    | 'point-list'\n    | 'line-list'\n    | 'line-strip'\n    | 'line-loop-webgl'\n    | 'triangle-list'\n    | 'triangle-strip'\n    | 'triangle-fan-webgl';\n  /** Auto calculated from attributes if not provided */\n  vertexCount: number;\n  bufferLayout: BufferLayout[];\n  indices?: Buffer | null;\n  attributes: Record<string, Buffer>;\n};\n\nexport class GPUGeometry {\n  readonly id: string;\n  userData: Record<string, unknown> = {};\n\n  /** Determines how vertices are read from the 'vertex' attributes */\n  readonly topology?: PrimitiveTopology;\n  readonly bufferLayout: BufferLayout[] = [];\n\n  readonly vertexCount: number;\n  readonly indices?: Buffer | null;\n  readonly attributes: Record<string, Buffer>;\n\n  constructor(props: GPUGeometryProps) {\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n    this.indices = props.indices || null;\n    this.attributes = props.attributes;\n\n    this.vertexCount = props.vertexCount;\n\n    this.bufferLayout = props.bufferLayout || [];\n\n    if (this.indices) {\n      assert(this.indices.usage === Buffer.INDEX);\n    }\n  }\n\n  destroy(): void {\n    this.indices.destroy();\n    this.attributes.positions.destroy();\n    this.attributes.normals.destroy();\n    this.attributes.texCoords.destroy();\n    this.attributes.colors?.destroy();\n  }\n\n  getVertexCount(): number {\n    return this.vertexCount;\n  }\n\n  getAttributes(): Record<string, Buffer> {\n    return this.attributes;\n  }\n\n  getIndexes(): Buffer | null {\n    return this.indices;\n  }\n\n  _calculateVertexCount(positions: Buffer): number {\n    // Assume that positions is a fully packed float32x3 buffer\n    const vertexCount = positions.byteLength / 12;\n    return vertexCount;\n  }\n}\n\nexport function makeGPUGeometry(device: Device, geometry: Geometry | GPUGeometry): GPUGeometry {\n  if (geometry instanceof GPUGeometry) {\n    return geometry;\n  }\n\n  const indices = getIndexBufferFromGeometry(device, geometry);\n  const {attributes, bufferLayout} = getAttributeBuffersFromGeometry(device, geometry);\n  return new GPUGeometry({\n    topology: geometry.topology || 'triangle-list',\n    bufferLayout,\n    vertexCount: geometry.vertexCount,\n    indices,\n    attributes\n  });\n}\n\nexport function getIndexBufferFromGeometry(device: Device, geometry: Geometry): Buffer | undefined {\n  if (!geometry.indices) {\n    return undefined;\n  }\n  const data = geometry.indices.value;\n  return device.createBuffer({usage: Buffer.INDEX, data});\n}\n\nexport function getAttributeBuffersFromGeometry(\n  device: Device,\n  geometry: Geometry\n): {attributes: Record<string, Buffer>, bufferLayout: BufferLayout[], vertexCount: number} {\n  const bufferLayout: BufferLayout[] = [];\n\n  const attributes: Record<string, Buffer> = {};\n  for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {\n    let name: string = attributeName;\n    // TODO Map some GLTF attribute names (is this still needed?)\n    switch (attributeName) {\n      case 'POSITION': name = 'positions'; break;\n      case 'NORMAL': name = 'normals'; break;\n      case 'TEXCOORD_0': name = 'texCoords'; break;\n      case 'COLOR_0': name = 'colors'; break;\n    }\n    attributes[name] = device.createBuffer({data: attribute.value, id: `${attributeName}-buffer`});\n    const {value, size, normalized} = attribute;\n    bufferLayout.push({name, format: getVertexFormatFromAttribute(value, size, normalized)});\n  }\n\n  const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices)\n\n  return {attributes, bufferLayout, vertexCount};\n}\n"],"mappings":"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"}