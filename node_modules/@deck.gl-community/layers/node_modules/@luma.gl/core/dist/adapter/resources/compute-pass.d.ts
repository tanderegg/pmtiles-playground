import { Resource, ResourceProps } from './resource';
import { ComputePipeline } from './compute-pipeline';
import { Buffer } from './buffer';
import type { Device } from '../device';
export type ComputePassProps = ResourceProps & {};
export declare abstract class ComputePass extends Resource<ComputePassProps> {
    static defaultProps: Required<ComputePassProps>;
    get [Symbol.toStringTag](): string;
    constructor(device: Device, props: ComputePassProps);
    abstract destroy(): void;
    abstract end(): void;
    abstract setPipeline(pipeline: ComputePipeline): void;
    /** Sets an array of bindings (uniform buffers, samplers, textures, ...) */
    /**
     * Dispatch work to be performed with the current ComputePipeline.
     * @param x X dimension of the grid of workgroups to dispatch.
     * @param y Y dimension of the grid of workgroups to dispatch.
     * @param z Z dimension of the grid of workgroups to dispatch.
     */
    abstract dispatch(x: number, y?: number, z?: number): void;
    /**
     * Dispatch work to be performed with the current ComputePipeline.
     * @param indirectBuffer buffer must be a tightly packed block of three 32-bit unsigned integer values (12 bytes total), given in the same order as the arguments for dispatch()
     * @param indirectOffset
     */
    abstract dispatchIndirect(indirectBuffer: Buffer, indirectOffset?: number): void;
    abstract pushDebugGroup(groupLabel: string): void;
    abstract popDebugGroup(): void;
    abstract insertDebugMarker(markerLabel: string): void;
}
//# sourceMappingURL=compute-pass.d.ts.map