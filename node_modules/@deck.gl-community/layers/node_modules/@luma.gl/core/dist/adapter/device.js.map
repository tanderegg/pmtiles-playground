{"version":3,"file":"device.js","names":["VERSION","lumaStats","log","uid","Buffer","_Symbol$toStringTag","Symbol","toStringTag","Device","constructor","props","id","statsManager","userData","_lumaData","info","lost","canvasContext","defaultProps","toLowerCase","loseDevice","getCanvasContext","Error","createTexture","Promise","data","_createTexture","createCommandEncoder","arguments","length","undefined","readPixelsToArrayWebGL","source","options","readPixelsToBufferWebGL","setParametersWebGL","parameters","getParametersWebGL","withParametersWebGL","func","clearWebGL","_getBufferProps","ArrayBuffer","isView","newProps","usage","INDEX","indexType","Uint32Array","Uint16Array","warn","type","canvas","container","webgl2","webgl1","manageState","width","height","debug","Boolean","get","break","gl"],"sources":["../../src/adapter/device.ts"],"sourcesContent":["// luma.gl, MIT license\nimport {VERSION} from '../init';\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\nimport {uid} from '../utils/utils';\nimport type {TextureFormat} from './types/texture-formats';\nimport type {CanvasContext, CanvasContextProps} from './canvas-context';\nimport type {BufferProps} from './resources/buffer';\nimport {Buffer} from './resources/buffer';\nimport type {RenderPipeline, RenderPipelineProps} from './resources/render-pipeline';\nimport type {ComputePipeline, ComputePipelineProps} from './resources/compute-pipeline';\nimport type {Sampler, SamplerProps} from './resources/sampler';\nimport type {Shader, ShaderProps} from './resources/shader';\nimport type {Texture, TextureProps, TextureData} from './resources/texture';\nimport type {ExternalTexture, ExternalTextureProps} from './resources/external-texture';\nimport type {Framebuffer, FramebufferProps} from './resources/framebuffer';\nimport type {RenderPass, RenderPassProps} from './resources/render-pass';\nimport type {ComputePass, ComputePassProps} from './resources/compute-pass';\nimport type {CommandEncoder, CommandEncoderProps} from './resources/command-encoder';\nimport type {VertexArray, VertexArrayProps} from './resources/vertex-array';\nimport type {TransformFeedback, TransformFeedbackProps} from './resources/transform-feedback';\n\n/** Device properties */\nexport type DeviceProps = {\n  id?: string;\n\n  type?: 'webgl' | 'webgl1' | 'webgl2' | 'webgpu' | 'best-available';\n\n  // Common parameters\n  canvas?: HTMLCanvasElement | OffscreenCanvas | string | null; // A canvas element or a canvas string id\n  container?: HTMLElement | string | null;\n  width?: number /** width is only used when creating a new canvas */;\n  height?: number /** height is only used when creating a new canvas */;\n\n  // WebGLDevice parameters\n  webgl2?: boolean; // Set to false to not create a WebGL2 context (force webgl1)\n  webgl1?: boolean; // set to false to not create a WebGL1 context (fails if webgl2 not available)\n\n  // WebGLContext PARAMETERS - Can only be set on context creation...\n  // alpha?: boolean; // Default render target has an alpha buffer.\n  // depth?: boolean; // Default render target has a depth buffer of at least 16 bits.\n  // stencil?: boolean; // Default render target has a stencil buffer of at least 8 bits.\n  // antialias?: boolean; // Boolean that indicates whether or not to perform anti-aliasing.\n  // premultipliedAlpha?: boolean; // Boolean that indicates that the page compositor will assume the drawing buffer contains colors with pre-multiplied alpha.\n  // preserveDrawingBuffer?: boolean; // Default render target buffers will not be automatically cleared and will preserve their values until cleared or overwritten\n  // failIfMajorPerformanceCaveat?: boolean; // Do not create if the system performance is low.\n\n  // Unclear if these are still supported\n  debug?: boolean; // Instrument context (at the expense of performance)\n  manageState?: boolean; // Set to false to disable WebGL state management instrumentation\n  break?: string[]; // TODO: types\n\n  // @deprecated Attach to existing context\n  gl?: WebGLRenderingContext | WebGL2RenderingContext | null;\n};\n\n/**\n * Identifies the GPU vendor and driver.\n * @note Chrome WebGPU does not provide much information, though more can be enabled with\n * @see https://developer.chrome.com/blog/new-in-webgpu-120#adapter_information_updates\n * chrome://flags/#enable-webgpu-developer-features\n */\nexport type DeviceInfo = {\n  /** Type of device */\n  type: 'webgl' | 'webgl2' | 'webgpu';\n  /** Vendor (name of GPU vendor, Apple, nVidia etc */\n  vendor: string;\n  /** Renderer (usually driver name) */\n  renderer: string;\n  /** version of driver */\n  version: string;\n  /** family of GPU */\n  gpu: 'nvidia' | 'amd' | 'intel' | 'apple' | 'software' | 'unknown';\n  /** Type of GPU () */\n  gpuType: 'discrete' | 'integrated' | 'cpu' | 'unknown';\n  /** GPU architecture */\n  gpuArchitecture?: string; // 'common-3' on Apple\n  /** GPU driver backend. Can sometimes be sniffed */\n  gpuBackend?: 'opengl' | 'opengles' | 'metal' | 'd3d11' | 'd3d12' | 'vulkan' | 'unknown';\n  /** If this is a fallback adapter */\n  fallback?: boolean;\n  /** Shader language supported by device.createShader() */\n  shadingLanguage: 'wgsl' | 'glsl';\n  /** Highest supported shader language version (GLSL 3.00 = 300, GLSL 1.00 = 100) */\n  shadingLanguageVersion: number;\n};\n\n/** Limits for a device */\nexport type DeviceLimits = {\n  readonly maxTextureDimension1D?: number;\n  readonly maxTextureDimension2D?: number;\n  readonly maxTextureDimension3D?: number;\n  readonly maxTextureArrayLayers?: number;\n  readonly maxBindGroups: number;\n  readonly maxDynamicUniformBuffersPerPipelineLayout: number;\n  readonly maxDynamicStorageBuffersPerPipelineLayout: number;\n  readonly maxSampledTexturesPerShaderStage: number;\n  readonly maxSamplersPerShaderStage: number;\n  readonly maxStorageBuffersPerShaderStage: number;\n  readonly maxStorageTexturesPerShaderStage: number;\n  readonly maxUniformBuffersPerShaderStage: number;\n  readonly maxUniformBufferBindingSize: number;\n  readonly maxStorageBufferBindingSize?: number;\n  readonly minUniformBufferOffsetAlignment?: number;\n  readonly minStorageBufferOffsetAlignment?: number;\n  readonly maxVertexBuffers?: number;\n  readonly maxVertexAttributes: number;\n  readonly maxVertexBufferArrayStride?: number;\n  readonly maxInterStageShaderComponents?: number;\n  readonly maxComputeWorkgroupStorageSize?: number;\n  readonly maxComputeInvocationsPerWorkgroup?: number;\n  readonly maxComputeWorkgroupSizeX?: number;\n  readonly maxComputeWorkgroupSizeY?: number;\n  readonly maxComputeWorkgroupSizeZ?: number;\n  readonly maxComputeWorkgroupsPerDimension?: number;\n};\n\nexport type WebGPUDeviceFeature =\n  | 'depth-clip-control'\n  | 'depth24unorm-stencil8'\n  | 'depth32float-stencil8'\n  | 'timestamp-query'\n  | 'indirect-first-instance'\n  | 'texture-compression-bc'\n  | 'texture-compression-etc2'\n  | 'texture-compression-astc';\n\n// obsolete...\n// 'depth-clamping' |\n// 'depth24unorm-stencil8' |\n// 'depth32float-stencil8' |\n// 'pipeline-statistics-query' |\n// 'timestamp-query' |\n// 'texture-compression-bc'\n\nexport type WebGLDeviceFeature =\n  | 'webgpu'\n  | 'webgl2'\n  | 'webgl'\n\n  // api support (unify with WebGPU timestamp-query?)\n  | 'timer-query-webgl'\n  | 'uniform-buffers-webgl'\n  | 'uniforms-webgl'\n\n  // texture filtering\n  | 'texture-filter-linear-float32-webgl'\n  | 'texture-filter-linear-float16-webgl'\n  | 'texture-filter-anisotropic-webgl'\n\n  // texture rendering\n  | 'texture-renderable-float32-webgl'\n  | 'texture-renderable-float16-webgl'\n  | 'texture-renderable-rgba32float-webgl' // TODO - remove\n\n  // texture blending\n  | 'texture-blend-float-webgl1'\n\n  // texture format support\n  | 'texture-formats-norm16-webgl'\n  | 'texture-formats-srgb-webgl1'\n  | 'texture-formats-depth-webgl1'\n  | 'texture-formats-float32-webgl1'\n  | 'texture-formats-float16-webgl1'\n\n  // api support\n  | 'vertex-array-object-webgl1'\n  | 'instanced-rendering-webgl1'\n  | 'multiple-render-targets-webgl1'\n  | 'index-uint32-webgl1'\n  | 'blend-minmax-webgl1'\n  | 'transform-feedback-webgl2'\n\n  // glsl extensions\n  | 'glsl-frag-data'\n  | 'glsl-frag-depth'\n  | 'glsl-derivatives'\n  | 'glsl-texture-lod';\n\ntype WebGLCompressedTextureFeatures =\n  | 'texture-compression-bc5-webgl'\n  | 'texture-compression-etc1-webgl'\n  | 'texture-compression-pvrtc-webgl'\n  | 'texture-compression-atc-webgl';\n\n/** Valid feature strings */\nexport type DeviceFeature =\n  | WebGPUDeviceFeature\n  | WebGLDeviceFeature\n  | WebGLCompressedTextureFeatures;\n\n/**\n * WebGPU Device/WebGL context abstraction\n */\nexport abstract class Device {\n\n  static defaultProps: Required<DeviceProps> = {\n    id: null!,\n    type: 'best-available',\n    canvas: null,\n    container: null,\n    webgl2: true, // Attempt to create a WebGL2 context\n    webgl1: true, // Attempt to create a WebGL1 context (false to fail if webgl2 not available)\n    manageState: true,\n    width: 800, // width are height are only used by headless gl\n    height: 600,\n    debug: Boolean(log.get('debug')), // Instrument context (at the expense of performance)\n    break: [],\n  \n    // alpha: undefined,\n    // depth: undefined,\n    // stencil: undefined,\n    // antialias: undefined,\n    // premultipliedAlpha: undefined,\n    // preserveDrawingBuffer: undefined,\n    // failIfMajorPerformanceCaveat: undefined\n  \n    gl: null\n  };\n  \n\n  get [Symbol.toStringTag](): string {\n    return 'Device';\n  }\n\n  static VERSION = VERSION;\n\n  constructor(props: DeviceProps) {\n    this.props = {...Device.defaultProps, ...props};\n    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());\n  }\n\n  /** id of this device, primarily for debugging */\n  readonly id: string;\n  /** stats */\n  readonly statsManager: StatsManager = lumaStats;\n  /** A copy of the device props  */\n  readonly props: Required<DeviceProps>;\n  /** Available for the application to store data on the device */\n  userData: {[key: string]: unknown} = {};\n  /** Used by other luma.gl modules to store data on the device */\n  _lumaData: {[key: string]: unknown} = {};\n\n  abstract destroy(): void;\n\n  // Capabilities\n\n  /** Information about the device (vendor, versions etc) */\n  abstract info: DeviceInfo;\n\n  /** Optional capability discovery */\n  abstract get features(): Set<DeviceFeature>;\n\n  /** WebGPU style device limits */\n  abstract get limits(): DeviceLimits;\n\n  /** Check if device supports a specific texture format (creation and `nearest` sampling) */\n  abstract isTextureFormatSupported(format: TextureFormat): boolean;\n\n  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */\n  abstract isTextureFormatFilterable(format: TextureFormat): boolean;\n\n  /** Check if device supports rendering to a specific texture format */\n  abstract isTextureFormatRenderable(format: TextureFormat): boolean;\n\n  // Device loss\n\n  /** `true` if device is already lost */\n  abstract get isLost(): boolean;\n\n  /** Promise that resolves when device is lost */\n  abstract readonly lost: Promise<{reason: 'destroyed'; message: string}>;\n\n  /**\n   * Trigger device loss.\n   * @returns `true` if context loss could actually be triggered.\n   * @note primarily intended for testing how application reacts to device loss\n   */\n  loseDevice(): boolean {\n    return false;\n  }\n\n  // Canvas context\n\n  /** Default / primary canvas context. Can be null as WebGPU devices can be created without a CanvasContext */\n  abstract canvasContext: CanvasContext | null;\n\n  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */\n  getCanvasContext(): CanvasContext {\n    if (!this.canvasContext) {\n      throw new Error('Device has no CanvasContext');\n    }\n    return this.canvasContext;\n  }\n\n  /** Creates a new CanvasContext (WebGPU only) */\n  abstract createCanvasContext(props?: CanvasContextProps): CanvasContext;\n\n  /** Call after rendering a frame (necessary e.g. on WebGL OffscreenCanvas) */\n  abstract submit(): void;\n\n  // Resource creation\n\n  /** Create a buffer */\n  abstract createBuffer(props: BufferProps | ArrayBuffer | ArrayBufferView): Buffer;\n\n  /** Create a texture */\n  abstract _createTexture(props: TextureProps): Texture;\n  createTexture(props: TextureProps): Texture;\n  createTexture(data: Promise<TextureData>): Texture;\n  createTexture(url: string): Texture;\n\n  createTexture(props: TextureProps | Promise<TextureData> | string): Texture {\n    // Signature: new Texture2D(gl, url | Promise)\n    if (props instanceof Promise || typeof props === 'string') {\n      props = {data: props};\n    }\n    return this._createTexture(props);\n  }\n\n  /** Create a temporary texture view of a video source */\n  abstract createExternalTexture(props: ExternalTextureProps): ExternalTexture;\n\n  /** Create a sampler */\n  abstract createSampler(props: SamplerProps): Sampler;\n\n  /** Create a Framebuffer. Must have at least one attachment. */\n  abstract createFramebuffer(props: FramebufferProps): Framebuffer;\n\n  /** Create a shader */\n  abstract createShader(props: ShaderProps): Shader;\n\n  /** Create a render pipeline (aka program) */\n  abstract createRenderPipeline(props: RenderPipelineProps): RenderPipeline;\n\n  /** Create a compute pipeline (aka program). WebGPU only. */\n  abstract createComputePipeline(props: ComputePipelineProps): ComputePipeline;\n\n  /** Create a vertex array */\n  abstract createVertexArray(props: VertexArrayProps): VertexArray;\n\n  /** Create a RenderPass */\n  abstract beginRenderPass(props?: RenderPassProps): RenderPass;\n\n  /** Create a ComputePass */\n  abstract beginComputePass(props?: ComputePassProps): ComputePass;\n\n  /** Get a renderpass that is set up to render to the primary CanvasContext */\n  abstract getDefaultRenderPass(): RenderPass;\n\n  /** Create a transform feedback (immutable set of output buffer bindings). WebGL 2 only. */\n  abstract createTransformFeedback(props: TransformFeedbackProps): TransformFeedback;\n\n  createCommandEncoder(props: CommandEncoderProps = {}): CommandEncoder {\n    throw new Error('not implemented');\n  }\n\n  // WebGL specific HACKS - enables app to remove webgl import\n  // Use until we have a better way to handle these\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToArrayWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      sourceAttachment?: number;\n      target?: Uint8Array | Uint16Array | Float32Array;\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Uint8Array | Uint16Array | Float32Array {\n    throw new Error('not implemented');\n  }\n  \n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToBufferWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      target?: Buffer; // A new Buffer object is created when not provided.\n      targetByteOffset?: number; // byte offset in buffer object\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Buffer {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  setParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  getParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  withParametersWebGL(parameters: any, func: any): any {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use clear arguments in RenderPass */\n  clearWebGL(options?: {framebuffer?: Framebuffer; color?: any; depth?: any; stencil?: any}): void {\n    throw new Error('not implemented');\n  }\n\n  // Implementation\n\n  protected _getBufferProps(props: BufferProps | ArrayBuffer | ArrayBufferView): BufferProps {\n    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    // TODO - fragile, as this is done before we merge with default options\n    // inside the Buffer constructor\n\n    const newProps = {...props};\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        newProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        newProps.indexType = 'uint16';\n      } else {\n        log.warn('indices buffer content must be of integer type')();\n      }\n    }\n    return newProps;\n  }\n}\n"],"mappings":"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"}