import { assert } from "../../utils/assert.js";
const UNIFORM_FORMATS = {
  'f32': {
    type: 'f32',
    components: 1
  },
  'i32': {
    type: 'i32',
    components: 1
  },
  'u32': {
    type: 'u32',
    components: 1
  },
  'vec2<f32>': {
    type: 'f32',
    components: 2
  },
  'vec3<f32>': {
    type: 'f32',
    components: 3
  },
  'vec4<f32>': {
    type: 'f32',
    components: 4
  },
  'vec2<i32>': {
    type: 'i32',
    components: 2
  },
  'vec3<i32>': {
    type: 'i32',
    components: 3
  },
  'vec4<i32>': {
    type: 'i32',
    components: 4
  },
  'vec2<u32>': {
    type: 'u32',
    components: 2
  },
  'vec3<u32>': {
    type: 'u32',
    components: 3
  },
  'vec4<u32>': {
    type: 'u32',
    components: 4
  },
  'mat2x2<f32>': {
    type: 'f32',
    components: 4
  },
  'mat2x3<f32>': {
    type: 'f32',
    components: 6
  },
  'mat2x4<f32>': {
    type: 'f32',
    components: 8
  },
  'mat3x2<f32>': {
    type: 'f32',
    components: 6
  },
  'mat3x3<f32>': {
    type: 'f32',
    components: 9
  },
  'mat3x4<f32>': {
    type: 'f32',
    components: 12
  },
  'mat4x2<f32>': {
    type: 'f32',
    components: 8
  },
  'mat4x3<f32>': {
    type: 'f32',
    components: 12
  },
  'mat4x4<f32>': {
    type: 'f32',
    components: 16
  }
};
export function decodeShaderUniformType(format) {
  const decoded = UNIFORM_FORMATS[format];
  assert(format);
  return decoded;
}
export function alignTo(size, count) {
  switch (count) {
    case 1:
      return size;
    case 2:
      return size + size % 2;
    default:
      return size + (4 - size % 4) % 4;
  }
}
//# sourceMappingURL=decode-shader-types.js.map