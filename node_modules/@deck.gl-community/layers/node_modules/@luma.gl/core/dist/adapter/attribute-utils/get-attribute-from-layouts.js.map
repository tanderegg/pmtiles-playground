{"version":3,"file":"get-attribute-from-layouts.js","names":["log","decodeShaderAttributeType","decodeVertexFormat","getAttributeInfosFromLayouts","shaderLayout","bufferLayout","attributeInfos","attribute","attributes","name","getAttributeInfoFromLayouts","getAttributeInfosByLocation","maxVertexAttributes","arguments","length","undefined","locationInfos","Array","fill","attributeInfo","Object","values","location","shaderDeclaration","getAttributeFromShaderLayout","bufferMapping","getAttributeFromBufferLayout","attributeTypeInfo","type","vertexFormat","defaultVertexFormat","vertexFormatInfo","attributeName","bufferName","shaderType","shaderDataType","dataType","shaderComponents","components","bufferDataType","bufferComponents","normalized","integer","stepMode","byteOffset","byteStride","find","attr","warn","bufferLayouts","checkBufferLayouts","bufferLayoutInfo","getAttributeFromShortHand","getAttributeFromAttributesList","format","_bufferLayout$attribu","attributeMapping","info","byteLength","mapping","mergeShaderLayout","baseLayout","overrideLayout","mergedLayout","map","baseAttribute"],"sources":["../../../src/adapter/attribute-utils/get-attribute-from-layouts.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport {log} from '../../utils/log';\nimport type {ShaderLayout, AttributeDeclaration} from '../types/shader-layout';\nimport type {BufferLayout} from '../types/buffer-layout';\nimport type {ShaderDataType, ShaderAttributeType} from '../types/shader-types';\nimport {decodeShaderAttributeType} from '../type-utils/decode-attribute-type';\nimport type {VertexFormat, VertexType} from '../types/vertex-formats';\nimport {decodeVertexFormat} from '../type-utils/decode-vertex-format';\n\n/** Resolved info for a buffer / attribute combination to help backend configure it correctly */\nexport type AttributeInfo = {\n  /** Attribute name */\n  attributeName: string;\n  /** Location in shader */\n  location: number;\n  /** Type / precision used in shader (buffer values may be converted) */\n  shaderType: ShaderAttributeType;\n  /** Calculations are done in this type in the shader's attribute declaration */\n  shaderDataType: ShaderDataType;\n  /** Components refer to the number of components in the shader's attribute declaration */\n  shaderComponents: 1 | 2 | 3 | 4;\n  /** It is the shader attribute declaration that determines whether GPU will process as integer or float */\n  integer: boolean;\n\n  /** BufferName */\n  bufferName: string;\n  /** Format of buffer data */\n  vertexFormat: VertexFormat;\n  /** Memory data type refers to the data type in the buffer */\n  bufferDataType: VertexType;\n  /** Components refer to the number of components in the buffer's vertex format */\n  bufferComponents: 1 | 2 | 3 | 4;\n  /** Normalization is encoded in the buffer layout's vertex format... */\n  normalized: boolean;\n\n  /** If not specified, the step mode is inferred from the attribute name in the shader (contains string instance) */\n  stepMode: 'vertex' | 'instance';\n\n  /** The byteOffset is encoded in or calculated from the buffer layout */\n  byteOffset: number;\n  /** The byteStride is encoded in or calculated from the buffer layout */\n  byteStride: number;\n};\n\ntype BufferAttributeInfo = {\n  attributeName: string;\n  bufferName: string;\n  stepMode?: 'vertex' | 'instance';\n  vertexFormat: VertexFormat;\n  byteOffset: number;\n  byteStride: number;\n};\n\n/** \n * Map from \"attribute names\" to \"resolved attribute infos\" \n * containing information about both buffer layouts and shader attribute declarations\n */\nexport function getAttributeInfosFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[]\n): Record<string, AttributeInfo> {\n  const attributeInfos: Record<string, AttributeInfo> = {};\n  for (const attribute of shaderLayout.attributes) {\n    attributeInfos[attribute.name] = getAttributeInfoFromLayouts(\n      shaderLayout,\n      bufferLayout,\n      attribute.name\n    );\n  }\n  return attributeInfos;\n}\n\n/** \n * Array indexed by \"location\" holding \"resolved attribute infos\" \n */\nexport function getAttributeInfosByLocation(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  maxVertexAttributes: number = 16\n): AttributeInfo[] {\n  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);\n  const locationInfos: AttributeInfo[] = new Array(maxVertexAttributes).fill(null);\n  for (const attributeInfo of Object.values(attributeInfos)) {\n    locationInfos[attributeInfo.location] = attributeInfo;\n  }\n  return locationInfos;\n}\n\n/**\n * Get the combined information from a shader layout and a buffer layout for a specific attribute\n */\nfunction getAttributeInfoFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  name: string\n): AttributeInfo | null {\n  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name);\n  const bufferMapping: BufferAttributeInfo = getAttributeFromBufferLayout(bufferLayout, name);\n\n  // TODO should no longer happen\n  if (!shaderDeclaration) {\n    //  || !bufferMapping\n    return null;\n  }\n\n  const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);\n  const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;\n  const vertexFormatInfo = decodeVertexFormat(vertexFormat);\n\n  return {\n    attributeName: bufferMapping?.attributeName || shaderDeclaration.name,\n    bufferName: bufferMapping?.bufferName || shaderDeclaration.name,\n    location: shaderDeclaration.location,\n    shaderType: shaderDeclaration.type,\n    shaderDataType: attributeTypeInfo.dataType,\n    shaderComponents: attributeTypeInfo.components,\n    vertexFormat,\n    bufferDataType: vertexFormatInfo.type,\n    bufferComponents: vertexFormatInfo.components,\n    // normalized is a property of the buffer's vertex format\n    normalized: vertexFormatInfo.normalized,\n    // integer is a property of the shader declaration\n    integer: attributeTypeInfo.integer,\n    stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode,\n    byteOffset: bufferMapping?.byteOffset || 0,\n    byteStride: bufferMapping?.byteStride || 0\n  };\n}\n\nfunction getAttributeFromShaderLayout(\n  shaderLayout: ShaderLayout,\n  name: string\n): AttributeDeclaration | null {\n  const attribute = shaderLayout.attributes.find(attr => attr.name === name);\n  if (!attribute) {\n    log.warn(`shader layout attribute \"${name}\" not present in shader`);\n  }\n  return attribute || null;\n}\n\nfunction getAttributeFromBufferLayout(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  // Check that bufferLayouts are valid (each either has format or attribute)\n  checkBufferLayouts(bufferLayouts);\n\n  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  // Didn't find...\n  log.warn(`layout for attribute \"${name}\" not present in buffer layout`);\n  return null;\n}\n\n/** Check that bufferLayouts are valid (each either has format or attribute) */\nfunction checkBufferLayouts(bufferLayouts: BufferLayout[]) {\n  for (const bufferLayout of bufferLayouts) {\n    if (\n      (bufferLayout.attributes && bufferLayout.format) ||\n      (!bufferLayout.attributes && !bufferLayout.format)\n    ) {\n      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);\n    }\n  }\n}\n\n/** Get attribute from format shorthand if specified */\nfunction getAttributeFromShortHand(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    if (bufferLayout.format && bufferLayout.name === name) {\n      return {\n        attributeName: bufferLayout.name,\n        bufferName: name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: bufferLayout.format,\n        // If offset is needed, use `attributes` field.\n        byteOffset: 0,\n        byteStride: bufferLayout.byteStride || 0\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * Search attribute mappings (e.g. interleaved attributes) for buffer mapping.\n * Not the name of the buffer might be the same as one of the interleaved attributes.\n */\nfunction getAttributeFromAttributesList(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    let byteStride: number | undefined = bufferLayout.byteStride;\n\n    // Calculate a default byte stride if not provided\n    if (typeof bufferLayout.byteStride !== 'number') {\n      for (const attributeMapping of bufferLayout.attributes || []) {\n        const info = decodeVertexFormat(attributeMapping.format);\n        byteStride += info.byteLength;\n      }\n    }\n\n    const attributeMapping = bufferLayout.attributes?.find(mapping => mapping.attribute === name);\n    if (attributeMapping) {\n      return {\n        attributeName: attributeMapping.attribute,\n        bufferName: bufferLayout.name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: attributeMapping.format,\n        byteOffset: attributeMapping.byteOffset,\n        byteStride\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Merges an provided shader layout into a base shader layout\n * In WebGL, this allows the auto generated shader layout to be overridden by the application\n * Typically to change the format of the vertex attributes (from float32x4 to uint8x4 etc).\n * @todo Drop this? Aren't all use cases covered by mergeBufferLayout()?\n */\nexport function mergeShaderLayout(\n  baseLayout: ShaderLayout,\n  overrideLayout: ShaderLayout\n): ShaderLayout {\n  // Deep clone the base layout\n  const mergedLayout: ShaderLayout = {\n    ...baseLayout,\n    attributes: baseLayout.attributes.map(attribute => ({...attribute}))\n  };\n  // Merge the attributes\n  for (const attribute of overrideLayout?.attributes || []) {\n    const baseAttribute = mergedLayout.attributes.find(attr => attr.name === attribute.name);\n    if (!baseAttribute) {\n      log.warn(`shader layout attribute ${attribute.name} not present in shader`);\n    } else {\n      baseAttribute.type = attribute.type || baseAttribute.type;\n      baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;\n    }\n  }\n  return mergedLayout;\n}\n"],"mappings":"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"}