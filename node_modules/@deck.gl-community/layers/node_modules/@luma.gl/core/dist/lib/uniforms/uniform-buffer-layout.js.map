{"version":3,"file":"uniform-buffer-layout.js","names":["decodeShaderUniformType","alignTo","getScratchArrayBuffer","isNumberArray","log","minBufferSize","UniformBufferLayout","constructor","uniformTypes","layout","byteLength","size","key","uniformType","Object","entries","typeAndComponents","type","components","count","offset","actualByteLength","Math","max","getData","uniformValues","bufferSize","arrayBuffer","typedArrays","i32","Int32Array","u32","Uint32Array","f32","Float32Array","f16","Uint16Array","name","value","uniformLayout","warn","typedArray","Number","numericArray","set","Uint8Array","has","Boolean","get"],"sources":["../../../src/lib/uniforms/uniform-buffer-layout.ts"],"sourcesContent":["// luma.gl, MIT license\nimport type {ShaderUniformType, ShaderDataType} from '../../adapter/types/shader-types';\nimport type {UniformValue} from '../../adapter/types/types';\nimport {decodeShaderUniformType, alignTo} from '../../adapter/type-utils/decode-shader-types';\nimport {getScratchArrayBuffer} from '../../utils/array-utils-flat';\nimport {isNumberArray} from '../../utils/is-array';\nimport { log } from '../../utils/log';\n\n/** \n * Smallest buffer size that can be used for uniform buffers.\n * TODO - does this depend on device?\n */\nconst minBufferSize: number = 1024;\n\n/**\n * Std140 layout for uniform buffers\n * Supports manual listing of uniforms\n */\nexport class UniformBufferLayout {\n  readonly layout: Record<string, {offset: number, size: number, type: ShaderDataType}> = {};\n\n  /** number of bytes needed for buffer allocation */\n  readonly byteLength: number;\n\n\n  /** Create a new UniformBufferLayout given a map of attributes. */\n  constructor(uniformTypes: Record<string, ShaderUniformType>) {\n    /** number of 4 byte slots taken */\n    let size: number = 0;\n\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const [key, uniformType] of Object.entries(uniformTypes)) {\n      const typeAndComponents = decodeShaderUniformType(uniformType);\n      const {type, components: count} = typeAndComponents;\n      // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n      size = alignTo(size, count);\n      // Use the aligned size as the offset of the current uniform.\n      const offset = size;\n      // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n      size += count;\n      this.layout[key] = {type, size: count, offset};\n    }\n    size += (4 - (size % 4)) % 4;\n\n    const actualByteLength = size * 4;\n    this.byteLength = Math.max(actualByteLength, minBufferSize);\n  }\n\n  /** Get the data for the complete buffer */\n  getData(uniformValues: Record<string, UniformValue>): Uint8Array {\n    const bufferSize = Math.max(this.byteLength, minBufferSize);\n\n    // Allocate three typed arrays pointing at same memory\n    const arrayBuffer = getScratchArrayBuffer(bufferSize);\n    const typedArrays = {\n      i32: new Int32Array(arrayBuffer),\n      u32: new Uint32Array(arrayBuffer),\n      f32: new Float32Array(arrayBuffer),\n      // TODO not implemented\n      f16: new Uint16Array(arrayBuffer)\n    };\n    // TODO is this needed?\n    // typedArrays.i32.fill(0);\n    \n    for (const [name, value] of Object.entries(uniformValues)) {\n      const uniformLayout = this.layout[name];\n      if (!uniformLayout) {\n        log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const {type, size, offset} = uniformLayout;\n      const typedArray = typedArrays[type];\n      if (size === 1) {\n        if (typeof value !== 'number' && typeof value !== 'boolean') {\n          log.warn(`Supplied value for single component uniform ${name} is not a number: ${value}`)();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // single value -> just set it\n        typedArray[offset] = Number(value);\n      } else {\n        const numericArray = isNumberArray(value);\n        if (!numericArray) {\n          log.warn(`Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`)();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // vector/matrix -> copy the supplied (typed) array, starting from offset\n        // TODO: we should limit or check size in case the supplied data overflows\n        typedArray.set(numericArray, offset);\n      }\n    }\n\n    return new Uint8Array(arrayBuffer);\n  }  \n\n  /** Does this layout have a field with specified name */\n  has(name: string) {\n    return Boolean(this.layout[name]);\n  }\n\n  /** Get offset and size for a field with specified name */\n  get(name: string): {offset: number, size: number} | undefined {\n    const layout = this.layout[name];\n    return layout;\n  }\n}\n"],"mappings":"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"}