export function formatCompilerLog(shaderLog, source, options) {
  let formattedLog = '';
  const lines = source.split(/\r?\n/);
  const log = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);
  switch ((options === null || options === void 0 ? void 0 : options.showSourceCode) || 'no') {
    case 'all':
      let currentMessage = 0;
      for (let lineNum = 1; lineNum <= lines.length; lineNum++) {
        formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
        while (log.length > currentMessage && log[currentMessage].lineNum === lineNum) {
          const message = log[currentMessage++];
          formattedLog += formatCompilerMessage(message, lines, message.lineNum, {
            ...options,
            inlineSource: false
          });
        }
      }
      return formattedLog;
    case 'issues':
    case 'no':
      for (const message of shaderLog) {
        formattedLog += formatCompilerMessage(message, lines, message.lineNum, {
          inlineSource: (options === null || options === void 0 ? void 0 : options.showSourceCode) !== 'no'
        });
      }
      return formattedLog;
  }
}
function formatCompilerMessage(message, lines, lineNum, options) {
  if (options !== null && options !== void 0 && options.inlineSource) {
    const numberedLines = getNumberedLines(lines, lineNum);
    const positionIndicator = message.linePos > 0 ? `${' '.repeat(message.linePos + 5)}^^^\n` : '';
    return `
${numberedLines}${positionIndicator}${message.type.toUpperCase()}: ${message.message}

`;
  }
  return options !== null && options !== void 0 && options.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${message.type.toUpperCase()}: ${message.message}</b></div>` : `${message.type.toUpperCase()}: ${message.message}`;
}
function getNumberedLines(lines, lineNum, options) {
  let numberedLines = '';
  for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {
    const sourceLine = lines[lineIndex - 1];
    if (sourceLine !== undefined) {
      numberedLines += getNumberedLine(sourceLine, lineNum, options);
    }
  }
  return numberedLines;
}
function getNumberedLine(line, lineNum, options) {
  const escapedLine = options !== null && options !== void 0 && options.html ? escapeHTML(line) : line;
  return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options !== null && options !== void 0 && options.html ? '<br/>' : '\n'}`;
}
function padLeft(string, paddedLength) {
  let result = '';
  for (let i = string.length; i < paddedLength; ++i) {
    result += ' ';
  }
  return result + string;
}
function escapeHTML(unsafe) {
  return unsafe.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll('\'', '&#039;');
}
//# sourceMappingURL=format-compiler-log.js.map