import { arrayEqual, arrayCopy } from "../../utils/array-equal.js";
export class UniformBlock {
  constructor(props) {
    this.name = void 0;
    this.uniforms = {};
    this.modifiedUniforms = {};
    this.modified = true;
    this.bindingLayout = {};
    this.needsRedraw = 'initialized';
    this.name = props === null || props === void 0 ? void 0 : props.name;
    if (props !== null && props !== void 0 && props.name && props !== null && props !== void 0 && props.shaderLayout) {
      var _props$shaderLayout$b;
      const binding = props === null || props === void 0 || (_props$shaderLayout$b = props.shaderLayout.bindings) === null || _props$shaderLayout$b === void 0 ? void 0 : _props$shaderLayout$b.find(binding => binding.type === 'uniform' && binding.name === (props === null || props === void 0 ? void 0 : props.name));
      if (!binding) {
        throw new Error(props === null || props === void 0 ? void 0 : props.name);
      }
      const uniformBlock = binding;
      for (const uniform of uniformBlock.uniforms || []) {
        this.bindingLayout[uniform.name] = uniform;
      }
    }
  }
  setUniforms(uniforms) {
    for (const [key, value] of Object.entries(uniforms)) {
      this._setUniform(key, value);
      if (!this.needsRedraw) {
        this.setNeedsRedraw(`${this.name}.${key}=${value}`);
      }
    }
  }
  setNeedsRedraw(reason) {
    this.needsRedraw = this.needsRedraw || reason;
  }
  getAllUniforms() {
    this.modifiedUniforms = {};
    this.needsRedraw = false;
    return this.uniforms || {};
  }
  _setUniform(key, value) {
    if (arrayEqual(this.uniforms[key], value)) {
      return;
    }
    this.uniforms[key] = arrayCopy(value);
    this.modifiedUniforms[key] = true;
    this.modified = true;
  }
}
//# sourceMappingURL=uniform-block.js.map