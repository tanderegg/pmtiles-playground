import { glsl } from "../glsl-utils/highlight.js";
import { resolveModules } from "./resolve-modules.js";
import { getPlatformShaderDefines, getVersionDefines } from "./platform-defines.js";
import { injectShader, DECLARATION_INJECT_MARKER } from "./shader-injections.js";
import { transpileGLSLShader } from "../shader-transpiler/transpile-glsl-shader.js";
import { normalizeShaderHooks, getShaderHooks } from "./shader-hooks.js";
import { assert } from "../utils/assert.js";
import { getShaderInfo } from "../glsl-utils/get-shader-info.js";
const INJECT_SHADER_DECLARATIONS = `\n\n${DECLARATION_INJECT_MARKER}\n`;
const FRAGMENT_SHADER_PROLOGUE = glsl`\
precision highp float;
`;
export function assembleShaders(options) {
  const {
    vs,
    fs
  } = options;
  const modules = resolveModules(options.modules || []);
  switch (options.platformInfo.shaderLanguage) {
    case 'glsl':
      return {
        vs: assembleGLSLShader(options.platformInfo, {
          ...options,
          source: vs,
          stage: 'vertex',
          modules
        }),
        fs: assembleGLSLShader(options.platformInfo, {
          ...options,
          source: fs,
          stage: 'fragment',
          modules
        }),
        getUniforms: assembleGetUniforms(modules)
      };
    case 'wgsl':
      return {
        vs: assembleWGSLShader(options.platformInfo, {
          ...options,
          source: vs,
          stage: 'vertex',
          modules
        }),
        fs: assembleWGSLShader(options.platformInfo, {
          ...options,
          source: fs,
          stage: 'fragment',
          modules
        }),
        getUniforms: assembleGetUniforms(modules)
      };
  }
}
function assembleWGSLShader(platformInfo, options) {
  const {
    source,
    stage,
    modules,
    hookFunctions = [],
    inject = {},
    log
  } = options;
  assert(typeof source === 'string', 'shader source must be a string');
  const coreSource = source;
  let assembledSource = '';
  const hookFunctionMap = normalizeShaderHooks(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === 'decl') {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  const modulesToInject = platformInfo.type !== 'webgpu' ? modules : [];
  for (const module of modulesToInject) {
    if (log) {
      module.checkDeprecations(coreSource, log);
    }
    const moduleSource = module.getModuleSource(stage, 'wgsl');
    assembledSource += moduleSource;
    const injections = module.injections[stage];
    for (const key in injections) {
      const match = /^(v|f)s:#([\w-]+)$/.exec(key);
      if (match) {
        const name = match[2];
        const injectionType = name === 'decl' ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, stage, declInjections);
  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, stage, mainInjections);
  return assembledSource;
}
function assembleGLSLShader(platformInfo, options) {
  const {
    id,
    source,
    stage,
    language = 'glsl',
    modules,
    defines = {},
    hookFunctions = [],
    inject = {},
    prologue = true,
    log
  } = options;
  assert(typeof source === 'string', 'shader source must be a string');
  const sourceVersion = language === 'glsl' ? getShaderInfo(source).version : -1;
  const targetVersion = platformInfo.shaderLanguageVersion;
  const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';
  const sourceLines = source.split('\n');
  const coreSource = sourceLines.slice(1).join('\n');
  const allDefines = {};
  modules.forEach(module => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  let assembledSource = '';
  switch (language) {
    case 'wgsl':
      break;
    case 'glsl':
      assembledSource = prologue ? `\
${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${getShaderNameDefine({
        id,
        source,
        stage
      })}
${`#define SHADER_TYPE_${stage.toUpperCase()}`}
${getPlatformShaderDefines(platformInfo)}
${getVersionDefines(platformInfo)}
${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
      break;
  }
  const hookFunctionMap = normalizeShaderHooks(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === 'decl') {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log) {
      module.checkDeprecations(coreSource, log);
    }
    const moduleSource = module.getModuleSource(stage);
    assembledSource += moduleSource;
    const injections = module.injections[stage];
    for (const key in injections) {
      const match = /^(v|f)s:#([\w-]+)$/.exec(key);
      if (match) {
        const name = match[2];
        const injectionType = name === 'decl' ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, stage, declInjections);
  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, stage, mainInjections);
  if (language === 'glsl' && sourceVersion !== targetVersion) {
    assembledSource = transpileGLSLShader(assembledSource, targetVersion, stage);
  }
  return assembledSource.trim();
}
function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    const uniforms = {};
    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }
    return uniforms;
  };
}
function getShaderNameDefine(options) {
  const {
    id,
    source,
    stage
  } = options;
  const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName ? `
#define SHADER_NAME ${id}_${stage}

` : '';
}
function getApplicationDefines() {
  let defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let sourceText = '';
  for (const define in defines) {
    const value = defines[define];
    if (value || Number.isFinite(value)) {
      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\n`;
    }
  }
  return sourceText;
}
//# sourceMappingURL=assemble-shaders.js.map