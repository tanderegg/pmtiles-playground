import { MODULE_INJECTORS_VS, MODULE_INJECTORS_FS } from "../../module-injectors.js";
import { assert } from "../utils/assert.js";
const MODULE_INJECTORS = {
  vertex: MODULE_INJECTORS_VS,
  fragment: MODULE_INJECTORS_FS
};
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
const fragments = [];
export const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';
export function normalizeInjections(injections) {
  const result = {
    vertex: {},
    fragment: {}
  };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = getHookStage(hook);
    if (typeof injection === 'string') {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}
function getHookStage(hook) {
  const type = hook.slice(0, 2);
  switch (type) {
    case 'vs':
      return 'vertex';
    case 'fs':
      return 'fragment';
    default:
      throw new Error(type);
  }
}
export function injectShader(source, stage, inject) {
  let injectStandardStubs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const isVertex = stage === 'vertex';
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a, b) => a.order - b.order);
    fragments.length = fragmentData.length;
    for (let i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }
    const fragmentString = `${fragments.join('\n')}\n`;
    switch (key) {
      case 'vs:#decl':
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case 'vs:#main-start':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }
        break;
      case 'vs:#main-end':
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }
        break;
      case 'fs:#decl':
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case 'fs:#main-start':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }
        break;
      case 'fs:#main-end':
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }
        break;
      default:
        source = source.replace(key, match => match + fragmentString);
    }
  }
  source = source.replace(DECLARATION_INJECT_MARKER, '');
  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, match => match + MODULE_INJECTORS[stage]);
  }
  return source;
}
export function combineInjects(injects) {
  const result = {};
  assert(Array.isArray(injects) && injects.length > 1);
  injects.forEach(inject => {
    for (const key in inject) {
      result[key] = result[key] ? `${result[key]}\n${inject[key]}` : inject[key];
    }
  });
  return result;
}
//# sourceMappingURL=shader-injections.js.map