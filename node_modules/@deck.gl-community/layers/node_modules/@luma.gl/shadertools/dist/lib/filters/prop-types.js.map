{"version":3,"file":"prop-types.js","names":["assert","DEFAULT_PROP_VALIDATORS","number","type","validate","value","propType","Number","isFinite","max","undefined","min","array","Array","isArray","ArrayBuffer","isView","makePropValidators","propTypes","propValidators","name","Object","entries","makePropValidator","getValidatedProperties","properties","errorMessage","validated","key","propsValidator","private","getTypeOf","Error"],"sources":["../../../src/lib/filters/prop-types.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport {assert} from '../utils/assert';\n\n/** \n * For use by shader module and shader pass writers to describe the types of the \n * properties they expose (properties ultimately map to uniforms).\n */\nexport type PropType = {\n  type?: string;\n  value?: unknown;\n  max?: number;\n  min?: number;\n  softMax?: number;\n  softMin?: number;\n  hint?: string;\n  /** @deprecated internal uniform */\n  private?: boolean;\n} | number;\n\n/**\n * Internal property validators generated by processing the prop types , \n * The `validate()` method can be used to validate the type of properties passed in to\n * shader module or shader pass\n */\nexport type PropValidator = {\n  type: string;\n  value?: unknown;\n  max?: number;\n  min?: number;\n  private?: boolean;\n  validate?(value: unknown, propDef: PropValidator): boolean;\n};\n\n/** Minimal validators for number and array types */\nconst DEFAULT_PROP_VALIDATORS: Record<string, PropValidator> = {\n  number: {\n    type: 'number',\n    validate(value: unknown, propType: PropType) {\n      return (\n        Number.isFinite(value) &&\n        typeof propType === 'object' &&\n        (propType.max === undefined || value as number <= propType.max) &&\n        (propType.min === undefined || value as number >= propType.min)\n      );\n    }\n  },\n  array: {\n    type: 'array',\n    validate(value: unknown, propType: PropType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\n/**\n * Parse a list of property types into property definitions that can be used to validate\n * values passed in by applications.\n * @param propTypes \n * @returns \n */\nexport function makePropValidators(propTypes: Record<string, PropType>): Record<string, PropValidator> {\n  const propValidators: Record<string, PropValidator> = {};\n  for (const [name, propType] of Object.entries(propTypes)) {\n    propValidators[name] = makePropValidator(propType);\n  }\n  return propValidators;\n}\n\n/**\n * Validate a map of user supplied properties against a map of validators\n * Inject default values when user doesn't supply a property\n * @param properties \n * @param propValidators \n * @returns \n */\nexport function getValidatedProperties(\n  properties: Record<string, unknown>,\n  propValidators: Record<string, PropValidator>,\n  errorMessage: string\n): Record<string, unknown> {\n\n  const validated: Record<string, unknown> = {};\n\n  for (const [key, propsValidator] of Object.entries(propValidators)) {\n    if (properties && key in properties && !propsValidator.private) {\n      if (propsValidator.validate) {\n        assert(propsValidator.validate(properties[key], propsValidator), `${errorMessage}: invalid ${key}`);\n      }\n      validated[key] = properties[key];\n    } else {\n      // property not supplied - use default value\n      validated[key] = propsValidator.value;\n    }\n  }\n\n  // TODO - warn for unused properties that don't match a validator?\n\n  return validated;\n}\n\n\n/**\n * Creates a property validator for a prop type. Either contains:\n * - a valid prop type object ({type, ...})\n * - or just a default value, in which case type and name inference is used\n */\nfunction makePropValidator(propType: PropType): PropValidator {\n  let type = getTypeOf(propType);\n\n  if (type !== 'object') {\n    return {value: propType, ...DEFAULT_PROP_VALIDATORS[type], type};\n  }\n\n  // Special handling for objects\n  if (typeof propType === 'object') {\n    if (!propType) {\n      return {type: 'object', value: null};\n    }\n    if (propType.type !== undefined) {\n      return {...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type};\n    }\n    // If no type and value this object is likely the value\n    if (propType.value === undefined) {\n      return {type: 'object', value: propType};\n    }\n\n    type = getTypeOf(propType.value);\n    return {...propType, ...DEFAULT_PROP_VALIDATORS[type], type};\n  }\n\n  throw new Error('props');\n}\n\n/** \n * \"improved\" version of javascript typeof that can distinguish arrays and null values\n */\nfunction getTypeOf(value: unknown): string {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n"],"mappings":"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"}