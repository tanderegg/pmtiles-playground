export function transpileGLSLShader(source, targetGLSLVersion, stage) {
  var _source$match;
  const sourceGLSLVersion = Number(((_source$match = source.match(/^#version[ \t]+(\d+)/m)) === null || _source$match === void 0 ? void 0 : _source$match[1]) || 100);
  if (sourceGLSLVersion !== 300) {
    throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');
  }
  switch (targetGLSLVersion) {
    case 300:
      switch (stage) {
        case 'vertex':
          source = convertShader(source, ES300_VERTEX_REPLACEMENTS);
          return source;
        case 'fragment':
          source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
          return source;
        default:
          throw new Error(stage);
      }
    case 100:
      switch (stage) {
        case 'vertex':
          source = convertShader(source, ES100_VERTEX_REPLACEMENTS);
          return source;
        case 'fragment':
          source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
          source = convertFragmentShaderTo100(source);
          return source;
        default:
          throw new Error(stage);
      }
    default:
      throw new Error(String(targetGLSLVersion));
  }
}
const ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, '#version 300 es\n'], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, 'textureLod('], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, 'texture(']];
const ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [makeVariableTextRegExp('attribute'), 'in $1'], [makeVariableTextRegExp('varying'), 'out $1']];
const ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [makeVariableTextRegExp('varying'), 'in $1']];
const ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, '#version 100'], [/\btexture(2D|2DProj|Cube)Lod\(/g, 'texture$1LodEXT('], [/\btexture\(/g, 'texture2D('], [/\btextureLod\(/g, 'texture2DLodEXT(']];
const ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [makeVariableTextRegExp('in'), 'attribute $1'], [makeVariableTextRegExp('out'), 'varying $1']];
const ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [makeVariableTextRegExp('in'), 'varying $1']];
const ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';
const ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }
  return source;
}
function convertFragmentShaderTo100(source) {
  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
  const outputMatch = ES300_FRAGMENT_OUTPUT_REGEX.exec(source);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, '').replace(new RegExp(`\\b${outputName}\\b`, 'g'), ES100_FRAGMENT_OUTPUT_NAME);
  }
  return source;
}
function makeVariableTextRegExp(qualifier) {
  return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, 'g');
}
//# sourceMappingURL=transpile-glsl-shader.js.map