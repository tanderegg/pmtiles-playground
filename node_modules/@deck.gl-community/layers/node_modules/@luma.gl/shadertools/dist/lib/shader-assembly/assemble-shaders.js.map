{"version":3,"file":"assemble-shaders.js","names":["glsl","resolveModules","getPlatformShaderDefines","getVersionDefines","injectShader","DECLARATION_INJECT_MARKER","transpileGLSLShader","normalizeShaderHooks","getShaderHooks","assert","getShaderInfo","INJECT_SHADER_DECLARATIONS","FRAGMENT_SHADER_PROLOGUE","assembleShaders","options","vs","fs","modules","platformInfo","shaderLanguage","assembleGLSLShader","source","stage","getUniforms","assembleGetUniforms","assembleWGSLShader","hookFunctions","inject","log","coreSource","assembledSource","hookFunctionMap","hookInjections","declInjections","mainInjections","key","injection","order","match","exec","hash","name","modulesToInject","type","module","checkDeprecations","moduleSource","getModuleSource","injections","injectionType","push","id","language","defines","prologue","sourceVersion","version","targetVersion","shaderLanguageVersion","sourceVersionDirective","sourceLines","split","slice","join","allDefines","forEach","Object","assign","getDefines","getShaderNameDefine","toUpperCase","getApplicationDefines","trim","opts","uniforms","moduleUniforms","injectShaderName","indexOf","arguments","length","undefined","sourceText","define","value","Number","isFinite"],"sources":["../../../src/lib/shader-assembly/assemble-shaders.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport {glsl} from '../glsl-utils/highlight';\nimport {resolveModules} from './resolve-modules';\nimport {PlatformInfo} from './platform-info';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport {injectShader, DECLARATION_INJECT_MARKER} from './shader-injections';\nimport {transpileGLSLShader} from '../shader-transpiler/transpile-glsl-shader';\nimport {ShaderModuleInstance} from '../shader-module/shader-module-instance';\nimport type {ShaderInjection} from './shader-injections';\nimport type {ShaderModule} from '../shader-module/shader-module';\nimport {ShaderHook, normalizeShaderHooks, getShaderHooks} from './shader-hooks';\nimport {assert} from '../utils/assert';\nimport { getShaderInfo } from '../glsl-utils/get-shader-info';\n\n/** Define map */\nexport type ShaderDefine = string | number | boolean;\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n`;\n\n/**\n * Precision prologue to inject before functions are injected in shader\n * TODO - extract any existing prologue in the fragment source and move it up...\n */\nconst FRAGMENT_SHADER_PROLOGUE = glsl`\\\nprecision highp float;\n`;\n\nexport type HookFunction = {hook: string; header: string; footer: string; signature?: string};\n\nexport type AssembleShaderOptions = {\n  /** information about the platform (which shader language & version, extensions etc.) */\n  platformInfo: PlatformInfo,\n  /** Inject shader id #defines */\n  id?: string;\n  /** Vertex shader */\n  vs: string;\n  /** Fragment shader */\n  fs: string;\n  /** Shader type @deprecated do we still need this */\n  // type?: any;\n  /** Modules to be injected */\n  modules?: (ShaderModule | ShaderModuleInstance)[];\n  /** Defines to be injected */\n  defines?: Record<string, ShaderDefine>;\n  /** Hook functions */\n  hookFunctions?: (ShaderHook | string)[];\n  /** Code injections */\n  inject?: Record<string, string | ShaderInjection>;\n  /** Whether to inject prologue */\n  prologue?: boolean;\n  /** logger object */\n  log?: any;\n};\n\ntype AssembleStageOptions = {\n  /** Inject shader id #defines */\n  id?: string;\n  /** Vertex shader */\n  source: string;\n  stage: 'vertex' | 'fragment';\n  /** Modules to be injected */\n  modules: any[];\n  /** Defines to be injected */\n  defines?: Record<string, ShaderDefine>;\n  /** Hook functions */\n  hookFunctions?: (ShaderHook | string)[];\n  /** Code injections */\n  inject?: Record<string, string | ShaderInjection>;\n  /** Whether to inject prologue */\n  prologue?: boolean;\n  /** logger object */\n  log?: any;\n};\n\n/**\n * getUniforms function returned from the shader module system\n */\nexport type GetUniformsFunc = (opts: Record<string, any>) => Record<string, any>;\n\n/**\n * Inject a list of shader modules into shader sources\n */\nexport function assembleShaders(\n  options: AssembleShaderOptions\n): {\n  vs: string;\n  fs: string;\n  getUniforms: GetUniformsFunc;\n} {\n  const {vs, fs} = options;\n  const modules = resolveModules(options.modules || []);\n\n  switch (options.platformInfo.shaderLanguage) {\n    case 'glsl':\n      return {\n        vs: assembleGLSLShader(options.platformInfo, {...options, source: vs, stage: 'vertex', modules}),\n        fs: assembleGLSLShader(options.platformInfo, {...options, source: fs, stage: 'fragment', modules}),\n        getUniforms: assembleGetUniforms(modules)\n      };\n\n    case 'wgsl':\n      return {\n        vs: assembleWGSLShader(options.platformInfo, {...options, source: vs, stage: 'vertex', modules}),\n        fs: assembleWGSLShader(options.platformInfo, {...options, source: fs, stage: 'fragment', modules}),\n        getUniforms: assembleGetUniforms(modules)\n      };\n  }\n}\n\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nfunction assembleWGSLShader(platformInfo: PlatformInfo, options: AssembleStageOptions) {\n  const {\n    // id,\n    source,\n    stage,\n    modules,\n    // defines = {},\n    hookFunctions = [],\n    inject = {},\n    log\n  } = options;\n\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // const isVertex = type === 'vs';\n  // const sourceLines = source.split('\\n');\n\n  const coreSource = source;\n\n  // Combine Module and Application Defines\n  // const allDefines = {};\n  // modules.forEach(module => {\n  //   Object.assign(allDefines, module.getDefines());\n  // });\n  // Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  //   prologue\n  //     ? `\\\n  // ${getShaderNameDefine({id, source, type})}\n  // ${getShaderType(type)}\n  // ${getPlatformShaderDefines(platformInfo)}\n  // ${getVersionDefines(platformInfo)}\n  // ${getApplicationDefines(allDefines)}\n  // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n  // `\n  // `;\n\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections: Record<string, ShaderInjection[]> = {};\n  const declInjections: Record<string, ShaderInjection[]> = {};\n  const mainInjections: Record<string, ShaderInjection[]> = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection as any];\n        } else {\n          mainInjections[key] = [injection as any];\n        }\n      } else {\n        hookInjections[key] = [injection as any];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection as any];\n    }\n  }\n\n  // TODO - hack until shadertool modules support WebGPU\n  const modulesToInject = platformInfo.type !== 'webgpu' ? modules : [];\n\n  for (const module of modulesToInject) {\n    if (log) {\n      module.checkDeprecations(coreSource, log);\n    }\n    const moduleSource = module.getModuleSource(stage, 'wgsl');\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections[stage];\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n\n  return assembledSource;\n}\n\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nfunction assembleGLSLShader(\n  platformInfo: PlatformInfo,\n  options: {\n    id?: string;\n    source: string;\n    language?: 'glsl' | 'wgsl';\n    stage: 'vertex' | 'fragment';\n    modules: ShaderModuleInstance[];\n    defines?: Record<string, ShaderDefine>;\n    hookFunctions?: any[];\n    inject?: Record<string, string | ShaderInjection>;\n    prologue?: boolean;\n    log?: any;\n  }\n) {\n  const {\n    id,\n    source,\n    stage,\n    language = 'glsl',\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    prologue = true,\n    log\n  } = options;\n\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const sourceVersion = language === 'glsl' ?  getShaderInfo(source).version : -1;\n  const targetVersion = platformInfo.shaderLanguageVersion;\n\n  const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';\n\n  const sourceLines = source.split('\\n');\n  // TODO : keep all pre-processor statements at the beginning of the shader.\n  const coreSource = sourceLines.slice(1).join('\\n');\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  switch (language) {\n    case 'wgsl':\n      break;\n    case 'glsl':\n      assembledSource = prologue\n        ? `\\\n${sourceVersionDirective}\n\n// ----- PROLOGUE -------------------------\n${getShaderNameDefine({id, source, stage})}\n${`#define SHADER_TYPE_${stage.toUpperCase()}`}\n${getPlatformShaderDefines(platformInfo)}\n${getVersionDefines(platformInfo)}\n${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${getApplicationDefines(allDefines)}\n\n`\n        : `${sourceVersionDirective}\n`;\n      break;\n  }\n\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections: Record<string, ShaderInjection[]> = {};\n  const declInjections: Record<string, ShaderInjection[]> = {};\n  const mainInjections: Record<string, ShaderInjection[]> = {};\n\n  for (const key in inject) {\n    // @ts-expect-error\n    const injection: ShaderInjection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      module.checkDeprecations(coreSource, log);\n    }\n    const moduleSource = module.getModuleSource(stage);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections[stage];\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n  \n  if (language === 'glsl' && sourceVersion !== targetVersion) {\n    assembledSource = transpileGLSLShader(assembledSource, targetVersion, stage);\n  }\n\n  return assembledSource.trim();\n}\n\n/**\n * Returns a combined `getUniforms` covering the options for all the modules,\n * the created function will pass on options to the inidividual `getUniforms`\n * function of each shader module and combine the results into one object that\n * can be passed to setUniforms.\n * @param modules\n * @returns\n */\nfunction assembleGetUniforms(modules: ShaderModuleInstance[]) {\n  return function getUniforms(opts: Record<string, any>): Record<string, any> {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n/**\n * Generate \"glslify-compatible\" SHADER_NAME defines\n * These are understood by the GLSL error parsing function\n * If id is provided and no SHADER_NAME constant is present in source, create one\n */\nfunction getShaderNameDefine(options: {\n  id?: string;\n  source: string;\n  stage: 'vertex' | 'fragment';\n}): string {\n  const {id, source, stage} = options;\n  const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${stage}\n\n`\n    : '';\n}\n\n/** Generates application defines from an object of key value pairs */\nfunction getApplicationDefines(defines: Record<string, ShaderDefine> = {}): string {\n  let sourceText = '';\n  for (const define in defines) {\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  return sourceText;\n}\n\n/*\nfunction getHookFunctions(\n  hookFunctions: Record<string, HookFunction>,\n  hookInjections: Record<string, Injection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {\n  vs: Record<string, HookFunction>;\n  fs: Record<string, HookFunction>;\n} {\n  const result: {vs: Record<string, any>; fs: Record<string, any>} = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach((hookFunction: string | HookFunction) => {\n    let opts: HookFunction;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as HookFunction;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    if (stage !== 'vs' && stage !== 'fs') {\n      throw new Error(stage);\n    }\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n*/\n"],"mappings":"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"}