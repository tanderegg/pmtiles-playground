import { WgslReflect } from '../../libs/wgsl-reflect/wgsl_reflect.module.js';
export function getShaderLayoutFromWGSL(source) {
  const shaderLayout = {
    attributes: [],
    bindings: []
  };
  const parsedWGSL = parseWGSL(source);
  for (const uniform of parsedWGSL.uniforms) {
    const members = [];
    for (const member of uniform.type.members) {
      members.push({
        name: member.name,
        type: getType(member.type)
      });
    }
    shaderLayout.bindings.push({
      type: 'uniform',
      name: uniform.name,
      location: uniform.binding,
      group: uniform.group,
      members
    });
  }
  const vertex = parsedWGSL.entry.vertex[0];
  const attributeCount = vertex.inputs.length;
  for (let i = 0; i < attributeCount; i++) {
    const wgslAttribute = vertex.inputs[i];
    if (wgslAttribute.locationType === 'location') {
      const type = getType(wgslAttribute.type);
      shaderLayout.attributes.push({
        name: wgslAttribute.name,
        location: wgslAttribute.location,
        type
      });
    }
  }
  return shaderLayout;
}
function getType(type) {
  return type.format ? `${type.name}<${type.format.name}>` : type.name;
}
function parseWGSL(source) {
  try {
    return new WgslReflect(source);
  } catch (error) {
    if (error instanceof Error) {
      throw error;
    }
    let message = 'WGSL parse error';
    if (typeof error === 'object' && error !== null && error !== void 0 && error.message) {
      message += `: ${error.message} `;
    }
    if (typeof error === 'object' && error !== null && error !== void 0 && error.token) {
      message += error.token.line || '';
    }
    throw new Error(message, {
      cause: error
    });
  }
}
//# sourceMappingURL=get-shader-layout-wgsl.js.map