{"version":3,"file":"tiltshift.js","names":["glsl","random","fs","tiltShift","name","uniformTypes","blurRadius","gradientRadius","start","end","invert","uniformPropTypes","value","min","max","private","passes","sampler","uniforms","dependencies"],"sources":["../../../../src/modules/postprocessing/image-blur-filters/tiltshift.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport {glsl} from '../../../lib/glsl-utils/highlight';\nimport {ShaderPass} from '../../../lib/shader-module/shader-pass';\nimport {random} from '../..//math/random/random';\n\nconst fs = glsl`\\\nuniform tiltShiftUniforms {\n  float blurRadius;\n  float gradientRadius;\n  vec2 start;\n  vec2 end;\n  bool invert;\n} tiltShift;\n\nvec2 tiltShift_getDelta(vec2 texSize) {\n  vec2 vector = normalize((tiltShift.end - tiltShift.start) * texSize);\n  return tiltShift.invert ? vec2(-vector.y, vector.x) : vector;\n}\n\nvec4 tiltShift_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  vec2 normal = normalize(vec2((tiltShift.start.y - tiltShift.end.y) * texSize.y, (tiltShift.end.x - tiltShift.start.x) * texSize.x));\n  float radius = smoothstep(0.0, 1.0,\n    abs(dot(texCoord * texSize - tiltShift.start * texSize, normal)) / tiltShift.gradientRadius) * tiltShift.blurRadius;\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 offsetColor = texture(source, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    offsetColor.rgb *= offsetColor.a;\n\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n`;\n\n/**\n * Tilt Shift\n * Simulates the shallow depth of field normally encountered in close-up photography\n */\nexport type TiltShiftProps = {\n  /** The x,y coordinate of the start of the line segment. */\n  start?: number[];\n  /** The xm y coordinate of the end of the line segment. */\n  end?: number[];\n  /** The maximum radius of the pyramid blur. */\n  blurRadius?: number;\n  /** The distance from the line at which the maximum blur radius is reached. */\n  gradientRadius?: number;\n  /** @deprecated internal shaderpass use */\n  invert?: number;\n};\n\n/**\n * Tilt Shift\n * Simulates the shallow depth of field normally encountered in close-up\n * photography, which makes the scene seem much smaller than it actually\n * is. This filter assumes the scene is relatively planar, in which case\n * the part of the scene that is completely in focus can be described by\n * a line (the intersection of the focal plane and the scene). An example\n * of a planar scene might be looking at a road from above at a downward\n * angle. The image is then blurred with a blur radius that starts at zero\n * on the line and increases further from the line.\n */\nexport const tiltShift: ShaderPass<TiltShiftProps, TiltShiftProps> = {\n  name: 'tiltShift',\n  uniformTypes: {\n    blurRadius: 'f32',\n    gradientRadius: 'f32',\n    start: 'vec2<f32>',\n    end: 'vec2<f32>',\n    invert: 'i32'\n  },\n  uniformPropTypes: {\n    blurRadius: {value: 15, min: 0, max: 50},\n    gradientRadius: {value: 200, min: 0, max: 400},\n    start: {value: [0, 0]},\n    end: {value: [1, 1]},\n    invert: {value: false, private: true}\n  },\n  passes: [\n    {sampler: true, uniforms: {invert: false}},\n    {sampler: true, uniforms: {invert: true}}\n  ],\n  dependencies: [random],\n  fs\n};\n\n/*\nfunction tiltShift(startX, startY, endX, endY, blurRadius, gradientRadius) {\n  var dx = endX - startX;\n  var dy = endY - startY;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  simpleShader.call(this, gl.tiltShift, {\n    blurRadius: blurRadius,\n    gradientRadius: gradientRadius,\n    start: [startX, startY],\n    end: [endX, endY],\n    delta: [dx / d, dy / d],\n    texSize: [this.width, this.height]\n  });\n  simpleShader.call(this, gl.tiltShift, {\n    blurRadius: blurRadius,\n    gradientRadius: gradientRadius,\n    start: [startX, startY],\n    end: [endX, endY],\n    delta: [-dy / d, dx / d],\n    texSize: [this.width, this.height]\n  });\n\n  return this;\n}\n*/\n"],"mappings":"SAGQA,IAAI;AAAA,SAEJC,MAAM;AAEd,MAAMC,EAAE,GAAGF,IAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AA8BD,OAAO,MAAMG,SAAqD,GAAG;EACnEC,IAAI,EAAE,WAAW;EACjBC,YAAY,EAAE;IACZC,UAAU,EAAE,KAAK;IACjBC,cAAc,EAAE,KAAK;IACrBC,KAAK,EAAE,WAAW;IAClBC,GAAG,EAAE,WAAW;IAChBC,MAAM,EAAE;EACV,CAAC;EACDC,gBAAgB,EAAE;IAChBL,UAAU,EAAE;MAACM,KAAK,EAAE,EAAE;MAAEC,GAAG,EAAE,CAAC;MAAEC,GAAG,EAAE;IAAE,CAAC;IACxCP,cAAc,EAAE;MAACK,KAAK,EAAE,GAAG;MAAEC,GAAG,EAAE,CAAC;MAAEC,GAAG,EAAE;IAAG,CAAC;IAC9CN,KAAK,EAAE;MAACI,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC;IAAC,CAAC;IACtBH,GAAG,EAAE;MAACG,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC;IAAC,CAAC;IACpBF,MAAM,EAAE;MAACE,KAAK,EAAE,KAAK;MAAEG,OAAO,EAAE;IAAI;EACtC,CAAC;EACDC,MAAM,EAAE,CACN;IAACC,OAAO,EAAE,IAAI;IAAEC,QAAQ,EAAE;MAACR,MAAM,EAAE;IAAK;EAAC,CAAC,EAC1C;IAACO,OAAO,EAAE,IAAI;IAAEC,QAAQ,EAAE;MAACR,MAAM,EAAE;IAAI;EAAC,CAAC,CAC1C;EACDS,YAAY,EAAE,CAAClB,MAAM,CAAC;EACtBC;AACF,CAAC"}