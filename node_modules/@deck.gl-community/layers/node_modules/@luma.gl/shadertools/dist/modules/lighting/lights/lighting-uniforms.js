import { lightingUniforms } from "./lighting-uniforms.glsl.js";
const MAX_LIGHTS = 5;
const COLOR_FACTOR = 255.0;
var LIGHT_TYPE = function (LIGHT_TYPE) {
  LIGHT_TYPE[LIGHT_TYPE["POINT"] = 0] = "POINT";
  LIGHT_TYPE[LIGHT_TYPE["DIRECTIONAL"] = 1] = "DIRECTIONAL";
  return LIGHT_TYPE;
}(LIGHT_TYPE || {});
export const lighting = {
  name: 'lighting',
  vs: lightingUniforms,
  fs: lightingUniforms,
  getUniforms(props, prevUniforms) {
    return getUniforms(props);
  },
  defines: {
    MAX_LIGHTS
  },
  uniformTypes: {
    enabled: 'i32',
    ambientLightColor: 'vec3<f32>',
    numberOfLights: 'i32',
    lightType: 'i32',
    lightColor: 'vec3<f32>',
    lightPosition: 'vec3<f32>',
    lightDirection: 'vec3<f32>',
    lightAttenuation: 'vec3<f32>'
  },
  defaultUniforms: {
    enabled: 1,
    ambientLightColor: [0.1, 0.1, 0.1],
    numberOfLights: 0,
    lightType: LIGHT_TYPE.POINT,
    lightColor: [1, 1, 1],
    lightPosition: [1, 1, 2],
    lightDirection: [1, 1, 1],
    lightAttenuation: [1, 1, 1]
  }
};
function getUniforms(props) {
  let prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  props = props ? {
    ...props
  } : props;
  if (!props) {
    return {
      ...lighting.defaultUniforms
    };
  }
  if (props.lights) {
    props = {
      ...props,
      ...extractLightTypes(props.lights),
      lights: undefined
    };
  }
  const {
    ambientLight,
    pointLights,
    directionalLights
  } = props || {};
  const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
  if (!hasLights) {
    return {
      ...lighting.defaultUniforms,
      enabled: 0
    };
  }
  const uniforms = {
    ...lighting.defaultUniforms,
    ...prevUniforms,
    ...getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    })
  };
  if (props.enabled !== undefined) {
    uniforms.enabled = props.enabled ? 1 : 0;
  }
  return uniforms;
}
function getLightSourceUniforms(_ref) {
  let {
    ambientLight,
    pointLights = [],
    directionalLights = []
  } = _ref;
  const lightSourceUniforms = {};
  lightSourceUniforms.ambientLightColor = convertColor(ambientLight);
  let currentLight = 0;
  for (const pointLight of pointLights) {
    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;
    lightSourceUniforms.lightColor = convertColor(pointLight);
    lightSourceUniforms.lightPosition = pointLight.position;
    lightSourceUniforms.lightAttenuation = [pointLight.attenuation || 1, 0, 0];
    currentLight++;
  }
  for (const directionalLight of directionalLights) {
    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;
    lightSourceUniforms.lightColor = convertColor(directionalLight);
    lightSourceUniforms.lightPosition = directionalLight.position;
    lightSourceUniforms.lightDirection = directionalLight.direction;
    currentLight++;
  }
  lightSourceUniforms.numberOfLights = currentLight;
  return lightSourceUniforms;
}
function extractLightTypes(lights) {
  var _lightSources$directi, _lightSources$pointLi;
  const lightSources = {
    pointLights: [],
    directionalLights: []
  };
  for (const light of lights || []) {
    switch (light.type) {
      case 'ambient':
        lightSources.ambientLight = light;
        break;
      case 'directional':
        (_lightSources$directi = lightSources.directionalLights) === null || _lightSources$directi === void 0 ? void 0 : _lightSources$directi.push(light);
        break;
      case 'point':
        (_lightSources$pointLi = lightSources.pointLights) === null || _lightSources$pointLi === void 0 ? void 0 : _lightSources$pointLi.push(light);
        break;
      default:
    }
  }
  return lightSources;
}
function convertColor() {
  let colorDef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    color = [0, 0, 0],
    intensity = 1.0
  } = colorDef;
  return color.map(component => component * intensity / COLOR_FACTOR);
}
//# sourceMappingURL=lighting-uniforms.js.map