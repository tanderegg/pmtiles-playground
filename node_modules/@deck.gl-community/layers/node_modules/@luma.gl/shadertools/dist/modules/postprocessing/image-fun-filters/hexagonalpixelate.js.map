{"version":3,"file":"hexagonalpixelate.js","names":["glsl","fs","hexagonalPixelate","name","uniformTypes","center","scale","uniformPropTypes","value","hint","min","softMin","softMax","passes","sampler"],"sources":["../../../../src/modules/postprocessing/image-fun-filters/hexagonalpixelate.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport {ShaderPass} from '../../../lib/shader-module/shader-pass';\nimport {glsl} from '../../../lib/glsl-utils/highlight';\n\nconst fs = glsl`\\\nuniform hexagonalPixelateUniforms {\n  vec2 center;\n  float scale;\n} hexagonalPixelate;\n\nvec4 hexagonalPixelate_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - hexagonalPixelate.center * texSize) / hexagonalPixelate.scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= hexagonalPixelate.scale / texSize;\n\n  return texture(source, choice + hexagonalPixelate.center);\n}\n`;\n\n/**\n * Hexagonal Pixelate\n * Renders the image using a pattern of hexagonal tiles. \n * Tile colors are nearest-neighbor sampled from the centers of the tiles.\n */\nexport type HexagonalPixelateProps = {\n  /** The [x, y] coordinates of the pattern center. */\n  center?: number[];\n  /** The width of an individual tile, in pixels. */\n  scale?: number;\n};\n\n/**\n * Hexagonal Pixelate\n * Renders the image using a pattern of hexagonal tiles. Tile colors\n * are nearest-neighbor sampled from the centers of the tiles.\n */\nexport const hexagonalPixelate: ShaderPass<HexagonalPixelateProps, HexagonalPixelateProps> = {\n  name: 'hexagonalPixelate',\n  uniformTypes: {\n    center: 'vec2<f32>',\n    scale: 'f32'\n  },\n  uniformPropTypes: {\n    center: {value: [0.5, 0.5], hint: 'screenspace'},\n    scale: {value: 10, min: 1, softMin: 5, softMax: 50}\n  },\n  fs,\n  passes: [{sampler: true}]\n};\n"],"mappings":"SAIQA,IAAI;AAEZ,MAAMC,EAAE,GAAGD,IAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAmBD,OAAO,MAAME,iBAA6E,GAAG;EAC3FC,IAAI,EAAE,mBAAmB;EACzBC,YAAY,EAAE;IACZC,MAAM,EAAE,WAAW;IACnBC,KAAK,EAAE;EACT,CAAC;EACDC,gBAAgB,EAAE;IAChBF,MAAM,EAAE;MAACG,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;MAAEC,IAAI,EAAE;IAAa,CAAC;IAChDH,KAAK,EAAE;MAACE,KAAK,EAAE,EAAE;MAAEE,GAAG,EAAE,CAAC;MAAEC,OAAO,EAAE,CAAC;MAAEC,OAAO,EAAE;IAAE;EACpD,CAAC;EACDX,EAAE;EACFY,MAAM,EAAE,CAAC;IAACC,OAAO,EAAE;EAAI,CAAC;AAC1B,CAAC"}