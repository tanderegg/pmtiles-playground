{"version":3,"file":"lights.js","names":["lightingShader","INITIAL_MODULE_OPTIONS","lightSources","convertColor","colorDef","arguments","length","undefined","color","intensity","map","component","getLightSourceUniforms","_ref","ambientLight","pointLights","directionalLights","lightSourceUniforms","forEach","pointLight","index","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","getUniforms","_lightSources$directi","_lightSources$pointLi","opts","hasLights","lighting_uEnabled","Object","assign","light","lights","type","push","name","vs","fs","defines","MAX_LIGHTS"],"sources":["../../../../src/modules-webgl1/lighting/lights/lights.ts"],"sourcesContent":["import type {NumberArray} from '../../../types';\nimport {lightingShader} from './lights.glsl';\n\n/* eslint-disable camelcase */\n\ntype LightSources = {\n  ambientLight?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n  };\n  pointLights?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n    position: NumberArray;\n    attenuation: number;\n  }[];\n  directionalLights?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n    position: NumberArray;\n    direction: NumberArray;\n  }[];\n};\n\nexport type LightsOptions = {\n  lightSources?: LightSources;\n};\n\nconst INITIAL_MODULE_OPTIONS: Required<LightsOptions> = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor(colorDef: {color?: Readonly<NumberArray>, intensity?: number} = {}): NumberArray {\n  const {color = [0, 0, 0], intensity = 1.0} = colorDef;\n  return color.map((component) => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}: LightSources): Record<string, any> {\n  const lightSourceUniforms: Record<string, any> = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1, 0, 0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] =\n      convertColor(directionalLight);\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts: LightsOptions = INITIAL_MODULE_OPTIONS): Record<string, any> {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources: LightSources = {pointLights: [], directionalLights: []};\n    // @ts-expect-error\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights?.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights?.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/**\n * An implementation of PBR (Physically-Based Rendering).\n * Physically Based Shading of a microfacet surface defined by a glTF material.\n */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n"],"mappings":"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"}