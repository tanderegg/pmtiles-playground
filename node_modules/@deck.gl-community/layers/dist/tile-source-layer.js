import { CompositeLayer } from '@deck.gl/core';
import { TileLayer } from '@deck.gl/geo-layers';
import { BitmapLayer, GeoJsonLayer, PathLayer } from '@deck.gl/layers';
const devicePixelRatio = typeof window !== 'undefined' && window.devicePixelRatio || 1;
export class TileSourceLayer extends CompositeLayer {
  constructor() {
    super(...arguments);
    this.state = void 0;
  }
  initializeState() {
    this.setState({
      tileSource: null
    });
  }
  updateState(_ref) {
    let {
      props,
      changeFlags
    } = _ref;
    this.setState({
      tileSource: props.tileSource
    });
  }
  renderLayers() {
    const {
      tileSource,
      showTileBorders,
      metadata,
      onTilesLoad
    } = this.props;
    const minZoom = (metadata === null || metadata === void 0 ? void 0 : metadata.minZoom) || 0;
    const maxZoom = (metadata === null || metadata === void 0 ? void 0 : metadata.maxZoom) || 30;
    return [new TileLayer({
      id: String(tileSource.url),
      getTileData: tileSource.getTileData,
      maxRequests: 20,
      pickable: true,
      onViewportLoad: onTilesLoad,
      autoHighlight: showTileBorders,
      highlightColor: [60, 60, 60, 40],
      minZoom,
      maxZoom,
      tileSize: 256,
      zoomOffset: devicePixelRatio === 1 ? -1 : 0,
      renderSubLayers,
      tileSource,
      showTileBorders
    })];
  }
}
TileSourceLayer.layerName = 'TileSourceLayer';
TileSourceLayer.defaultProps = {
  ...TileLayer.defaultProps,
  showTileBorders: true
};
function renderSubLayers(props) {
  const {
    tileSource,
    showTileBorders,
    minZoom,
    maxZoom,
    tile: {
      index: {
        z: zoom
      },
      bbox: {
        west,
        south,
        east,
        north
      }
    }
  } = props;
  const layers = [];
  const borderColor = zoom <= minZoom || zoom >= maxZoom ? [255, 0, 0, 255] : [0, 0, 255, 255];
  switch (tileSource.mimeType) {
    case 'application/vnd.mapbox-vector-tile':
      layers.push(new GeoJsonLayer({
        id: `${props.id}-geojson`,
        data: props.data,
        pickable: true,
        getFillColor: [0, 190, 80, 255],
        lineWidthScale: 500,
        lineWidthMinPixels: 0.5
      }));
      break;
    case 'image/png':
    case 'image/jpeg':
    case 'image/webp':
    case 'image/avif':
      layers.push(new BitmapLayer(props, {
        data: null,
        image: props.data,
        bounds: [west, south, east, north],
        pickable: true
      }));
      break;
    default:
      console.error('Unknown tile mimeType', tileSource === null || tileSource === void 0 ? void 0 : tileSource.mimeType);
  }
  if (showTileBorders) {
    layers.push(new PathLayer({
      id: `${props.id}-border`,
      data: [[[west, north], [west, south], [east, south], [east, north], [west, north]]],
      getPath: d => d,
      getColor: borderColor,
      widthMinPixels: 4
    }));
  }
  return layers;
}
//# sourceMappingURL=tile-source-layer.js.map