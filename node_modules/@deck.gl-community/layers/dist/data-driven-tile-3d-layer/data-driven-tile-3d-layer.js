import { Tile3DLayer } from '@deck.gl/geo-layers';
import { TILE_TYPE, Tileset3D } from '@loaders.gl/tiles';
import { load } from '@loaders.gl/core';
const defaultProps = {
  colorsByAttribute: null,
  filtersByAttribute: null
};
export class DataDrivenTile3DLayer extends Tile3DLayer {
  constructor() {
    super(...arguments);
    this.state = void 0;
  }
  initializeState() {
    super.initializeState();
    this.setState({
      colorsByAttribute: this.props.colorsByAttribute,
      filtersByAttribute: this.props.filtersByAttribute,
      loadingCounter: 0
    });
  }
  updateState(params) {
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    if (props.data && props.data !== oldProps.data) {
      this._loadTileset(props.data);
    } else if (props.colorsByAttribute !== oldProps.colorsByAttribute) {
      this.setState({
        colorsByAttribute: props.colorsByAttribute
      });
      this._colorizeTileset();
    } else if (props.filtersByAttribute !== oldProps.filtersByAttribute) {
      this.setState({
        filtersByAttribute: props.filtersByAttribute
      });
      this._filterTileset();
    } else if (changeFlags.viewportChanged) {
      const {
        activeViewports
      } = this.state;
      const viewportsNumber = Object.keys(activeViewports).length;
      if (viewportsNumber) {
        if (!this.state.loadingCounter) {
          super._updateTileset(activeViewports);
        }
        this.state.lastUpdatedViewports = activeViewports;
        this.state.activeViewports = {};
      }
    } else {
      super.updateState(params);
    }
  }
  async _loadTileset(tilesetUrl) {
    const {
      loadOptions = {}
    } = this.props;
    let loader = this.props.loader || this.props.loaders;
    if (Array.isArray(loader)) {
      loader = loader[0];
    }
    const options = {
      loadOptions: {
        ...loadOptions
      }
    };
    if (loader.preload) {
      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
      if (preloadOptions.headers) {
        options.loadOptions.fetch = {
          ...options.loadOptions.fetch,
          headers: preloadOptions.headers
        };
      }
      Object.assign(options, preloadOptions);
    }
    const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);
    const tileset3d = new Tileset3D(tilesetJson, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: super._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      onTraversalComplete: this._onTraversalComplete.bind(this),
      ...options
    });
    this.setState({
      tileset3d,
      layerMap: {}
    });
    super._updateTileset(this.state.activeViewports);
    this.props.onTilesetLoad(tileset3d);
  }
  _onTileLoad(tileHeader) {
    const {
      lastUpdatedViewports
    } = this.state;
    this._colorizeTiles([tileHeader]);
    this._filterTiles([tileHeader]);
    this.props.onTileLoad(tileHeader);
    if (!this.state.colorsByAttribute && !this.state.filtersByAttribute) {
      super._updateTileset(lastUpdatedViewports);
      this.setNeedsUpdate();
    }
  }
  _onTraversalComplete(selectedTiles) {
    this._colorizeTiles(selectedTiles);
    this._filterTiles(selectedTiles);
    return this.props.onTraversalComplete ? this.props.onTraversalComplete(selectedTiles) : selectedTiles;
  }
  _colorizeTiles(tiles) {
    var _tiles$;
    if (this.props.customizeColors && ((_tiles$ = tiles[0]) === null || _tiles$ === void 0 ? void 0 : _tiles$.type) === TILE_TYPE.MESH) {
      const {
        layerMap,
        colorsByAttribute
      } = this.state;
      const promises = [];
      for (const tile of tiles) {
        promises.push(this.props.customizeColors(tile, colorsByAttribute));
      }
      this.setState({
        loadingCounter: this.state.loadingCounter + 1
      });
      Promise.allSettled(promises).then(result => {
        this.setState({
          loadingCounter: this.state.loadingCounter - 1
        });
        let isTileChanged = false;
        for (const item of result) {
          if (item.status === 'fulfilled' && item.value.isColored) {
            isTileChanged = true;
            delete layerMap[item.value.id];
          }
        }
        if (isTileChanged && !this.state.loadingCounter) {
          super._updateTileset(this.state.activeViewports);
          this.setNeedsUpdate();
        }
      });
    }
  }
  _colorizeTileset() {
    const {
      tileset3d
    } = this.state;
    if (tileset3d) {
      this._colorizeTiles(tileset3d.selectedTiles);
    }
  }
  _filterTiles(tiles) {
    var _tiles$2;
    if (this.props.filterTile && ((_tiles$2 = tiles[0]) === null || _tiles$2 === void 0 ? void 0 : _tiles$2.type) === TILE_TYPE.MESH) {
      const {
        layerMap,
        filtersByAttribute
      } = this.state;
      const promises = [];
      for (const tile of tiles) {
        promises.push(this.props.filterTile(tile, filtersByAttribute));
      }
      this.setState({
        loadingCounter: this.state.loadingCounter + 1
      });
      Promise.allSettled(promises).then(result => {
        this.setState({
          loadingCounter: this.state.loadingCounter - 1
        });
        let isTileChanged = false;
        for (const item of result) {
          if (item.status === 'fulfilled' && item.value.isFiltered) {
            isTileChanged = true;
            delete layerMap[item.value.id];
          }
        }
        if (isTileChanged && !this.state.loadingCounter) {
          super._updateTileset(this.state.activeViewports);
          this.setNeedsUpdate();
        }
      });
    }
  }
  _filterTileset() {
    const {
      tileset3d
    } = this.state;
    if (tileset3d) {
      this._filterTiles(tileset3d.selectedTiles);
    }
  }
}
DataDrivenTile3DLayer.layerName = 'DataDrivenTile3DLayer';
DataDrivenTile3DLayer.defaultProps = defaultProps;
//# sourceMappingURL=data-driven-tile-3d-layer.js.map