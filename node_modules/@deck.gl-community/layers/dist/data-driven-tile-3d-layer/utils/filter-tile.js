import { I3SAttributeLoader } from '@loaders.gl/i3s';
import { load } from '@loaders.gl/core';
export const filterTile = async (tile, filtersByAttribute) => {
  var _tile$content$userDat;
  const result = {
    isFiltered: false,
    id: tile.id
  };
  if (((_tile$content$userDat = tile.content.userData) === null || _tile$content$userDat === void 0 ? void 0 : _tile$content$userDat.customFilters) !== filtersByAttribute) {
    var _tile$content$userDat4;
    if (tile.content && filtersByAttribute) {
      var _tile$content$userDat2, _tile$content$userDat3;
      if (((_tile$content$userDat2 = tile.content.userData) === null || _tile$content$userDat2 === void 0 ? void 0 : _tile$content$userDat2.originalIndices) === undefined) {
        tile.content.userData = {};
        tile.content.userData.originalIndices = tile.content.indices;
      }
      tile.content.indices = (_tile$content$userDat3 = tile.content.userData) === null || _tile$content$userDat3 === void 0 ? void 0 : _tile$content$userDat3.originalIndices;
      tile.content.userData.customFilters = filtersByAttribute;
      const {
        indices
      } = await filterTileIndices(tile, filtersByAttribute, tile.tileset.loadOptions.i3s.token);
      if (indices && tile.content.userData.customFilters === filtersByAttribute) {
        tile.content.indices = indices;
        result.isFiltered = true;
      }
    } else if (tile.content && ((_tile$content$userDat4 = tile.content.userData) === null || _tile$content$userDat4 === void 0 ? void 0 : _tile$content$userDat4.originalIndices) !== undefined) {
      tile.content.indices = tile.content.userData.originalIndices;
      tile.content.userData.customFilters = null;
      result.isFiltered = true;
    }
  }
  return result;
};
async function filterTileIndices(tile, filtersByAttribute, token) {
  var _objectIdAttributeDat;
  if (!filtersByAttribute.attributeName.length) {
    return {
      success: false
    };
  }
  const filterAttributeField = tile.tileset.tileset.fields.find(_ref => {
    let {
      name
    } = _ref;
    return name === (filtersByAttribute === null || filtersByAttribute === void 0 ? void 0 : filtersByAttribute.attributeName);
  });
  if (!filterAttributeField || !['esriFieldTypeDouble', 'esriFieldTypeInteger', 'esriFieldTypeSmallInteger'].includes(filterAttributeField.type)) {
    return {
      success: false
    };
  }
  const tileFilterAttributeData = await loadFeatureAttributeData(filterAttributeField.name, tile.header.attributeUrls, tile.tileset.tileset.attributeStorageInfo, token);
  if (!tileFilterAttributeData) {
    return {
      success: false
    };
  }
  const objectIdField = tile.tileset.tileset.fields.find(_ref2 => {
    let {
      type
    } = _ref2;
    return type === 'esriFieldTypeOID';
  });
  if (!objectIdField) {
    return {
      success: false
    };
  }
  const objectIdAttributeData = await loadFeatureAttributeData(objectIdField.name, tile.header.attributeUrls, tile.tileset.tileset.attributeStorageInfo, token);
  if (!objectIdAttributeData) {
    return {
      success: false
    };
  }
  const attributeValuesMap = {};
  (_objectIdAttributeDat = objectIdAttributeData[objectIdField.name]) === null || _objectIdAttributeDat === void 0 || _objectIdAttributeDat.forEach((elem, index) => {
    attributeValuesMap[elem] = tileFilterAttributeData[filterAttributeField.name][index];
  });
  if (!tile.content.indices) {
    const triangles = [];
    for (let i = 0; i < tile.content.featureIds.length; i += 3) {
      if (attributeValuesMap[tile.content.featureIds[i]] === filtersByAttribute.value) {
        triangles.push(i);
      }
    }
    const indices = new Uint32Array(3 * triangles.length);
    triangles.forEach((vertex, index) => {
      indices[index * 3] = vertex;
      indices[index * 3 + 1] = vertex + 1;
      indices[index * 3 + 2] = vertex + 2;
    });
    return {
      success: true,
      indices
    };
  } else {
    const triangles = [];
    for (let i = 0; i < tile.content.indices.length; i += 3) {
      if (attributeValuesMap[tile.content.featureIds[tile.content.indices[i]]] === filtersByAttribute.value) {
        triangles.push(i);
      }
    }
    const indices = new Uint32Array(3 * triangles.length);
    triangles.forEach((vertex, index) => {
      indices[index * 3] = tile.content.indices[vertex];
      indices[index * 3 + 1] = tile.content.indices[vertex + 1];
      indices[index * 3 + 2] = tile.content.indices[vertex + 2];
    });
    return {
      success: true,
      indices
    };
  }
}
async function loadFeatureAttributeData(attributeName, attributeUrls, attributesStorageInfo, token) {
  const attributeIndex = attributesStorageInfo.findIndex(_ref3 => {
    let {
      name
    } = _ref3;
    return attributeName === name;
  });
  if (attributeIndex === -1) {
    return null;
  }
  const objectIdAttributeUrl = getUrlWithToken(attributeUrls[attributeIndex], token);
  const attributeType = getAttributeValueType(attributesStorageInfo[attributeIndex]);
  const objectIdAttributeData = await load(objectIdAttributeUrl, I3SAttributeLoader, {
    attributeName,
    attributeType
  });
  return objectIdAttributeData;
}
function getUrlWithToken(url) {
  let token = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return token ? `${url}?token=${token}` : url;
}
function getAttributeValueType(attribute) {
  if (attribute.hasOwnProperty('objectIds')) {
    return 'Oid32';
  } else if (attribute.hasOwnProperty('attributeValues')) {
    var _attribute$attributeV;
    return (_attribute$attributeV = attribute.attributeValues) === null || _attribute$attributeV === void 0 ? void 0 : _attribute$attributeV.valueType;
  }
  return '';
}
//# sourceMappingURL=filter-tile.js.map