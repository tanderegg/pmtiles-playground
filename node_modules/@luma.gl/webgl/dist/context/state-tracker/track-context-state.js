import { assert } from '@luma.gl/core';
import { GL_PARAMETER_DEFAULTS, GL_HOOKED_SETTERS, NON_CACHE_PARAMETERS } from "../parameters/webgl-parameter-tables.js";
import { setGLParameters, getGLParameters } from "../parameters/unified-parameter-api.js";
import { deepArrayEqual } from "./deep-array-equal.js";
class GLState {
  constructor(gl) {
    let {
      copyState = false,
      log = () => {}
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = void 0;
    this.program = null;
    this.stateStack = [];
    this.enable = true;
    this.cache = void 0;
    this.log = void 0;
    this.gl = gl;
    this.cache = copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
    this.log = log;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }
  push() {
    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.stateStack.push({});
  }
  pop() {
    assert(this.stateStack.length > 0);
    const oldValues = this.stateStack[this.stateStack.length - 1];
    setGLParameters(this.gl, oldValues);
    this.stateStack.pop();
  }
  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const key in values) {
      assert(key !== undefined);
      const value = values[key];
      const cached = this.cache[key];
      if (!deepArrayEqual(value, cached)) {
        valueChanged = true;
        oldValue = cached;
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }
        this.cache[key] = value;
      }
    }
    return {
      valueChanged,
      oldValue
    };
  }
}
function getContextState(gl) {
  return gl.state;
}
export function trackContextState(gl, options) {
  const {
    enable = true,
    copyState
  } = options;
  assert(copyState !== undefined);
  if (!gl.state) {
    gl.state = new GLState(gl, {
      copyState
    });
    installProgramSpy(gl);
    for (const key in GL_HOOKED_SETTERS) {
      const setter = GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }
  const glState = getContextState(gl);
  glState.enable = enable;
  return gl;
}
export function pushContextState(gl) {
  let glState = getContextState(gl);
  if (!glState) {
    trackContextState(gl, {
      copyState: false
    });
    glState = getContextState(gl);
  }
  glState.push();
}
export function popContextState(gl) {
  const glState = getContextState(gl);
  assert(glState);
  glState.pop();
}
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get(pname) {
    if (pname === undefined || NON_CACHE_PARAMETERS.has(pname)) {
      return originalGetterFunc(pname);
    }
    const glState = getContextState(gl);
    if (!(pname in glState.cache)) {
      glState.cache[pname] = originalGetterFunc(pname);
    }
    return glState.enable ? glState.cache[pname] : originalGetterFunc(pname);
  };
  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-from-cache`,
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  if (!gl[functionName]) {
    return;
  }
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set() {
    const glState = getContextState(gl);
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    const {
      valueChanged,
      oldValue
    } = setter(glState._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-to-cache`,
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    const glState = getContextState(gl);
    if (glState.program !== handle) {
      originalUseProgram(handle);
      glState.program = handle;
    }
  };
}
//# sourceMappingURL=track-context-state.js.map