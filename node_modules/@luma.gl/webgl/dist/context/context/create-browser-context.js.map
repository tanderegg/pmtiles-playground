{"version":3,"file":"create-browser-context.js","names":["DEFAULT_CONTEXT_PROPS","webgl2","webgl1","powerPreference","onContextLost","console","error","onContextRestored","info","createBrowserContext","canvas","props","errorMessage","onCreateError","statusMessage","addEventListener","gl","type","getContext","removeEventListener","Error","event"],"sources":["../../../src/context/context/create-browser-context.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\n/**\n * ContextProps\n * @param webgl2 Set to false to not create a WebGL2 context (force webgl1)\n * @param webgl1 set to false to not create a WebGL1 context (fail if webgl2 not available)\n * @param onContextLost\n * @param onContextRestored\n *\n * BROWSER CONTEXT PARAMETERS\n * @param debug Instrument context (at the expense of performance).\n * @param alpha Default render target has an alpha buffer.\n * @param depth Default render target has a depth buffer of at least 16 bits.\n * @param stencil Default render target has a stencil buffer of at least 8 bits.\n * @param antialias Boolean that indicates whether or not to perform anti-aliasing.\n * @param premultipliedAlpha Boolean that indicates that the page compositor will assume the drawing buffer contains colors with pre-multiplied alpha.\n * @param preserveDrawingBuffer Default render target buffers will not be automatically cleared and will preserve their values until cleared or overwritten\n * @param failIfMajorPerformanceCaveat Do not create if the system performance is low.\n */\ntype ContextProps = {\n  type?: 'webgl' | 'webgl1' | 'webgl2' | string;\n  webgl1?: boolean;\n  webgl2?: boolean;\n  onContextLost?: (event: Event) => void;\n  onContextRestored?: (event: Event) => void;\n  alpha?: boolean; // indicates if the canvas contains an alpha buffer.\n  desynchronized?: boolean; // hints the user agent to reduce the latency by desynchronizing the canvas paint cycle from the event loop\n  antialias?: boolean; // indicates whether or not to perform anti-aliasing.\n  depth?: boolean; // indicates that the drawing buffer has a depth buffer of at least 16 bits.\n  failIfMajorPerformanceCaveat?: boolean; // indicates if a context will be created if the system performance is low or if no hardware GPU is available.\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  premultipliedAlpha?: boolean; // page compositor will assume the drawing buffer contains colors with pre-multiplied alpha.\n  preserveDrawingBuffer?: boolean; // buffers will not be cleared and will preserve their values until cleared or overwritten by the author.\n};\n\nconst DEFAULT_CONTEXT_PROPS: ContextProps = {\n  webgl2: true, // Attempt to create a WebGL2 context\n  webgl1: true, // Attempt to create a WebGL1 context (false to fail if webgl2 not available)\n  powerPreference: 'high-performance', // After all, most apps are using WebGL for performance reasons\n  // eslint-disable-next-line no-console\n  onContextLost: () => console.error('WebGL context lost'),\n  // eslint-disable-next-line no-console\n  onContextRestored: () => console.info('WebGL context restored')\n};\n\n/**\n * Create a WebGL context for a canvas\n * Note calling this multiple time on the same canvas does return the same context\n * @param canvas A canvas element or offscreen canvas\n */\nexport function createBrowserContext(\n  canvas: HTMLCanvasElement | OffscreenCanvas,\n  props: ContextProps\n): WebGLRenderingContext {\n  props = {...DEFAULT_CONTEXT_PROPS, ...props};\n\n  // Try to extract any extra information about why context creation failed\n  let errorMessage = null;\n  const onCreateError = error => (errorMessage = error.statusMessage || errorMessage);\n  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);\n\n  // Create the desired context\n  let gl: WebGLRenderingContext | WebGL2RenderingContext | null = null;\n\n  if (props.type === 'webgl2') {\n    props = {...props, webgl1: false};\n  }\n  if (props.type === 'webgl1') {\n    props = {...props, webgl2: false};\n  }\n\n  // props.failIfMajorPerformanceCaveat = true;\n\n  // Prefer webgl2 over webgl1 if both are acceptable\n  if (!gl && props.webgl2) {\n    gl = canvas.getContext('webgl2', props) as WebGL2RenderingContext;\n  }\n  if (!gl && props.webgl1) {\n    gl = canvas.getContext('webgl', props) as WebGLRenderingContext;\n  }\n\n  // Software GPU\n\n  // props.failIfMajorPerformanceCaveat = false;\n  // if (!gl && props.webgl2) {\n  //   gl = canvas.getContext('webgl2', props);\n  // }\n  // if (!gl && props.webgl1) {\n  //   gl = canvas.getContext('webgl', props);\n  // }\n\n  // TODO are we removing this listener before giving it a chance to fire?\n  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);\n\n  if (!gl) {\n    throw new Error(\n      `Failed to create ${props.webgl2 && !props.webgl1 ? 'WebGL2' : 'WebGL'} context: ${\n        errorMessage || 'Unknown error'\n      }`\n    );\n  }\n\n  if (props.onContextLost) {\n    // Carefully extract and wrap callbacks to prevent addEventListener from rebinding them.\n    const {onContextLost} = props;\n    canvas.addEventListener('webglcontextlost', (event: Event) => onContextLost(event), false);\n  }\n  if (props.onContextRestored) {\n    // Carefully extract and wrap callbacks to prevent addEventListener from rebinding them.\n    const {onContextRestored} = props;\n    canvas.addEventListener(\n      'webglcontextrestored',\n      (event: Event) => onContextRestored(event),\n      false\n    );\n  }\n\n  return gl;\n}\n\n/* TODO - can we call this asynchronously to catch the error events?\nexport async function createBrowserContextAsync(canvas: HTMLCanvasElement | OffscreenCanvas, props: ContextProps): Promise<WebGLRenderingContext> {\n  props = {...DEFAULT_CONTEXT_PROPS, ...props};\n\n // Try to extract any extra information about why context creation failed\n let errorMessage = null;\n const onCreateError = (error) => (errorMessage = error.statusMessage || errorMessage);\n canvas.addEventListener('webglcontextcreationerror', onCreateError, false);\n\n const gl = createBrowserContext(canvas, props);\n\n // Give the listener a chance to fire\n await new Promise(resolve => setTimeout(resolve, 0));\n\n canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);\n\n return gl;\n}\n*/\n"],"mappings":"AAoCA,MAAMA,qBAAmC,GAAG;EAC1CC,MAAM,EAAE,IAAI;EACZC,MAAM,EAAE,IAAI;EACZC,eAAe,EAAE,kBAAkB;EAEnCC,aAAa,EAAEA,CAAA,KAAMC,OAAO,CAACC,KAAK,CAAC,oBAAoB,CAAC;EAExDC,iBAAiB,EAAEA,CAAA,KAAMF,OAAO,CAACG,IAAI,CAAC,wBAAwB;AAChE,CAAC;AAOD,OAAO,SAASC,oBAAoBA,CAClCC,MAA2C,EAC3CC,KAAmB,EACI;EACvBA,KAAK,GAAG;IAAC,GAAGX,qBAAqB;IAAE,GAAGW;EAAK,CAAC;EAG5C,IAAIC,YAAY,GAAG,IAAI;EACvB,MAAMC,aAAa,GAAGP,KAAK,IAAKM,YAAY,GAAGN,KAAK,CAACQ,aAAa,IAAIF,YAAa;EACnFF,MAAM,CAACK,gBAAgB,CAAC,2BAA2B,EAAEF,aAAa,EAAE,KAAK,CAAC;EAG1E,IAAIG,EAAyD,GAAG,IAAI;EAEpE,IAAIL,KAAK,CAACM,IAAI,KAAK,QAAQ,EAAE;IAC3BN,KAAK,GAAG;MAAC,GAAGA,KAAK;MAAET,MAAM,EAAE;IAAK,CAAC;EACnC;EACA,IAAIS,KAAK,CAACM,IAAI,KAAK,QAAQ,EAAE;IAC3BN,KAAK,GAAG;MAAC,GAAGA,KAAK;MAAEV,MAAM,EAAE;IAAK,CAAC;EACnC;EAKA,IAAI,CAACe,EAAE,IAAIL,KAAK,CAACV,MAAM,EAAE;IACvBe,EAAE,GAAGN,MAAM,CAACQ,UAAU,CAAC,QAAQ,EAAEP,KAAK,CAA2B;EACnE;EACA,IAAI,CAACK,EAAE,IAAIL,KAAK,CAACT,MAAM,EAAE;IACvBc,EAAE,GAAGN,MAAM,CAACQ,UAAU,CAAC,OAAO,EAAEP,KAAK,CAA0B;EACjE;EAaAD,MAAM,CAACS,mBAAmB,CAAC,2BAA2B,EAAEN,aAAa,EAAE,KAAK,CAAC;EAE7E,IAAI,CAACG,EAAE,EAAE;IACP,MAAM,IAAII,KAAK,CACZ,oBAAmBT,KAAK,CAACV,MAAM,IAAI,CAACU,KAAK,CAACT,MAAM,GAAG,QAAQ,GAAG,OAAQ,aACrEU,YAAY,IAAI,eACjB,EACH,CAAC;EACH;EAEA,IAAID,KAAK,CAACP,aAAa,EAAE;IAEvB,MAAM;MAACA;IAAa,CAAC,GAAGO,KAAK;IAC7BD,MAAM,CAACK,gBAAgB,CAAC,kBAAkB,EAAGM,KAAY,IAAKjB,aAAa,CAACiB,KAAK,CAAC,EAAE,KAAK,CAAC;EAC5F;EACA,IAAIV,KAAK,CAACJ,iBAAiB,EAAE;IAE3B,MAAM;MAACA;IAAiB,CAAC,GAAGI,KAAK;IACjCD,MAAM,CAACK,gBAAgB,CACrB,sBAAsB,EACrBM,KAAY,IAAKd,iBAAiB,CAACc,KAAK,CAAC,EAC1C,KACF,CAAC;EACH;EAEA,OAAOL,EAAE;AACX"}