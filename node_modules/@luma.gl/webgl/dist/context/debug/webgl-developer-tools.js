import { log, loadScript } from '@luma.gl/core';
import { GL as GLEnum } from '@luma.gl/constants';
import { isBrowser } from '@probe.gl/env';
const WEBGL_DEBUG_CDN_URL = 'https://unpkg.com/webgl-debug@2.0.1/index.js';
function getContextData(gl) {
  gl.luma = gl.luma || {};
  return gl.luma;
}
export async function loadWebGLDeveloperTools() {
  if (isBrowser() && !globalThis.WebGLDebugUtils) {
    globalThis.global = globalThis.global || globalThis;
    globalThis.global.module = {};
    await loadScript(WEBGL_DEBUG_CDN_URL);
  }
}
export function makeDebugContext(gl) {
  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!gl) {
    return null;
  }
  return props.debug ? getDebugContext(gl, props) : getRealContext(gl);
}
function getRealContext(gl) {
  const data = getContextData(gl);
  return data.realContext ? data.realContext : gl;
}
function getDebugContext(gl, props) {
  if (!globalThis.WebGLDebugUtils) {
    log.warn('webgl-debug not loaded')();
    return gl;
  }
  const data = getContextData(gl);
  if (data.debugContext) {
    return data.debugContext;
  }
  globalThis.WebGLDebugUtils.init({
    ...GLEnum,
    ...gl
  });
  const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
  for (const key in GLEnum) {
    if (!(key in glDebug) && typeof GLEnum[key] === 'number') {
      glDebug[key] = GLEnum[key];
    }
  }
  class WebGLDebugContext {}
  Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
  Object.setPrototypeOf(WebGLDebugContext, glDebug);
  const debugContext = Object.create(WebGLDebugContext);
  data.realContext = gl;
  data.debugContext = debugContext;
  debugContext.debug = true;
  return debugContext;
}
function getFunctionString(functionName, functionArgs) {
  functionArgs = Array.from(functionArgs).map(arg => arg === undefined ? 'undefined' : arg);
  let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
  args = `${args.slice(0, 100)}${args.length > 100 ? '...' : ''}`;
  return `gl.${functionName}(${args})`;
}
function onGLError(props, err, functionName, args) {
  args = Array.from(args).map(arg => arg === undefined ? 'undefined' : arg);
  const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
  const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
  const glName = props.webgl2 ? 'gl2' : 'gl1';
  const message = `${errorMessage} in ${glName}.${functionName}(${functionArgs})`;
  log.error(message)();
  debugger;
  if (props.throwOnError) {
    throw new Error(message);
  }
}
function onValidateGLFunc(props, functionName, functionArgs) {
  let functionString = '';
  if (log.level >= 1) {
    functionString = getFunctionString(functionName, functionArgs);
    log.log(1, functionString)();
  }
  if (props.break && props.break.length > 0) {
    functionString = functionString || getFunctionString(functionName, functionArgs);
    const isBreakpoint = props.break.every(breakOn => functionString.indexOf(breakOn) !== -1);
    if (isBreakpoint) {
      debugger;
    }
  }
  for (const arg of functionArgs) {
    if (arg === undefined) {
      functionString = functionString || getFunctionString(functionName, functionArgs);
      if (props.throwOnError) {
        throw new Error(`Undefined argument: ${functionString}`);
      } else {
        log.error(`Undefined argument: ${functionString}`)();
        debugger;
      }
    }
  }
}
//# sourceMappingURL=webgl-developer-tools.js.map