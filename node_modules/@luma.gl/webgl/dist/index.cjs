var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Accessor: () => Accessor,
  WEBGLBuffer: () => WEBGLBuffer,
  WEBGLCommandEncoder: () => WEBGLCommandEncoder,
  WEBGLFramebuffer: () => WEBGLFramebuffer,
  WEBGLRenderPass: () => WEBGLRenderPass,
  WEBGLRenderPipeline: () => WEBGLRenderPipeline,
  WEBGLRenderbuffer: () => WEBGLRenderbuffer,
  WEBGLResource: () => WebGLResource,
  WEBGLSampler: () => WEBGLSampler,
  WEBGLShader: () => WEBGLShader,
  WEBGLTexture: () => WEBGLTexture,
  WEBGLTransformFeedback: () => WEBGLTransformFeedback,
  WEBGLVertexArray: () => WEBGLVertexArray,
  WebGLCanvasContext: () => WebGLCanvasContext,
  WebGLDevice: () => WebGLDevice,
  WebGLResource: () => WebGLResource,
  _TEXTURE_FORMATS: () => TEXTURE_FORMATS,
  _checkFloat32ColorAttachment: () => _checkFloat32ColorAttachment,
  assertWebGL2Context: () => assertWebGL2Context,
  assertWebGLContext: () => assertWebGLContext,
  convertGLToTextureFormat: () => convertGLToTextureFormat,
  getGLParameters: () => getGLParameters,
  getShaderLayout: () => getShaderLayout,
  getWebGL2Context: () => getWebGL2Context,
  isWebGL: () => isWebGL,
  isWebGL2: () => isWebGL2,
  polyfillContext: () => polyfillContext,
  popContextState: () => popContextState,
  pushContextState: () => pushContextState,
  registerHeadlessGL: () => registerHeadlessGL,
  resetGLParameters: () => resetGLParameters,
  setDeviceParameters: () => setDeviceParameters,
  setGLParameters: () => setGLParameters,
  trackContextState: () => trackContextState,
  withDeviceParameters: () => withDeviceParameters,
  withGLParameters: () => withGLParameters
});
module.exports = __toCommonJS(src_exports);

// src/context/context/create-headless-context.ts
var ERR_HEADLESSGL_FAILED = "Failed to create WebGL context in Node.js, headless gl returned null";
var ERR_HEADLESSGL_LOAD = "  luma.gl: loaded under Node.js without headless gl installed, meaning that WebGL   contexts can not be created. This may not be an error. For example, this is a   typical configuration for isorender applications running on the server.";
var CONTEXT_DEFAULTS = {
  width: 1,
  height: 1,
  debug: true,
  throwOnError: false
};
var headlessGL = null;
function registerHeadlessGL(headlessgl) {
  headlessGL = headlessgl;
}
function isHeadlessGLRegistered() {
  return headlessGL !== null;
}
function createHeadlessContext(options) {
  options = { ...CONTEXT_DEFAULTS, ...options };
  const { width, height, webgl1, webgl2 } = options;
  if (webgl2 && !webgl1) {
    throw new Error("headless-gl does not support WebGL2");
  }
  if (!headlessGL) {
    throw new Error(ERR_HEADLESSGL_LOAD);
  }
  const gl = headlessGL(width, height, options);
  if (!gl) {
    throw new Error(ERR_HEADLESSGL_FAILED);
  }
  return gl;
}

// src/adapter/webgl-device.ts
var import_core29 = require("@luma.gl/core");
var import_env3 = require("@probe.gl/env");

// src/context/polyfill/polyfill-context.ts
var import_core3 = require("@luma.gl/core");

// src/context/polyfill/polyfill-vertex-array-object.ts
var glErrorShadow = {};
function error(msg) {
  if (globalThis.console && globalThis.console.error) {
    globalThis.console.error(msg);
  }
}
function log(msg) {
  if (globalThis.console && globalThis.console.log) {
    globalThis.console.log(msg);
  }
}
function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;
  if (opt_msg !== void 0) {
    error(opt_msg);
  }
}
function wrapGLError(gl) {
  const f = gl.getError;
  gl.getError = function getError() {
    let err;
    do {
      err = f.apply(gl);
      if (err !== gl.NO_ERROR) {
        glErrorShadow[err] = true;
      }
    } while (err !== gl.NO_ERROR);
    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }
    return gl.NO_ERROR;
  };
}
var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
  const gl = ext.gl;
  this.ext = ext;
  this.isAlive = true;
  this.hasBeenBound = false;
  this.elementArrayBuffer = null;
  this.attribs = new Array(ext.maxVertexAttribs);
  for (let n = 0; n < this.attribs.length; n++) {
    const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
    this.attribs[n] = attrib;
  }
  this.maxAttrib = 0;
};
WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
  this.enabled = false;
  this.buffer = null;
  this.size = 4;
  this.type = gl.FLOAT;
  this.normalized = false;
  this.stride = 16;
  this.offset = 0;
  this.cached = "";
  this.recache();
};
WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
};
var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
  const self = this;
  this.gl = gl;
  wrapGLError(gl);
  const original = this.original = {
    getParameter: gl.getParameter,
    enableVertexAttribArray: gl.enableVertexAttribArray,
    disableVertexAttribArray: gl.disableVertexAttribArray,
    bindBuffer: gl.bindBuffer,
    getVertexAttrib: gl.getVertexAttrib,
    vertexAttribPointer: gl.vertexAttribPointer
  };
  gl.getParameter = function getParameter(pname) {
    if (pname === self.VERTEX_ARRAY_BINDING_OES) {
      if (self.currentVertexArrayObject === self.defaultVertexArrayObject) {
        return null;
      }
      return self.currentVertexArrayObject;
    }
    return original.getParameter.apply(this, arguments);
  };
  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = true;
    return original.enableVertexAttribArray.apply(this, arguments);
  };
  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = false;
    return original.disableVertexAttribArray.apply(this, arguments);
  };
  gl.bindBuffer = function bindBuffer2(target, buffer) {
    switch (target) {
      case gl.ARRAY_BUFFER:
        self.currentArrayBuffer = buffer;
        break;
      case gl.ELEMENT_ARRAY_BUFFER:
        self.currentVertexArrayObject.elementArrayBuffer = buffer;
        break;
      default:
    }
    return original.bindBuffer.apply(this, arguments);
  };
  gl.getVertexAttrib = function getVertexAttrib(index, pname) {
    const vao = self.currentVertexArrayObject;
    const attrib = vao.attribs[index];
    switch (pname) {
      case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
        return attrib.buffer;
      case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
        return attrib.enabled;
      case gl.VERTEX_ATTRIB_ARRAY_SIZE:
        return attrib.size;
      case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
        return attrib.stride;
      case gl.VERTEX_ATTRIB_ARRAY_TYPE:
        return attrib.type;
      case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
        return attrib.normalized;
      default:
        return original.getVertexAttrib.apply(this, arguments);
    }
  };
  gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
    const attrib = vao.attribs[indx];
    attrib.buffer = self.currentArrayBuffer;
    attrib.size = size;
    attrib.type = type;
    attrib.normalized = normalized;
    attrib.stride = stride;
    attrib.offset = offset;
    attrib.recache();
    return original.vertexAttribPointer.apply(this, arguments);
  };
  if (gl.instrumentExtension) {
    gl.instrumentExtension(this, "OES_vertex_array_object");
  }
  if (gl.canvas) {
    gl.canvas.addEventListener(
      "webglcontextrestored",
      () => {
        log("OESVertexArrayObject emulation library context restored");
        self.reset_();
      },
      true
    );
  }
  this.reset_();
};
OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
OESVertexArrayObject.prototype.reset_ = function reset_() {
  const contextWasLost = this.vertexArrayObjects !== void 0;
  if (contextWasLost) {
    for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
      this.vertexArrayObjects.isAlive = false;
    }
  }
  const gl = this.gl;
  this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
  this.currentVertexArrayObject = null;
  this.currentArrayBuffer = null;
  this.vertexArrayObjects = [this.defaultVertexArrayObject];
  this.bindVertexArrayOES(null);
};
OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
  const arrayObject = new WebGLVertexArrayObjectOES(this);
  this.vertexArrayObjects.push(arrayObject);
  return arrayObject;
};
OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
  arrayObject.isAlive = false;
  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
  if (this.currentVertexArrayObject === arrayObject) {
    this.bindVertexArrayOES(null);
  }
};
OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
    if (arrayObject.hasBeenBound && arrayObject.ext === this) {
      return true;
    }
  }
  return false;
};
OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
  const gl = this.gl;
  if (arrayObject && !arrayObject.isAlive) {
    synthesizeGLError(
      gl.INVALID_OPERATION,
      "bindVertexArrayOES: attempt to bind deleted arrayObject"
    );
    return;
  }
  const original = this.original;
  const oldVAO = this.currentVertexArrayObject;
  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
  this.currentVertexArrayObject.hasBeenBound = true;
  const newVAO = this.currentVertexArrayObject;
  if (oldVAO === newVAO) {
    return;
  }
  if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
    original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
  }
  let currentBinding = this.currentArrayBuffer;
  const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
  for (let n = 0; n <= maxAttrib; n++) {
    const attrib = newVAO.attribs[n];
    const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
    if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
      if (attrib.enabled) {
        original.enableVertexAttribArray.call(gl, n);
      } else {
        original.disableVertexAttribArray.call(gl, n);
      }
    }
    if (attrib.enabled) {
      let bufferChanged = false;
      if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
        if (currentBinding !== attrib.buffer) {
          original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
          currentBinding = attrib.buffer;
        }
        bufferChanged = true;
      }
      if (bufferChanged || attrib.cached !== oldAttrib.cached) {
        original.vertexAttribPointer.call(
          gl,
          n,
          attrib.size,
          attrib.type,
          attrib.normalized,
          attrib.stride,
          attrib.offset
        );
      }
    }
  }
  if (this.currentArrayBuffer !== currentBinding) {
    original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
  }
};
function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === "function") {
    return;
  }
  const original_getSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];
    if (list.indexOf("OES_vertex_array_object") < 0) {
      list.push("OES_vertex_array_object");
    }
    return list;
  };
  const original_getExtension = gl.getExtension;
  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);
    if (ext) {
      return ext;
    }
    if (name !== "OES_vertex_array_object") {
      return null;
    }
    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }
    return this.__OESVertexArrayObject;
  };
}

// src/context/polyfill/polyfill-table.ts
var import_core2 = require("@luma.gl/core");
var import_constants2 = require("@luma.gl/constants");

// src/context/context/webgl-checks.ts
var import_core = require("@luma.gl/core");
var ERR_CONTEXT = "Invalid WebGLRenderingContext";
var ERR_WEBGL2 = "Requires WebGL2";
function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}
function assertWebGLContext(gl) {
  (0, import_core.assert)(isWebGL(gl), ERR_CONTEXT);
  return gl;
}
function assertWebGL2Context(gl) {
  (0, import_core.assert)(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}

// src/context/polyfill/get-parameter-polyfill.ts
var import_constants = require("@luma.gl/constants");
var OES_element_index = "OES_element_index";
var WEBGL_draw_buffers = "WEBGL_draw_buffers";
var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
var GL_DONT_CARE = 4352;
var GL_GPU_DISJOINT_EXT = 36795;
var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
var GL_UNMASKED_VENDOR_WEBGL = 37445;
var GL_UNMASKED_RENDERER_WEBGL = 37446;
var getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
var WEBGL_PARAMETERS = {
  [import_constants.GL.READ_BUFFER]: (gl) => !isWebGL2(gl) ? import_constants.GL.COLOR_ATTACHMENT0 : void 0,
  // WebGL2 context parameters
  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
  [import_constants.GL.RASTERIZER_DISCARD]: getWebGL2ValueOrZero,
  [import_constants.GL.SAMPLES]: getWebGL2ValueOrZero,
  // WebGL2 extension context parameters
  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
    const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  },
  // Extension fixed values
  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || import_constants.GL.VENDOR);
  },
  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || import_constants.GL.RENDERER);
  },
  // Extension LIMITS
  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
    var _a, _b;
    const ext = ((_b = (_a = gl.luma) == null ? void 0 : _a.extensions) == null ? void 0 : _b[EXT_texture_filter_anisotropic]) || gl.getExtension("EXT_texture_filter_anisotropic");
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
  },
  // WebGL2 Limits
  [import_constants.GL.MAX_3D_TEXTURE_SIZE]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_ARRAY_TEXTURE_LAYERS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_CLIENT_WAIT_TIMEOUT_WEBGL]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_COLOR_ATTACHMENTS]: (gl, getParameter) => {
    if (!isWebGL2(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
    return void 0;
  },
  [import_constants.GL.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_COMBINED_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_DRAW_BUFFERS]: (gl) => {
    if (!isWebGL2(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
    return void 0;
  },
  [import_constants.GL.MAX_ELEMENT_INDEX]: (
    // Guess: per webglstats.com 99.6% of webgl2 supports 2147483647
    (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535
  ),
  [import_constants.GL.MAX_ELEMENTS_INDICES]: (
    // Guess: "Reasonably safe" per webglstats.com - could be higher/lower (on some mobile devices)
    (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535
  ),
  [import_constants.GL.MAX_ELEMENTS_VERTICES]: (
    // Guess: "Reasonably safe" per webglstats.com - could be higher/lower (on some mobile devices)
    (gl) => 16777216
  ),
  [import_constants.GL.MAX_FRAGMENT_INPUT_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_FRAGMENT_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_FRAGMENT_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_SAMPLES]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_SERVER_WAIT_TIMEOUT]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_TEXTURE_LOD_BIAS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_UNIFORM_BLOCK_SIZE]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_UNIFORM_BUFFER_BINDINGS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_VARYING_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_VERTEX_OUTPUT_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_VERTEX_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_VERTEX_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [import_constants.GL.MIN_PROGRAM_TEXEL_OFFSET]: getWebGL2ValueOrZero,
  [import_constants.GL.MAX_PROGRAM_TEXEL_OFFSET]: getWebGL2ValueOrZero,
  [import_constants.GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT]: getWebGL2ValueOrZero
};
function getParameterPolyfill(gl, originalGetParameter, pname) {
  const limit = WEBGL_PARAMETERS[pname];
  const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== void 0 ? value : originalGetParameter(pname);
  return result;
}

// src/context/polyfill/context-data.ts
function getContextData(gl) {
  const luma = gl.luma;
  if (!luma) {
    const contextState = {
      _polyfilled: false,
      _extensions: {}
    };
    gl.luma = contextState;
  }
  return gl.luma;
}

// src/context/polyfill/polyfill-table.ts
var OES_vertex_array_object = "OES_vertex_array_object";
var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
function getExtensionData(gl, extension) {
  return {
    webgl2: isWebGL2(gl),
    ext: gl.getExtension(extension)
  };
}
var WEBGL2_CONTEXT_POLYFILLS = {
  // POLYFILL TABLE
  [OES_vertex_array_object]: {
    meta: { suffix: "OES" },
    // NEW METHODS
    createVertexArray: () => {
      (0, import_core2.assert)(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: () => {
    },
    bindVertexArray: () => {
    },
    isVertexArray: () => false
  },
  [ANGLE_instanced_arrays]: {
    meta: {
      suffix: "ANGLE"
      // constants: {
      //   VERTEX_ATTRIB_ARRAY_DIVISOR: 'VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE'
      // }
    },
    vertexAttribDivisor(location, divisor) {
      (0, import_core2.assert)(divisor === 0, "WebGL instanced rendering not supported");
    },
    drawElementsInstanced: () => {
    },
    drawArraysInstanced: () => {
    }
  },
  [WEBGL_draw_buffers2]: {
    meta: {
      suffix: "WEBGL"
    },
    drawBuffers: () => {
      (0, import_core2.assert)(false);
    }
  },
  [EXT_disjoint_timer_query2]: {
    meta: { suffix: "EXT" },
    // WebGL1: Polyfills the WebGL2 Query API
    createQuery: () => {
      (0, import_core2.assert)(false);
    },
    deleteQuery: () => {
      (0, import_core2.assert)(false);
    },
    beginQuery: () => {
      (0, import_core2.assert)(false);
    },
    endQuery: () => {
    },
    getQuery(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    // The WebGL1 extension uses getQueryObject rather then getQueryParameter
    getQueryParameter(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryObject: (handle, pname) => {
    }
  }
};
var WEBGL2_CONTEXT_OVERRIDES = {
  // Ensure readBuffer is a no-op
  readBuffer: (gl, originalFunc, attachment) => {
    if (isWebGL2(gl)) {
      originalFunc(attachment);
    } else {
    }
  },
  // Override for getVertexAttrib that returns sane values for non-WebGL1 constants
  getVertexAttrib: (gl, originalFunc, location, pname) => {
    const { webgl2, ext } = getExtensionData(gl, ANGLE_instanced_arrays);
    let result;
    switch (pname) {
      case import_constants2.GL.VERTEX_ATTRIB_ARRAY_INTEGER:
        result = !webgl2 ? false : void 0;
        break;
      case import_constants2.GL.VERTEX_ATTRIB_ARRAY_DIVISOR:
        result = !webgl2 && !ext ? 0 : void 0;
        break;
      default:
    }
    return result !== void 0 ? result : originalFunc(location, pname);
  },
  // Handle transform feedback and uniform block queries in WebGL1
  getProgramParameter: (gl, originalFunc, program, pname) => {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case import_constants2.GL.TRANSFORM_FEEDBACK_BUFFER_MODE:
          return import_constants2.GL.SEPARATE_ATTRIBS;
        case import_constants2.GL.TRANSFORM_FEEDBACK_VARYINGS:
          return 0;
        case import_constants2.GL.ACTIVE_UNIFORM_BLOCKS:
          return 0;
        default:
      }
    }
    return originalFunc(program, pname);
  },
  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case import_constants2.GL.SAMPLES:
          return new Int32Array([0]);
        default:
      }
    }
    const gl2 = gl;
    return gl2.getInternalformatParameter(target, format, pname);
  },
  getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case import_constants2.GL.TEXTURE_MAX_ANISOTROPY_EXT:
        const contextData = getContextData(gl);
        const { _extensions } = contextData;
        const ext = _extensions[EXT_texture_filter_anisotropic2];
        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || import_constants2.GL.TEXTURE_MAX_ANISOTROPY_EXT;
        break;
      default:
    }
    return originalFunc(target, pname);
  },
  getParameter: getParameterPolyfill,
  hint(gl, originalFunc, pname, value) {
    return originalFunc(pname, value);
  }
};

// src/context/polyfill/polyfill-context.ts
function polyfillContext(gl) {
  const contextState = getContextData(gl);
  if (!contextState._polyfilled) {
    polyfillVertexArrayObject(gl);
    initializeExtensions(gl);
    installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, { target: contextState, target2: gl });
    contextState._polyfilled = true;
  }
  return gl;
}
function initializeExtensions(gl) {
  const contextState = getContextData(gl);
  const EXTENSIONS = gl.getSupportedExtensions() || [];
  const IGNORE_EXTENSIONS = ["WEBGL_polygon_mode"];
  for (const extensionName of EXTENSIONS) {
    if (!IGNORE_EXTENSIONS.includes(extensionName)) {
      const extension = gl.getExtension(extensionName);
      contextState._extensions[extensionName] = extension;
    }
  }
}
function installPolyfills(gl, polyfills) {
  const contextState = getContextData(gl);
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== "overrides") {
      polyfillExtension(gl, { extension, target: contextState, target2: gl });
    }
  }
}
function polyfillExtension(gl, { extension, target, target2 }) {
  const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
  (0, import_core3.assert)(defaults);
  const { meta = {} } = defaults;
  const { suffix = "" } = meta;
  const ext = gl.getExtension(extension);
  for (const key of Object.keys(defaults)) {
    const extKey = `${key}${suffix}`;
    let polyfill = null;
    if (key === "meta") {
    } else if (typeof gl[key] === "function") {
    } else if (ext && typeof ext[extKey] === "function") {
      polyfill = (...args) => ext[extKey](...args);
    } else if (typeof defaults[key] === "function") {
      polyfill = defaults[key].bind(target);
    }
    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}
function installOverrides(gl, { target, target2 }) {
  Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
    if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
      };
      const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}

// src/context/state-tracker/track-context-state.ts
var import_core4 = require("@luma.gl/core");

// src/context/parameters/webgl-parameter-tables.ts
var import_constants3 = require("@luma.gl/constants");
var GL_PARAMETER_DEFAULTS = {
  [import_constants3.GL.BLEND]: false,
  [import_constants3.GL.BLEND_COLOR]: new Float32Array([0, 0, 0, 0]),
  [import_constants3.GL.BLEND_EQUATION_RGB]: import_constants3.GL.FUNC_ADD,
  [import_constants3.GL.BLEND_EQUATION_ALPHA]: import_constants3.GL.FUNC_ADD,
  [import_constants3.GL.BLEND_SRC_RGB]: import_constants3.GL.ONE,
  [import_constants3.GL.BLEND_DST_RGB]: import_constants3.GL.ZERO,
  [import_constants3.GL.BLEND_SRC_ALPHA]: import_constants3.GL.ONE,
  [import_constants3.GL.BLEND_DST_ALPHA]: import_constants3.GL.ZERO,
  [import_constants3.GL.COLOR_CLEAR_VALUE]: new Float32Array([0, 0, 0, 0]),
  // TBD
  [import_constants3.GL.COLOR_WRITEMASK]: [true, true, true, true],
  [import_constants3.GL.CULL_FACE]: false,
  [import_constants3.GL.CULL_FACE_MODE]: import_constants3.GL.BACK,
  [import_constants3.GL.DEPTH_TEST]: false,
  [import_constants3.GL.DEPTH_CLEAR_VALUE]: 1,
  [import_constants3.GL.DEPTH_FUNC]: import_constants3.GL.LESS,
  [import_constants3.GL.DEPTH_RANGE]: new Float32Array([0, 1]),
  // TBD
  [import_constants3.GL.DEPTH_WRITEMASK]: true,
  [import_constants3.GL.DITHER]: true,
  [import_constants3.GL.CURRENT_PROGRAM]: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [import_constants3.GL.FRAMEBUFFER_BINDING]: null,
  [import_constants3.GL.RENDERBUFFER_BINDING]: null,
  [import_constants3.GL.VERTEX_ARRAY_BINDING]: null,
  [import_constants3.GL.ARRAY_BUFFER_BINDING]: null,
  [import_constants3.GL.FRONT_FACE]: import_constants3.GL.CCW,
  [import_constants3.GL.GENERATE_MIPMAP_HINT]: import_constants3.GL.DONT_CARE,
  [import_constants3.GL.LINE_WIDTH]: 1,
  [import_constants3.GL.POLYGON_OFFSET_FILL]: false,
  [import_constants3.GL.POLYGON_OFFSET_FACTOR]: 0,
  [import_constants3.GL.POLYGON_OFFSET_UNITS]: 0,
  [import_constants3.GL.SAMPLE_ALPHA_TO_COVERAGE]: false,
  [import_constants3.GL.SAMPLE_COVERAGE]: false,
  [import_constants3.GL.SAMPLE_COVERAGE_VALUE]: 1,
  [import_constants3.GL.SAMPLE_COVERAGE_INVERT]: false,
  [import_constants3.GL.SCISSOR_TEST]: false,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  [import_constants3.GL.SCISSOR_BOX]: new Int32Array([0, 0, 1024, 1024]),
  [import_constants3.GL.STENCIL_TEST]: false,
  [import_constants3.GL.STENCIL_CLEAR_VALUE]: 0,
  [import_constants3.GL.STENCIL_WRITEMASK]: 4294967295,
  [import_constants3.GL.STENCIL_BACK_WRITEMASK]: 4294967295,
  [import_constants3.GL.STENCIL_FUNC]: import_constants3.GL.ALWAYS,
  [import_constants3.GL.STENCIL_REF]: 0,
  [import_constants3.GL.STENCIL_VALUE_MASK]: 4294967295,
  [import_constants3.GL.STENCIL_BACK_FUNC]: import_constants3.GL.ALWAYS,
  [import_constants3.GL.STENCIL_BACK_REF]: 0,
  [import_constants3.GL.STENCIL_BACK_VALUE_MASK]: 4294967295,
  [import_constants3.GL.STENCIL_FAIL]: import_constants3.GL.KEEP,
  [import_constants3.GL.STENCIL_PASS_DEPTH_FAIL]: import_constants3.GL.KEEP,
  [import_constants3.GL.STENCIL_PASS_DEPTH_PASS]: import_constants3.GL.KEEP,
  [import_constants3.GL.STENCIL_BACK_FAIL]: import_constants3.GL.KEEP,
  [import_constants3.GL.STENCIL_BACK_PASS_DEPTH_FAIL]: import_constants3.GL.KEEP,
  [import_constants3.GL.STENCIL_BACK_PASS_DEPTH_PASS]: import_constants3.GL.KEEP,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  [import_constants3.GL.VIEWPORT]: [0, 0, 1024, 1024],
  // WEBGL1 PIXEL PACK/UNPACK MODES
  [import_constants3.GL.PACK_ALIGNMENT]: 4,
  [import_constants3.GL.UNPACK_ALIGNMENT]: 4,
  [import_constants3.GL.UNPACK_FLIP_Y_WEBGL]: false,
  [import_constants3.GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL]: false,
  [import_constants3.GL.UNPACK_COLORSPACE_CONVERSION_WEBGL]: import_constants3.GL.BROWSER_DEFAULT_WEBGL,
  // WEBGL2 / EXTENSIONS
  // gl1: 'OES_standard_derivatives'
  [import_constants3.GL.TRANSFORM_FEEDBACK_BINDING]: null,
  [import_constants3.GL.COPY_READ_BUFFER_BINDING]: null,
  [import_constants3.GL.COPY_WRITE_BUFFER_BINDING]: null,
  [import_constants3.GL.PIXEL_PACK_BUFFER_BINDING]: null,
  [import_constants3.GL.PIXEL_UNPACK_BUFFER_BINDING]: null,
  [import_constants3.GL.FRAGMENT_SHADER_DERIVATIVE_HINT]: import_constants3.GL.DONT_CARE,
  [import_constants3.GL.READ_FRAMEBUFFER_BINDING]: null,
  [import_constants3.GL.RASTERIZER_DISCARD]: false,
  [import_constants3.GL.PACK_ROW_LENGTH]: 0,
  [import_constants3.GL.PACK_SKIP_PIXELS]: 0,
  [import_constants3.GL.PACK_SKIP_ROWS]: 0,
  [import_constants3.GL.UNPACK_ROW_LENGTH]: 0,
  [import_constants3.GL.UNPACK_IMAGE_HEIGHT]: 0,
  [import_constants3.GL.UNPACK_SKIP_PIXELS]: 0,
  [import_constants3.GL.UNPACK_SKIP_ROWS]: 0,
  [import_constants3.GL.UNPACK_SKIP_IMAGES]: 0
};
var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
var hint = (gl, value, key) => gl.hint(key, value);
var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
var bindFramebuffer = (gl, value, key) => {
  let target;
  if (key === import_constants3.GL.FRAMEBUFFER_BINDING) {
    target = isWebGL2(gl) ? import_constants3.GL.DRAW_FRAMEBUFFER : import_constants3.GL.FRAMEBUFFER;
  } else {
    target = import_constants3.GL.READ_FRAMEBUFFER;
  }
  return gl.bindFramebuffer(target, value);
};
var bindBuffer = (gl, value, key) => {
  const bindingMap = {
    [import_constants3.GL.ARRAY_BUFFER_BINDING]: import_constants3.GL.ARRAY_BUFFER,
    [import_constants3.GL.COPY_READ_BUFFER_BINDING]: import_constants3.GL.COPY_READ_BUFFER,
    [import_constants3.GL.COPY_WRITE_BUFFER_BINDING]: import_constants3.GL.COPY_WRITE_BUFFER,
    [import_constants3.GL.PIXEL_PACK_BUFFER_BINDING]: import_constants3.GL.PIXEL_PACK_BUFFER,
    [import_constants3.GL.PIXEL_UNPACK_BUFFER_BINDING]: import_constants3.GL.PIXEL_UNPACK_BUFFER
  };
  const glTarget = bindingMap[key];
  gl.bindBuffer(glTarget, value);
};
function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
}
var GL_PARAMETER_SETTERS = {
  [import_constants3.GL.BLEND]: enable,
  [import_constants3.GL.BLEND_COLOR]: (gl, value) => gl.blendColor(...value),
  [import_constants3.GL.BLEND_EQUATION_RGB]: "blendEquation",
  [import_constants3.GL.BLEND_EQUATION_ALPHA]: "blendEquation",
  [import_constants3.GL.BLEND_SRC_RGB]: "blendFunc",
  [import_constants3.GL.BLEND_DST_RGB]: "blendFunc",
  [import_constants3.GL.BLEND_SRC_ALPHA]: "blendFunc",
  [import_constants3.GL.BLEND_DST_ALPHA]: "blendFunc",
  [import_constants3.GL.COLOR_CLEAR_VALUE]: (gl, value) => gl.clearColor(...value),
  [import_constants3.GL.COLOR_WRITEMASK]: (gl, value) => gl.colorMask(...value),
  [import_constants3.GL.CULL_FACE]: enable,
  [import_constants3.GL.CULL_FACE_MODE]: (gl, value) => gl.cullFace(value),
  [import_constants3.GL.DEPTH_TEST]: enable,
  [import_constants3.GL.DEPTH_CLEAR_VALUE]: (gl, value) => gl.clearDepth(value),
  [import_constants3.GL.DEPTH_FUNC]: (gl, value) => gl.depthFunc(value),
  [import_constants3.GL.DEPTH_RANGE]: (gl, value) => gl.depthRange(...value),
  [import_constants3.GL.DEPTH_WRITEMASK]: (gl, value) => gl.depthMask(value),
  [import_constants3.GL.DITHER]: enable,
  [import_constants3.GL.FRAGMENT_SHADER_DERIVATIVE_HINT]: hint,
  [import_constants3.GL.CURRENT_PROGRAM]: (gl, value) => gl.useProgram(value),
  [import_constants3.GL.RENDERBUFFER_BINDING]: (gl, value) => gl.bindRenderbuffer(import_constants3.GL.RENDERBUFFER, value),
  [import_constants3.GL.TRANSFORM_FEEDBACK_BINDING]: (gl, value) => {
    var _a;
    return (_a = gl.bindTransformFeedback) == null ? void 0 : _a.call(gl, import_constants3.GL.TRANSFORM_FEEDBACK, value);
  },
  [import_constants3.GL.VERTEX_ARRAY_BINDING]: (gl, value) => gl.bindVertexArray(value),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [import_constants3.GL.FRAMEBUFFER_BINDING]: bindFramebuffer,
  [import_constants3.GL.READ_FRAMEBUFFER_BINDING]: bindFramebuffer,
  // Buffers
  [import_constants3.GL.ARRAY_BUFFER_BINDING]: bindBuffer,
  [import_constants3.GL.COPY_READ_BUFFER_BINDING]: bindBuffer,
  [import_constants3.GL.COPY_WRITE_BUFFER_BINDING]: bindBuffer,
  [import_constants3.GL.PIXEL_PACK_BUFFER_BINDING]: bindBuffer,
  [import_constants3.GL.PIXEL_UNPACK_BUFFER_BINDING]: bindBuffer,
  [import_constants3.GL.FRONT_FACE]: (gl, value) => gl.frontFace(value),
  [import_constants3.GL.GENERATE_MIPMAP_HINT]: hint,
  [import_constants3.GL.LINE_WIDTH]: (gl, value) => gl.lineWidth(value),
  [import_constants3.GL.POLYGON_OFFSET_FILL]: enable,
  [import_constants3.GL.POLYGON_OFFSET_FACTOR]: "polygonOffset",
  [import_constants3.GL.POLYGON_OFFSET_UNITS]: "polygonOffset",
  [import_constants3.GL.RASTERIZER_DISCARD]: enable,
  [import_constants3.GL.SAMPLE_ALPHA_TO_COVERAGE]: enable,
  [import_constants3.GL.SAMPLE_COVERAGE]: enable,
  [import_constants3.GL.SAMPLE_COVERAGE_VALUE]: "sampleCoverage",
  [import_constants3.GL.SAMPLE_COVERAGE_INVERT]: "sampleCoverage",
  [import_constants3.GL.SCISSOR_TEST]: enable,
  [import_constants3.GL.SCISSOR_BOX]: (gl, value) => gl.scissor(...value),
  [import_constants3.GL.STENCIL_TEST]: enable,
  [import_constants3.GL.STENCIL_CLEAR_VALUE]: (gl, value) => gl.clearStencil(value),
  [import_constants3.GL.STENCIL_WRITEMASK]: (gl, value) => gl.stencilMaskSeparate(import_constants3.GL.FRONT, value),
  [import_constants3.GL.STENCIL_BACK_WRITEMASK]: (gl, value) => gl.stencilMaskSeparate(import_constants3.GL.BACK, value),
  [import_constants3.GL.STENCIL_FUNC]: "stencilFuncFront",
  [import_constants3.GL.STENCIL_REF]: "stencilFuncFront",
  [import_constants3.GL.STENCIL_VALUE_MASK]: "stencilFuncFront",
  [import_constants3.GL.STENCIL_BACK_FUNC]: "stencilFuncBack",
  [import_constants3.GL.STENCIL_BACK_REF]: "stencilFuncBack",
  [import_constants3.GL.STENCIL_BACK_VALUE_MASK]: "stencilFuncBack",
  [import_constants3.GL.STENCIL_FAIL]: "stencilOpFront",
  [import_constants3.GL.STENCIL_PASS_DEPTH_FAIL]: "stencilOpFront",
  [import_constants3.GL.STENCIL_PASS_DEPTH_PASS]: "stencilOpFront",
  [import_constants3.GL.STENCIL_BACK_FAIL]: "stencilOpBack",
  [import_constants3.GL.STENCIL_BACK_PASS_DEPTH_FAIL]: "stencilOpBack",
  [import_constants3.GL.STENCIL_BACK_PASS_DEPTH_PASS]: "stencilOpBack",
  [import_constants3.GL.VIEWPORT]: (gl, value) => gl.viewport(...value),
  // WEBGL1 PIXEL PACK/UNPACK MODES
  [import_constants3.GL.PACK_ALIGNMENT]: pixelStorei,
  [import_constants3.GL.UNPACK_ALIGNMENT]: pixelStorei,
  [import_constants3.GL.UNPACK_FLIP_Y_WEBGL]: pixelStorei,
  [import_constants3.GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL]: pixelStorei,
  [import_constants3.GL.UNPACK_COLORSPACE_CONVERSION_WEBGL]: pixelStorei,
  // WEBGL2 PIXEL PACK/UNPACK MODES
  // RASTERIZER_DISCARD ...
  [import_constants3.GL.PACK_ROW_LENGTH]: pixelStorei,
  [import_constants3.GL.PACK_SKIP_PIXELS]: pixelStorei,
  [import_constants3.GL.PACK_SKIP_ROWS]: pixelStorei,
  [import_constants3.GL.UNPACK_ROW_LENGTH]: pixelStorei,
  [import_constants3.GL.UNPACK_IMAGE_HEIGHT]: pixelStorei,
  [import_constants3.GL.UNPACK_SKIP_PIXELS]: pixelStorei,
  [import_constants3.GL.UNPACK_SKIP_ROWS]: pixelStorei,
  [import_constants3.GL.UNPACK_SKIP_IMAGES]: pixelStorei,
  // Function-style setters
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(import_constants3.GL.FRAMEBUFFER, handle);
  },
  blend: (gl, value) => value ? gl.enable(import_constants3.GL.BLEND) : gl.disable(import_constants3.GL.BLEND),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    const separateModes = typeof args === "number" ? [args, args] : args;
    gl.blendEquationSeparate(...separateModes);
  },
  blendFunc: (gl, args) => {
    const separateFuncs = (args == null ? void 0 : args.length) === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...separateFuncs);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(import_constants3.GL.CULL_FACE) : gl.disable(import_constants3.GL.CULL_FACE),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(import_constants3.GL.DEPTH_TEST) : gl.disable(import_constants3.GL.DEPTH_TEST),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(import_constants3.GL.DITHER) : gl.disable(import_constants3.GL.DITHER),
  derivativeHint: (gl, value) => {
    gl.hint(import_constants3.GL.FRAGMENT_SHADER_DERIVATIVE_HINT, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(import_constants3.GL.GENERATE_MIPMAP_HINT, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(import_constants3.GL.POLYGON_OFFSET_FILL) : gl.disable(import_constants3.GL.POLYGON_OFFSET_FILL),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
  scissorTest: (gl, value) => value ? gl.enable(import_constants3.GL.SCISSOR_TEST) : gl.disable(import_constants3.GL.SCISSOR_TEST),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(import_constants3.GL.STENCIL_TEST) : gl.disable(import_constants3.GL.STENCIL_TEST),
  stencilMask: (gl, value) => {
    value = isArray(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(import_constants3.GL.FRONT, mask);
    gl.stencilMaskSeparate(import_constants3.GL.BACK, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(import_constants3.GL.FRONT, func, ref, mask);
    gl.stencilFuncSeparate(import_constants3.GL.BACK, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(import_constants3.GL.FRONT, sfail, dpfail, dppass);
    gl.stencilOpSeparate(import_constants3.GL.BACK, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};
function getValue(glEnum, values, cache) {
  return values[glEnum] !== void 0 ? values[glEnum] : cache[glEnum];
}
var GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache) => gl.blendEquationSeparate(
    getValue(import_constants3.GL.BLEND_EQUATION_RGB, values, cache),
    getValue(import_constants3.GL.BLEND_EQUATION_ALPHA, values, cache)
  ),
  blendFunc: (gl, values, cache) => gl.blendFuncSeparate(
    getValue(import_constants3.GL.BLEND_SRC_RGB, values, cache),
    getValue(import_constants3.GL.BLEND_DST_RGB, values, cache),
    getValue(import_constants3.GL.BLEND_SRC_ALPHA, values, cache),
    getValue(import_constants3.GL.BLEND_DST_ALPHA, values, cache)
  ),
  polygonOffset: (gl, values, cache) => gl.polygonOffset(
    getValue(import_constants3.GL.POLYGON_OFFSET_FACTOR, values, cache),
    getValue(import_constants3.GL.POLYGON_OFFSET_UNITS, values, cache)
  ),
  sampleCoverage: (gl, values, cache) => gl.sampleCoverage(
    getValue(import_constants3.GL.SAMPLE_COVERAGE_VALUE, values, cache),
    getValue(import_constants3.GL.SAMPLE_COVERAGE_INVERT, values, cache)
  ),
  stencilFuncFront: (gl, values, cache) => gl.stencilFuncSeparate(
    import_constants3.GL.FRONT,
    getValue(import_constants3.GL.STENCIL_FUNC, values, cache),
    getValue(import_constants3.GL.STENCIL_REF, values, cache),
    getValue(import_constants3.GL.STENCIL_VALUE_MASK, values, cache)
  ),
  stencilFuncBack: (gl, values, cache) => gl.stencilFuncSeparate(
    import_constants3.GL.BACK,
    getValue(import_constants3.GL.STENCIL_BACK_FUNC, values, cache),
    getValue(import_constants3.GL.STENCIL_BACK_REF, values, cache),
    getValue(import_constants3.GL.STENCIL_BACK_VALUE_MASK, values, cache)
  ),
  stencilOpFront: (gl, values, cache) => gl.stencilOpSeparate(
    import_constants3.GL.FRONT,
    getValue(import_constants3.GL.STENCIL_FAIL, values, cache),
    getValue(import_constants3.GL.STENCIL_PASS_DEPTH_FAIL, values, cache),
    getValue(import_constants3.GL.STENCIL_PASS_DEPTH_PASS, values, cache)
  ),
  stencilOpBack: (gl, values, cache) => gl.stencilOpSeparate(
    import_constants3.GL.BACK,
    getValue(import_constants3.GL.STENCIL_BACK_FAIL, values, cache),
    getValue(import_constants3.GL.STENCIL_BACK_PASS_DEPTH_FAIL, values, cache),
    getValue(import_constants3.GL.STENCIL_BACK_PASS_DEPTH_PASS, values, cache)
  )
};
var GL_HOOKED_SETTERS = {
  // GENERIC SETTERS
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, hint2) => update({
    [pname]: hint2
  }),
  // SPECIFIC SETTERS
  useProgram: (update, value) => update({
    [import_constants3.GL.CURRENT_PROGRAM]: value
  }),
  bindRenderbuffer: (update, target, value) => update({
    [import_constants3.GL.RENDERBUFFER_BINDING]: value
  }),
  bindTransformFeedback: (update, target, value) => update({
    [import_constants3.GL.TRANSFORM_FEEDBACK_BINDING]: value
  }),
  bindVertexArray: (update, value) => update({
    [import_constants3.GL.VERTEX_ARRAY_BINDING]: value
  }),
  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case import_constants3.GL.FRAMEBUFFER:
        return update({
          [import_constants3.GL.DRAW_FRAMEBUFFER_BINDING]: framebuffer,
          [import_constants3.GL.READ_FRAMEBUFFER_BINDING]: framebuffer
        });
      case import_constants3.GL.DRAW_FRAMEBUFFER:
        return update({ [import_constants3.GL.DRAW_FRAMEBUFFER_BINDING]: framebuffer });
      case import_constants3.GL.READ_FRAMEBUFFER:
        return update({ [import_constants3.GL.READ_FRAMEBUFFER_BINDING]: framebuffer });
      default:
        return null;
    }
  },
  bindBuffer: (update, target, buffer) => {
    const pname = {
      [import_constants3.GL.ARRAY_BUFFER]: [import_constants3.GL.ARRAY_BUFFER_BINDING],
      [import_constants3.GL.COPY_READ_BUFFER]: [import_constants3.GL.COPY_READ_BUFFER_BINDING],
      [import_constants3.GL.COPY_WRITE_BUFFER]: [import_constants3.GL.COPY_WRITE_BUFFER_BINDING],
      [import_constants3.GL.PIXEL_PACK_BUFFER]: [import_constants3.GL.PIXEL_PACK_BUFFER_BINDING],
      [import_constants3.GL.PIXEL_UNPACK_BUFFER]: [import_constants3.GL.PIXEL_UNPACK_BUFFER_BINDING]
    }[target];
    if (pname) {
      return update({ [pname]: buffer });
    }
    return { valueChanged: true };
  },
  blendColor: (update, r, g, b, a) => update({
    [import_constants3.GL.BLEND_COLOR]: new Float32Array([r, g, b, a])
  }),
  blendEquation: (update, mode) => update({
    [import_constants3.GL.BLEND_EQUATION_RGB]: mode,
    [import_constants3.GL.BLEND_EQUATION_ALPHA]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [import_constants3.GL.BLEND_EQUATION_RGB]: modeRGB,
    [import_constants3.GL.BLEND_EQUATION_ALPHA]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [import_constants3.GL.BLEND_SRC_RGB]: src,
    [import_constants3.GL.BLEND_DST_RGB]: dst,
    [import_constants3.GL.BLEND_SRC_ALPHA]: src,
    [import_constants3.GL.BLEND_DST_ALPHA]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [import_constants3.GL.BLEND_SRC_RGB]: srcRGB,
    [import_constants3.GL.BLEND_DST_RGB]: dstRGB,
    [import_constants3.GL.BLEND_SRC_ALPHA]: srcAlpha,
    [import_constants3.GL.BLEND_DST_ALPHA]: dstAlpha
  }),
  clearColor: (update, r, g, b, a) => update({
    [import_constants3.GL.COLOR_CLEAR_VALUE]: new Float32Array([r, g, b, a])
  }),
  clearDepth: (update, depth) => update({
    [import_constants3.GL.DEPTH_CLEAR_VALUE]: depth
  }),
  clearStencil: (update, s) => update({
    [import_constants3.GL.STENCIL_CLEAR_VALUE]: s
  }),
  colorMask: (update, r, g, b, a) => update({
    [import_constants3.GL.COLOR_WRITEMASK]: [r, g, b, a]
  }),
  cullFace: (update, mode) => update({
    [import_constants3.GL.CULL_FACE_MODE]: mode
  }),
  depthFunc: (update, func) => update({
    [import_constants3.GL.DEPTH_FUNC]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [import_constants3.GL.DEPTH_RANGE]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [import_constants3.GL.DEPTH_WRITEMASK]: mask
  }),
  frontFace: (update, face) => update({
    [import_constants3.GL.FRONT_FACE]: face
  }),
  lineWidth: (update, width) => update({
    [import_constants3.GL.LINE_WIDTH]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [import_constants3.GL.POLYGON_OFFSET_FACTOR]: factor,
    [import_constants3.GL.POLYGON_OFFSET_UNITS]: units
  }),
  sampleCoverage: (update, value, invert) => update({
    [import_constants3.GL.SAMPLE_COVERAGE_VALUE]: value,
    [import_constants3.GL.SAMPLE_COVERAGE_INVERT]: invert
  }),
  scissor: (update, x, y, width, height) => update({
    [import_constants3.GL.SCISSOR_BOX]: new Int32Array([x, y, width, height])
  }),
  stencilMask: (update, mask) => update({
    [import_constants3.GL.STENCIL_WRITEMASK]: mask,
    [import_constants3.GL.STENCIL_BACK_WRITEMASK]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === import_constants3.GL.FRONT ? import_constants3.GL.STENCIL_WRITEMASK : import_constants3.GL.STENCIL_BACK_WRITEMASK]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [import_constants3.GL.STENCIL_FUNC]: func,
    [import_constants3.GL.STENCIL_REF]: ref,
    [import_constants3.GL.STENCIL_VALUE_MASK]: mask,
    [import_constants3.GL.STENCIL_BACK_FUNC]: func,
    [import_constants3.GL.STENCIL_BACK_REF]: ref,
    [import_constants3.GL.STENCIL_BACK_VALUE_MASK]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === import_constants3.GL.FRONT ? import_constants3.GL.STENCIL_FUNC : import_constants3.GL.STENCIL_BACK_FUNC]: func,
    [face === import_constants3.GL.FRONT ? import_constants3.GL.STENCIL_REF : import_constants3.GL.STENCIL_BACK_REF]: ref,
    [face === import_constants3.GL.FRONT ? import_constants3.GL.STENCIL_VALUE_MASK : import_constants3.GL.STENCIL_BACK_VALUE_MASK]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [import_constants3.GL.STENCIL_FAIL]: fail,
    [import_constants3.GL.STENCIL_PASS_DEPTH_FAIL]: zfail,
    [import_constants3.GL.STENCIL_PASS_DEPTH_PASS]: zpass,
    [import_constants3.GL.STENCIL_BACK_FAIL]: fail,
    [import_constants3.GL.STENCIL_BACK_PASS_DEPTH_FAIL]: zfail,
    [import_constants3.GL.STENCIL_BACK_PASS_DEPTH_PASS]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === import_constants3.GL.FRONT ? import_constants3.GL.STENCIL_FAIL : import_constants3.GL.STENCIL_BACK_FAIL]: fail,
    [face === import_constants3.GL.FRONT ? import_constants3.GL.STENCIL_PASS_DEPTH_FAIL : import_constants3.GL.STENCIL_BACK_PASS_DEPTH_FAIL]: zfail,
    [face === import_constants3.GL.FRONT ? import_constants3.GL.STENCIL_PASS_DEPTH_PASS : import_constants3.GL.STENCIL_BACK_PASS_DEPTH_PASS]: zpass
  }),
  viewport: (update, x, y, width, height) => update({
    [import_constants3.GL.VIEWPORT]: [x, y, width, height]
  })
};
var isEnabled = (gl, key) => gl.isEnabled(key);
var GL_PARAMETER_GETTERS = {
  [import_constants3.GL.BLEND]: isEnabled,
  [import_constants3.GL.CULL_FACE]: isEnabled,
  [import_constants3.GL.DEPTH_TEST]: isEnabled,
  [import_constants3.GL.DITHER]: isEnabled,
  [import_constants3.GL.POLYGON_OFFSET_FILL]: isEnabled,
  [import_constants3.GL.SAMPLE_ALPHA_TO_COVERAGE]: isEnabled,
  [import_constants3.GL.SAMPLE_COVERAGE]: isEnabled,
  [import_constants3.GL.SCISSOR_TEST]: isEnabled,
  [import_constants3.GL.STENCIL_TEST]: isEnabled,
  // WebGL 2
  [import_constants3.GL.RASTERIZER_DISCARD]: isEnabled
};
var NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([
  // setter not intercepted
  import_constants3.GL.ACTIVE_TEXTURE,
  import_constants3.GL.TRANSFORM_FEEDBACK_ACTIVE,
  import_constants3.GL.TRANSFORM_FEEDBACK_PAUSED,
  // setters bindBufferRange/bindBufferBase cannot be pruned based on cache
  import_constants3.GL.TRANSFORM_FEEDBACK_BUFFER_BINDING,
  import_constants3.GL.UNIFORM_BUFFER_BINDING,
  // states depending on VERTEX_ARRAY_BINDING
  import_constants3.GL.ELEMENT_ARRAY_BUFFER_BINDING,
  // states depending on READ_FRAMEBUFFER_BINDING
  import_constants3.GL.IMPLEMENTATION_COLOR_READ_FORMAT,
  import_constants3.GL.IMPLEMENTATION_COLOR_READ_TYPE,
  // states depending on FRAMEBUFFER_BINDING
  import_constants3.GL.READ_BUFFER,
  import_constants3.GL.DRAW_BUFFER0,
  import_constants3.GL.DRAW_BUFFER1,
  import_constants3.GL.DRAW_BUFFER2,
  import_constants3.GL.DRAW_BUFFER3,
  import_constants3.GL.DRAW_BUFFER4,
  import_constants3.GL.DRAW_BUFFER5,
  import_constants3.GL.DRAW_BUFFER6,
  import_constants3.GL.DRAW_BUFFER7,
  import_constants3.GL.DRAW_BUFFER8,
  import_constants3.GL.DRAW_BUFFER9,
  import_constants3.GL.DRAW_BUFFER10,
  import_constants3.GL.DRAW_BUFFER11,
  import_constants3.GL.DRAW_BUFFER12,
  import_constants3.GL.DRAW_BUFFER13,
  import_constants3.GL.DRAW_BUFFER14,
  import_constants3.GL.DRAW_BUFFER15,
  // states depending on ACTIVE_TEXTURE
  import_constants3.GL.SAMPLER_BINDING,
  import_constants3.GL.TEXTURE_BINDING_2D,
  import_constants3.GL.TEXTURE_BINDING_2D_ARRAY,
  import_constants3.GL.TEXTURE_BINDING_3D,
  import_constants3.GL.TEXTURE_BINDING_CUBE_MAP
]);

// src/context/parameters/unified-parameter-api.ts
function setGLParameters(device, parameters) {
  const webglDevice = WebGLDevice.attach(device);
  const gl = webglDevice.gl;
  if (isObjectEmpty(parameters)) {
    return;
  }
  const compositeSetters = {};
  for (const key in parameters) {
    const glConstant = Number(key);
    const setter = GL_PARAMETER_SETTERS[key];
    if (setter) {
      if (typeof setter === "string") {
        compositeSetters[setter] = true;
      } else {
        setter(gl, parameters[key], glConstant);
      }
    }
  }
  const cache = gl.state && gl.state.cache;
  if (cache) {
    for (const key in compositeSetters) {
      const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, parameters, cache);
    }
  }
}
function getGLParameters(device, parameters = GL_PARAMETER_DEFAULTS) {
  const webglDevice = WebGLDevice.attach(device);
  const gl = webglDevice.gl;
  if (typeof parameters === "number") {
    const key = parameters;
    const getter = GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetGLParameters(device) {
  setGLParameters(device, GL_PARAMETER_DEFAULTS);
}
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}

// src/context/state-tracker/deep-array-equal.ts
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// src/context/state-tracker/track-context-state.ts
var GLState = class {
  gl;
  program = null;
  stateStack = [];
  enable = true;
  cache;
  log;
  constructor(gl, {
    copyState = false,
    // Copy cache from params (slow) or initialize from WebGL defaults (fast)
    log: log9 = () => {
    }
    // Logging function, called when gl parameter change calls are actually issued
  } = {}) {
    this.gl = gl;
    this.cache = copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
    this.log = log9;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }
  push(values = {}) {
    this.stateStack.push({});
  }
  pop() {
    (0, import_core4.assert)(this.stateStack.length > 0);
    const oldValues = this.stateStack[this.stateStack.length - 1];
    setGLParameters(this.gl, oldValues);
    this.stateStack.pop();
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const key in values) {
      (0, import_core4.assert)(key !== void 0);
      const value = values[key];
      const cached = this.cache[key];
      if (!deepArrayEqual(value, cached)) {
        valueChanged = true;
        oldValue = cached;
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }
        this.cache[key] = value;
      }
    }
    return { valueChanged, oldValue };
  }
};
function getContextState(gl) {
  return gl.state;
}
function trackContextState(gl, options) {
  const { enable: enable2 = true, copyState } = options;
  (0, import_core4.assert)(copyState !== void 0);
  if (!gl.state) {
    gl.state = new GLState(gl, { copyState });
    installProgramSpy(gl);
    for (const key in GL_HOOKED_SETTERS) {
      const setter = GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, "getParameter");
    installGetterOverride(gl, "isEnabled");
  }
  const glState = getContextState(gl);
  glState.enable = enable2;
  return gl;
}
function pushContextState(gl) {
  let glState = getContextState(gl);
  if (!glState) {
    trackContextState(gl, { copyState: false });
    glState = getContextState(gl);
  }
  glState.push();
}
function popContextState(gl) {
  const glState = getContextState(gl);
  (0, import_core4.assert)(glState);
  glState.pop();
}
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get(pname) {
    if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
      return originalGetterFunc(pname);
    }
    const glState = getContextState(gl);
    if (!(pname in glState.cache)) {
      glState.cache[pname] = originalGetterFunc(pname);
    }
    return glState.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      glState.cache[pname]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGLRenderingContext
      originalGetterFunc(pname)
    );
  };
  Object.defineProperty(gl[functionName], "name", {
    value: `${functionName}-from-cache`,
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  if (!gl[functionName]) {
    return;
  }
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set(...params) {
    const glState = getContextState(gl);
    const { valueChanged, oldValue } = setter(glState._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], "name", {
    value: `${functionName}-to-cache`,
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    const glState = getContextState(gl);
    if (glState.program !== handle) {
      originalUseProgram(handle);
      glState.program = handle;
    }
  };
}

// src/context/context/create-browser-context.ts
var DEFAULT_CONTEXT_PROPS = {
  webgl2: true,
  // Attempt to create a WebGL2 context
  webgl1: true,
  // Attempt to create a WebGL1 context (false to fail if webgl2 not available)
  powerPreference: "high-performance",
  // After all, most apps are using WebGL for performance reasons
  // eslint-disable-next-line no-console
  onContextLost: () => console.error("WebGL context lost"),
  // eslint-disable-next-line no-console
  onContextRestored: () => console.info("WebGL context restored")
};
function createBrowserContext(canvas, props) {
  props = { ...DEFAULT_CONTEXT_PROPS, ...props };
  let errorMessage = null;
  const onCreateError = (error2) => errorMessage = error2.statusMessage || errorMessage;
  canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
  let gl = null;
  if (props.type === "webgl2") {
    props = { ...props, webgl1: false };
  }
  if (props.type === "webgl1") {
    props = { ...props, webgl2: false };
  }
  if (!gl && props.webgl2) {
    gl = canvas.getContext("webgl2", props);
  }
  if (!gl && props.webgl1) {
    gl = canvas.getContext("webgl", props);
  }
  canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
  if (!gl) {
    throw new Error(
      `Failed to create ${props.webgl2 && !props.webgl1 ? "WebGL2" : "WebGL"} context: ${errorMessage || "Unknown error"}`
    );
  }
  if (props.onContextLost) {
    const { onContextLost } = props;
    canvas.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
  }
  if (props.onContextRestored) {
    const { onContextRestored } = props;
    canvas.addEventListener(
      "webglcontextrestored",
      (event) => onContextRestored(event),
      false
    );
  }
  return gl;
}

// src/adapter/device-helpers/get-device-info.ts
var import_constants4 = require("@luma.gl/constants");
function getDeviceInfo(gl) {
  const vendorMasked = gl.getParameter(import_constants4.GL.VENDOR);
  const rendererMasked = gl.getParameter(import_constants4.GL.RENDERER);
  const ext = gl.getExtension("WEBGL_debug_renderer_info");
  const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : import_constants4.GL.VENDOR);
  const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : import_constants4.GL.RENDERER);
  const vendor = vendorUnmasked || vendorMasked;
  const renderer = rendererUnmasked || rendererMasked;
  const version = gl.getParameter(import_constants4.GL.VERSION);
  const gpu = identifyGPUVendor(vendor, renderer);
  const gpuBackend = identifyGPUBackend(vendor, renderer);
  const gpuType = identifyGPUType(vendor, renderer);
  const shadingLanguage = "glsl";
  const shadingLanguageVersion = isWebGL2(gl) ? 300 : 100;
  return {
    type: isWebGL2(gl) ? "webgl2" : "webgl",
    gpu,
    gpuType,
    gpuBackend,
    vendor,
    renderer,
    version,
    shadingLanguage,
    shadingLanguageVersion
  };
}
function identifyGPUVendor(vendor, renderer) {
  if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
    return "nvidia";
  }
  if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
    return "intel";
  }
  if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
    return "apple";
  }
  if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
    return "amd";
  }
  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
    return "software";
  }
  return "unknown";
}
function identifyGPUBackend(vendor, renderer) {
  if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
    return "metal";
  }
  if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
    return "opengl";
  }
  return "unknown";
}
function identifyGPUType(vendor, renderer) {
  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
    return "cpu";
  }
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  switch (gpuVendor) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}

// src/adapter/device-helpers/is-old-ie.ts
function isOldIE(opts = {}) {
  const navigator = typeof window !== "undefined" ? window.navigator || {} : {};
  const userAgent = opts.userAgent || navigator.userAgent || "";
  const isMSIE = userAgent.indexOf("MSIE ") !== -1;
  const isTrident = userAgent.indexOf("Trident/") !== -1;
  return isMSIE || isTrident;
}

// src/adapter/converters/texture-formats.ts
var import_core5 = require("@luma.gl/core");
var import_constants6 = require("@luma.gl/constants");

// src/adapter/converters/vertex-formats.ts
var import_constants5 = require("@luma.gl/constants");
function getGLFromVertexType(dataType) {
  switch (dataType) {
    case "uint8":
      return import_constants5.GL.UNSIGNED_BYTE;
    case "sint8":
      return import_constants5.GL.BYTE;
    case "unorm8":
      return import_constants5.GL.UNSIGNED_BYTE;
    case "snorm8":
      return import_constants5.GL.BYTE;
    case "uint16":
      return import_constants5.GL.UNSIGNED_SHORT;
    case "sint16":
      return import_constants5.GL.SHORT;
    case "unorm16":
      return import_constants5.GL.UNSIGNED_SHORT;
    case "snorm16":
      return import_constants5.GL.SHORT;
    case "uint32":
      return import_constants5.GL.UNSIGNED_INT;
    case "sint32":
      return import_constants5.GL.INT;
    case "float16":
      return import_constants5.GL.HALF_FLOAT;
    case "float32":
      return import_constants5.GL.FLOAT;
  }
  throw new Error(String(dataType));
}

// src/adapter/converters/texture-formats.ts
var texture_compression_bc = "texture-compression-bc";
var texture_compression_astc = "texture-compression-astc";
var texture_compression_etc2 = "texture-compression-etc2";
var texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
var texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
var texture_compression_atc_webgl = "texture-compression-atc-webgl";
var X_S3TC = "WEBGL_compressed_texture_s3tc";
var X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
var X_RGTC = "EXT_texture_compression_rgtc";
var X_BPTC = "EXT_texture_compression_bptc";
var X_ETC2 = "WEBGL_compressed_texture_etc";
var X_ASTC = "WEBGL_compressed_texture_astc";
var X_ETC1 = "WEBGL_compressed_texture_etc1";
var X_PVRTC = "WEBGL_compressed_texture_pvrtc";
var X_ATC = "WEBGL_compressed_texture_atc";
var EXT_SRGB = "EXT_sRGB";
var EXT_TEXTURE_NORM16 = "EXT_texture_norm16";
var EXT_FLOAT_WEBGL1 = "WEBGL_color_buffer_float";
var EXT_FLOAT_RENDER_WEBGL2 = "EXT_color_buffer_float";
var checkExtension = (gl, extension) => gl.getExtension(extension);
var checkExtensions = (gl, extensions) => extensions.every((extension) => gl.getExtension(extension));
var TEXTURE_FEATURE_CHECKS = {
  "texture-blend-float-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, "EXT_float_blend"),
  "texture-formats-srgb-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, EXT_SRGB),
  "texture-formats-depth-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, "WEBGL_depth_texture"),
  "texture-formats-float32-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, "OES_texture_float"),
  "texture-formats-float16-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, "OES_texture_half_float"),
  "texture-formats-norm16-webgl": (gl) => isWebGL2(gl) ? checkExtension(gl, EXT_TEXTURE_NORM16) : false,
  "texture-filter-linear-float32-webgl": (gl) => checkExtension(gl, "OES_texture_float_linear"),
  "texture-filter-linear-float16-webgl": (gl) => checkExtension(gl, "OES_texture_half_float_linear"),
  "texture-filter-anisotropic-webgl": (gl) => checkExtension(gl, "EXT_texture_filter_anisotropic"),
  "texture-renderable-float32-webgl": (gl) => checkExtension(gl, "EXT_color_buffer_float"),
  // [false, 'EXT_color_buffer_float'],
  "texture-renderable-float16-webgl": (gl) => checkExtension(gl, "EXT_color_buffer_half_float"),
  "texture-compression-bc": (gl) => checkExtensions(gl, [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC]),
  "texture-compression-bc5-webgl": (gl) => checkExtensions(gl, [X_RGTC]),
  // 'texture-compression-bc7-webgl': gl => checkExtensions(gl, [X_BPTC]),
  // 'texture-compression-bc3-srgb-webgl': gl => checkExtensions(gl, [X_S3TC_SRGB]),
  // 'texture-compression-bc3-webgl': gl => checkExtensions(gl, [X_S3TC]),
  "texture-compression-etc2": (gl) => checkExtensions(gl, [X_ETC2]),
  "texture-compression-astc": (gl) => checkExtensions(gl, [X_ASTC]),
  "texture-compression-etc1-webgl": (gl) => checkExtensions(gl, [X_ETC1]),
  "texture-compression-pvrtc-webgl": (gl) => checkExtensions(gl, [X_PVRTC]),
  "texture-compression-atc-webgl": (gl) => checkExtensions(gl, [X_ATC])
};
function checkTextureFeature(gl, feature) {
  var _a;
  return ((_a = TEXTURE_FEATURE_CHECKS[feature]) == null ? void 0 : _a.call(TEXTURE_FEATURE_CHECKS, gl)) || false;
}
function getTextureFeatures(gl) {
  const textureFeatures = Object.keys(TEXTURE_FEATURE_CHECKS);
  return textureFeatures.filter((feature) => checkTextureFeature(gl, feature));
}
var TEXTURE_FORMATS = {
  // Unsized formats that leave the precision up to the driver.
  // TODO - Fix bpp constants
  // 'r8unorm-unsized': {gl: GL.LUMINANCE, b: 4, c: 2, bpp: 4},
  "rgb8unorm-unsized": {
    gl: import_constants6.GL.RGB,
    gl1: import_constants6.GL.RGB,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: import_constants6.GL.RGB,
    types: [import_constants6.GL.UNSIGNED_BYTE, import_constants6.GL.UNSIGNED_SHORT_5_6_5]
  },
  "rgba8unorm-unsized": {
    gl: import_constants6.GL.RGBA,
    gl1: import_constants6.GL.RGBA,
    b: 4,
    c: 2,
    bpp: 4,
    dataFormat: import_constants6.GL.RGBA,
    types: [import_constants6.GL.UNSIGNED_BYTE, import_constants6.GL.UNSIGNED_SHORT_4_4_4_4, import_constants6.GL.UNSIGNED_SHORT_5_5_5_1]
  },
  // 'rgb8unorm-srgb-unsized': {gl: GL.SRGB_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 'rgba8unorm-srgb-unsized': {gl: GL.SRGB_ALPHA_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
  // 8-bit formats
  "r8unorm": { gl: import_constants6.GL.R8, b: 1, c: 1, renderbuffer: true },
  "r8snorm": { gl: import_constants6.GL.R8_SNORM, b: 1, c: 1 },
  "r8uint": { gl: import_constants6.GL.R8UI, b: 1, c: 1, renderbuffer: true },
  "r8sint": { gl: import_constants6.GL.R8I, b: 1, c: 1, renderbuffer: true },
  // 16-bit formats
  "rg8unorm": { gl: import_constants6.GL.RG8, b: 2, c: 2, renderbuffer: true },
  "rg8snorm": { gl: import_constants6.GL.RG8_SNORM, b: 2, c: 2 },
  "rg8uint": { gl: import_constants6.GL.RG8UI, b: 2, c: 2, renderbuffer: true },
  "rg8sint": { gl: import_constants6.GL.RG8I, b: 2, c: 2, renderbuffer: true },
  "r16uint": { gl: import_constants6.GL.R16UI, b: 2, c: 1, renderbuffer: true },
  "r16sint": { gl: import_constants6.GL.R16I, b: 2, c: 1, renderbuffer: true },
  "r16float": { gl: import_constants6.GL.R16F, b: 2, c: 1, render: "texture-renderable-float16-webgl", filter: "texture-filter-linear-float16-webgl", renderbuffer: true },
  "r16unorm-webgl": { gl: import_constants6.GL.R16_EXT, b: 2, c: 1, f: "texture-formats-norm16-webgl", renderbuffer: true, x: EXT_TEXTURE_NORM16 },
  "r16snorm-webgl": { gl: import_constants6.GL.R16_SNORM_EXT, b: 2, c: 1, f: "texture-formats-norm16-webgl", x: EXT_TEXTURE_NORM16 },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: import_constants6.GL.RGBA4, b: 2, c: 4, wgpu: false, renderbuffer: true },
  "rgb565unorm-webgl": { gl: import_constants6.GL.RGB565, b: 2, c: 4, wgpu: false, renderbuffer: true },
  "rgb5a1unorm-webgl": { gl: import_constants6.GL.RGB5_A1, b: 2, c: 4, wgpu: false, renderbuffer: true },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: import_constants6.GL.RGB8, b: 3, c: 3, wgpu: false },
  "rgb8snorm-webgl": { gl: import_constants6.GL.RGB8_SNORM, b: 3, c: 3, wgpu: false },
  // 32-bit formats  
  "rgba8unorm": { gl: import_constants6.GL.RGBA8, gl1: import_constants6.GL.RGBA, b: 4, c: 2, bpp: 4 },
  "rgba8unorm-srgb": { gl: import_constants6.GL.SRGB8_ALPHA8, gl1: import_constants6.GL.SRGB_ALPHA_EXT, b: 4, c: 4, gl1ext: EXT_SRGB, bpp: 4 },
  "rgba8snorm": { gl: import_constants6.GL.RGBA8_SNORM, b: 4, c: 4 },
  "rgba8uint": { gl: import_constants6.GL.RGBA8UI, b: 4, c: 4, bpp: 4 },
  "rgba8sint": { gl: import_constants6.GL.RGBA8I, b: 4, c: 4, bpp: 4 },
  // reverse colors, webgpu only
  "bgra8unorm": { b: 4, c: 4 },
  "bgra8unorm-srgb": { b: 4, c: 4 },
  "rg16uint": { gl: import_constants6.GL.RG16UI, b: 4, c: 1, bpp: 4 },
  "rg16sint": { gl: import_constants6.GL.RG16I, b: 4, c: 2, bpp: 4 },
  // When using a WebGL 2 context and the EXT_color_buffer_float WebGL2 extension
  "rg16float": { gl: import_constants6.GL.RG16F, bpp: 4, b: 4, c: 2, render: "texture-renderable-float16-webgl", filter: "texture-filter-linear-float16-webgl", renderbuffer: true },
  "rg16unorm-webgl": { gl: import_constants6.GL.RG16_EXT, b: 2, c: 2, f: "texture-formats-norm16-webgl", x: EXT_TEXTURE_NORM16 },
  "rg16snorm-webgl": { gl: import_constants6.GL.RG16_SNORM_EXT, b: 2, c: 2, f: "texture-formats-norm16-webgl", x: EXT_TEXTURE_NORM16 },
  "r32uint": { gl: import_constants6.GL.R32UI, b: 4, c: 1, bpp: 4, renderbuffer: true },
  "r32sint": { gl: import_constants6.GL.R32I, b: 4, c: 1, bpp: 4, renderbuffer: true },
  "r32float": { gl: import_constants6.GL.R32F, bpp: 4, b: 4, c: 1, render: "texture-renderable-float32-webgl", filter: "texture-filter-linear-float32-webgl" },
  // Packed 32-bit formats
  "rgb9e5ufloat": { gl: import_constants6.GL.RGB9_E5, b: 4, c: 3, p: 1, render: "texture-renderable-float16-webgl", filter: "texture-filter-linear-float16-webgl" },
  "rg11b10ufloat": { gl: import_constants6.GL.R11F_G11F_B10F, b: 4, c: 3, p: 1, render: "texture-renderable-float32-webgl", renderbuffer: true },
  "rgb10a2unorm": { gl: import_constants6.GL.RGB10_A2, b: 4, c: 4, p: 1, renderbuffer: true },
  // webgl2 only
  "rgb10a2unorm-webgl": { b: 4, c: 4, gl: import_constants6.GL.RGB10_A2UI, p: 1, wgpu: false, bpp: 4, renderbuffer: true },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: import_constants6.GL.RGB16_EXT, b: 2, c: 3, f: "texture-formats-norm16-webgl", x: EXT_TEXTURE_NORM16 },
  "rgb16snorm-webgl": { gl: import_constants6.GL.RGB16_SNORM_EXT, b: 2, c: 3, f: "texture-formats-norm16-webgl", x: EXT_TEXTURE_NORM16 },
  // 64-bit formats
  "rg32uint": { gl: import_constants6.GL.RG32UI, b: 8, c: 2, renderbuffer: true },
  "rg32sint": { gl: import_constants6.GL.RG32I, b: 8, c: 2, renderbuffer: true },
  "rg32float": { gl: import_constants6.GL.RG32F, b: 8, c: 2, render: "texture-renderable-float32-webgl", filter: "texture-filter-linear-float32-webgl", renderbuffer: true },
  "rgba16uint": { gl: import_constants6.GL.RGBA16UI, b: 8, c: 4, renderbuffer: true },
  "rgba16sint": { gl: import_constants6.GL.RGBA16I, b: 8, c: 4, renderbuffer: true },
  "rgba16float": { gl: import_constants6.GL.RGBA16F, gl1: import_constants6.GL.RGBA, b: 8, c: 4, render: "texture-renderable-float16-webgl", filter: "texture-filter-linear-float16-webgl" },
  "rgba16unorm-webgl": { gl: import_constants6.GL.RGBA16_EXT, b: 2, c: 4, f: "texture-formats-norm16-webgl", renderbuffer: true, x: EXT_TEXTURE_NORM16 },
  "rgba16snorm-webgl": { gl: import_constants6.GL.RGBA16_SNORM_EXT, b: 2, c: 4, f: "texture-formats-norm16-webgl", x: EXT_TEXTURE_NORM16 },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    gl: import_constants6.GL.RGB32F,
    gl1: import_constants6.GL.RGB,
    render: "texture-renderable-float32-webgl",
    filter: "texture-filter-linear-float32-webgl",
    gl2ext: EXT_FLOAT_RENDER_WEBGL2,
    gl1ext: EXT_FLOAT_WEBGL1,
    // WebGL1 render buffers are supported with GL.RGB32F
    dataFormat: import_constants6.GL.RGB,
    types: [import_constants6.GL.FLOAT]
  },
  // 128-bit formats
  "rgba32uint": { gl: import_constants6.GL.RGBA32UI, b: 16, c: 4, renderbuffer: true },
  "rgba32sint": { gl: import_constants6.GL.RGBA32I, b: 16, c: 4, renderbuffer: true },
  "rgba32float": { gl: import_constants6.GL.RGBA32F, b: 16, c: 4, render: "texture-renderable-float32-webgl", filter: "texture-filter-linear-float32-webgl", renderbuffer: true },
  // Depth and stencil formats
  "stencil8": { gl: import_constants6.GL.STENCIL_INDEX8, gl1: import_constants6.GL.STENCIL_INDEX8, b: 1, c: 1, attachment: import_constants6.GL.STENCIL_ATTACHMENT, renderbuffer: true },
  // 8 stencil bits
  "depth16unorm": { gl: import_constants6.GL.DEPTH_COMPONENT16, gl1: import_constants6.GL.DEPTH_COMPONENT16, b: 2, c: 1, attachment: import_constants6.GL.DEPTH_ATTACHMENT, renderbuffer: true },
  // 16 depth bits
  "depth24plus": { gl: import_constants6.GL.DEPTH_COMPONENT24, b: 3, c: 1, attachment: import_constants6.GL.DEPTH_ATTACHMENT },
  "depth32float": { gl: import_constants6.GL.DEPTH_COMPONENT32F, b: 4, c: 1, attachment: import_constants6.GL.DEPTH_ATTACHMENT, renderbuffer: true },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { gl: import_constants6.GL.DEPTH_STENCIL, gl1: import_constants6.GL.DEPTH_STENCIL, b: 4, c: 2, p: 1, attachment: import_constants6.GL.DEPTH_STENCIL_ATTACHMENT, renderbuffer: true, depthTexture: true },
  // "depth24unorm-stencil8" feature
  "depth24unorm-stencil8": { gl: import_constants6.GL.DEPTH24_STENCIL8, b: 4, c: 2, p: 1, attachment: import_constants6.GL.DEPTH_STENCIL_ATTACHMENT, renderbuffer: true },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { gl: import_constants6.GL.DEPTH32F_STENCIL8, b: 5, c: 2, p: 1, attachment: import_constants6.GL.DEPTH_STENCIL_ATTACHMENT, renderbuffer: true },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGB_S3TC_DXT1_EXT, x: X_S3TC, f: texture_compression_bc },
  "bc1-rgb-unorm-srgb-webgl": { gl: import_constants6.GL.COMPRESSED_SRGB_S3TC_DXT1_EXT, x: X_S3TC_SRGB, f: texture_compression_bc },
  "bc1-rgba-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_S3TC_DXT1_EXT, x: X_S3TC, f: texture_compression_bc },
  "bc1-rgba-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB_S3TC_DXT1_EXT, x: X_S3TC_SRGB, f: texture_compression_bc },
  "bc2-rgba-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_S3TC_DXT3_EXT, x: X_S3TC, f: texture_compression_bc },
  "bc2-rgba-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, x: X_S3TC_SRGB, f: texture_compression_bc },
  "bc3-rgba-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_S3TC_DXT5_EXT, x: X_S3TC, f: texture_compression_bc },
  "bc3-rgba-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, x: X_S3TC_SRGB, f: texture_compression_bc },
  "bc4-r-unorm": { gl: import_constants6.GL.COMPRESSED_RED_RGTC1_EXT, x: X_RGTC, f: texture_compression_bc },
  "bc4-r-snorm": { gl: import_constants6.GL.COMPRESSED_SIGNED_RED_RGTC1_EXT, x: X_RGTC, f: texture_compression_bc },
  "bc5-rg-unorm": { gl: import_constants6.GL.COMPRESSED_RED_GREEN_RGTC2_EXT, x: X_RGTC, f: texture_compression_bc },
  "bc5-rg-snorm": { gl: import_constants6.GL.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT, x: X_RGTC, f: texture_compression_bc },
  "bc6h-rgb-ufloat": { gl: import_constants6.GL.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, x: X_BPTC, f: texture_compression_bc },
  "bc6h-rgb-float": { gl: import_constants6.GL.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, x: X_BPTC, f: texture_compression_bc },
  "bc7-rgba-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_BPTC_UNORM_EXT, x: X_BPTC, f: texture_compression_bc },
  "bc7-rgba-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT, x: X_BPTC, f: texture_compression_bc },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: import_constants6.GL.COMPRESSED_RGB8_ETC2, f: texture_compression_etc2 },
  "etc2-rgb8unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ETC2, f: texture_compression_etc2 },
  "etc2-rgb8a1unorm": { gl: import_constants6.GL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, f: texture_compression_etc2 },
  "etc2-rgb8a1unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, f: texture_compression_etc2 },
  "etc2-rgba8unorm": { gl: import_constants6.GL.COMPRESSED_RGBA8_ETC2_EAC, f: texture_compression_etc2 },
  "etc2-rgba8unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, f: texture_compression_etc2 },
  "eac-r11unorm": { gl: import_constants6.GL.COMPRESSED_R11_EAC, f: texture_compression_etc2 },
  "eac-r11snorm": { gl: import_constants6.GL.COMPRESSED_SIGNED_R11_EAC, f: texture_compression_etc2 },
  "eac-rg11unorm": { gl: import_constants6.GL.COMPRESSED_RG11_EAC, f: texture_compression_etc2 },
  "eac-rg11snorm": { gl: import_constants6.GL.COMPRESSED_SIGNED_RG11_EAC, f: texture_compression_etc2 },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_4x4_KHR, f: texture_compression_astc },
  "astc-4x4-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, f: texture_compression_astc },
  "astc-5x4-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_5x4_KHR, f: texture_compression_astc },
  "astc-5x4-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, f: texture_compression_astc },
  "astc-5x5-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_5x5_KHR, f: texture_compression_astc },
  "astc-5x5-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, f: texture_compression_astc },
  "astc-6x5-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_6x5_KHR, f: texture_compression_astc },
  "astc-6x5-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, f: texture_compression_astc },
  "astc-6x6-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_6x6_KHR, f: texture_compression_astc },
  "astc-6x6-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, f: texture_compression_astc },
  "astc-8x5-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_8x5_KHR, f: texture_compression_astc },
  "astc-8x5-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, f: texture_compression_astc },
  "astc-8x6-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_8x6_KHR, f: texture_compression_astc },
  "astc-8x6-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, f: texture_compression_astc },
  "astc-8x8-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_8x8_KHR, f: texture_compression_astc },
  "astc-8x8-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, f: texture_compression_astc },
  "astc-10x5-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_10x10_KHR, f: texture_compression_astc },
  "astc-10x5-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, f: texture_compression_astc },
  "astc-10x6-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_10x6_KHR, f: texture_compression_astc },
  "astc-10x6-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, f: texture_compression_astc },
  "astc-10x8-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_10x8_KHR, f: texture_compression_astc },
  "astc-10x8-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, f: texture_compression_astc },
  "astc-10x10-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_10x10_KHR, f: texture_compression_astc },
  "astc-10x10-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, f: texture_compression_astc },
  "astc-12x10-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_12x10_KHR, f: texture_compression_astc },
  "astc-12x10-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, f: texture_compression_astc },
  "astc-12x12-unorm": { gl: import_constants6.GL.COMPRESSED_RGBA_ASTC_12x12_KHR, f: texture_compression_astc },
  "astc-12x12-unorm-srgb": { gl: import_constants6.GL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR, f: texture_compression_astc },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG, f: texture_compression_pvrtc_webgl },
  "pvrtc-rgba4unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, f: texture_compression_pvrtc_webgl },
  "pvrtc-rbg2unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG, f: texture_compression_pvrtc_webgl },
  "pvrtc-rgba2unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, f: texture_compression_pvrtc_webgl },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGB_ETC1_WEBGL, f: texture_compression_etc1_webgl },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGB_ATC_WEBGL, f: texture_compression_atc_webgl },
  "atc-rgba-unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL, f: texture_compression_atc_webgl },
  "atc-rgbai-unorm-webgl": { gl: import_constants6.GL.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL, f: texture_compression_atc_webgl }
};
var DATA_FORMAT_CHANNELS = {
  [import_constants6.GL.RED]: 1,
  [import_constants6.GL.RED_INTEGER]: 1,
  [import_constants6.GL.RG]: 2,
  [import_constants6.GL.RG_INTEGER]: 2,
  [import_constants6.GL.RGB]: 3,
  [import_constants6.GL.RGB_INTEGER]: 3,
  [import_constants6.GL.RGBA]: 4,
  [import_constants6.GL.RGBA_INTEGER]: 4,
  [import_constants6.GL.DEPTH_COMPONENT]: 1,
  [import_constants6.GL.DEPTH_STENCIL]: 1,
  [import_constants6.GL.ALPHA]: 1,
  [import_constants6.GL.LUMINANCE]: 1,
  [import_constants6.GL.LUMINANCE_ALPHA]: 2
};
var TYPE_SIZES = {
  [import_constants6.GL.FLOAT]: 4,
  [import_constants6.GL.UNSIGNED_INT]: 4,
  [import_constants6.GL.INT]: 4,
  [import_constants6.GL.UNSIGNED_SHORT]: 2,
  [import_constants6.GL.SHORT]: 2,
  [import_constants6.GL.HALF_FLOAT]: 2,
  [import_constants6.GL.BYTE]: 1,
  [import_constants6.GL.UNSIGNED_BYTE]: 1
};
function isTextureFormatSupported(gl, formatOrGL) {
  const format = convertGLToTextureFormat(formatOrGL);
  const info = TEXTURE_FORMATS[format];
  if (!info) {
    return false;
  }
  if (isWebGL2(gl) ? info.gl === void 0 : info.gl1 === void 0) {
    return false;
  }
  const extension = info.x || (isWebGL2(gl) ? info.gl2ext || info.gl1ext : info.gl1ext);
  if (extension) {
    return Boolean(gl.getExtension(extension));
  }
  return true;
}
function isRenderbufferFormatSupported(gl, format) {
  var _a;
  return isTextureFormatSupported(gl, format) && ((_a = TEXTURE_FORMATS[format]) == null ? void 0 : _a.renderbuffer);
}
function convertGLToTextureFormat(format) {
  if (typeof format === "string") {
    return format;
  }
  const entry = Object.entries(TEXTURE_FORMATS).find(
    ([, entry2]) => entry2.gl === format || entry2.gl1 === format
  );
  if (!entry) {
    throw new Error(`Unknown texture format ${format}`);
  }
  return entry[0];
}
function convertTextureFormatToGL(format, isWebGL23) {
  const formatInfo = TEXTURE_FORMATS[format];
  const webglFormat = isWebGL23 ? formatInfo == null ? void 0 : formatInfo.gl : formatInfo == null ? void 0 : formatInfo.gl1;
  if (webglFormat === void 0) {
    throw new Error(`Unsupported texture format ${format}`);
  }
  return webglFormat;
}
function isTextureFormatFilterable(gl, formatOrGL) {
  const format = convertGLToTextureFormat(formatOrGL);
  if (!isTextureFormatSupported(gl, format)) {
    return false;
  }
  try {
    const decoded = (0, import_core5.decodeTextureFormat)(format);
    if (decoded.signed) {
      return false;
    }
  } catch {
    return false;
  }
  if (format.endsWith("32float")) {
    return Boolean(gl.getExtension("OES_texture_float_linear"));
  }
  if (format.endsWith("16float")) {
    return Boolean(gl.getExtension("OES_texture_half_float_linear"));
  }
  return true;
}
function isTextureFormatRenderable(gl, formatOrGL) {
  const format = convertGLToTextureFormat(formatOrGL);
  if (!isTextureFormatSupported(gl, format)) {
    return false;
  }
  if (typeof format === "number") {
    return false;
  }
  return true;
}
function getWebGLTextureParameters(formatOrGL, isWebGL23) {
  const format = convertGLToTextureFormat(formatOrGL);
  const webglFormat = convertTextureFormatToGL(format, isWebGL23);
  const decoded = (0, import_core5.decodeTextureFormat)(format);
  return {
    format: webglFormat,
    dataFormat: getWebGLPixelDataFormat(
      decoded.format,
      decoded.integer,
      decoded.normalized,
      webglFormat
    ),
    // depth formats don't have a type
    type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : import_constants6.GL.UNSIGNED_BYTE,
    // @ts-expect-error
    compressed: decoded.compressed
  };
}
function getDepthStencilAttachmentWebGL(format) {
  const info = TEXTURE_FORMATS[format];
  if (!(info == null ? void 0 : info.attachment)) {
    throw new Error(`${format} is not a depth stencil format`);
  }
  return info.attachment;
}
function _checkFloat32ColorAttachment(gl, internalFormat = gl.RGBA, srcFormat = import_constants6.GL.RGBA, srcType = import_constants6.GL.UNSIGNED_BYTE) {
  let texture = null;
  let framebuffer = null;
  try {
    texture = gl.createTexture();
    gl.bindTexture(import_constants6.GL.TEXTURE_2D, texture);
    const level = 0;
    const width = 1;
    const height = 1;
    const border = 0;
    const pixel = new Uint8Array([0, 0, 255, 255]);
    gl.texImage2D(
      gl.TEXTURE_2D,
      level,
      internalFormat,
      width,
      height,
      border,
      srcFormat,
      srcType,
      pixel
    );
    framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(import_constants6.GL.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(import_constants6.GL.FRAMEBUFFER, import_constants6.GL.COLOR_ATTACHMENT0, import_constants6.GL.TEXTURE_2D, texture, 0);
    const status = gl.checkFramebufferStatus(import_constants6.GL.FRAMEBUFFER) === import_constants6.GL.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(import_constants6.GL.TEXTURE_2D, null);
    return status;
  } finally {
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(framebuffer);
  }
}
function getTextureFormatBytesPerPixel(formatOrGL, isWebGL23) {
  const format = convertGLToTextureFormat(formatOrGL);
  const params = getWebGLTextureParameters(format, isWebGL23);
  const channels = DATA_FORMAT_CHANNELS[params.dataFormat] || 4;
  const channelSize = TYPE_SIZES[params.type] || 1;
  return channels * channelSize;
}
function getWebGLPixelDataFormat(dataFormat, integer, normalized, format) {
  if (format === import_constants6.GL.RGBA || format === import_constants6.GL.RGB) {
    return format;
  }
  switch (dataFormat) {
    case "r":
      return integer && !normalized ? import_constants6.GL.RED_INTEGER : import_constants6.GL.RED;
    case "rg":
      return integer && !normalized ? import_constants6.GL.RG_INTEGER : import_constants6.GL.RG;
    case "rgb":
      return integer && !normalized ? import_constants6.GL.RGB_INTEGER : import_constants6.GL.RGB;
    case "rgba":
      return integer && !normalized ? import_constants6.GL.RGBA_INTEGER : import_constants6.GL.RGBA;
    default:
      return import_constants6.GL.RGBA;
  }
}

// src/adapter/device-helpers/device-features.ts
function getDeviceFeatures(gl) {
  const features = getWebGLFeatures(gl);
  for (const textureFeature of getTextureFeatures(gl)) {
    features.add(textureFeature);
  }
  return features;
}
function getWebGLFeatures(gl) {
  gl.getExtension("EXT_color_buffer_float");
  gl.getExtension("WEBGL_color_buffer_float");
  gl.getExtension("EXT_float_blend");
  const features = /* @__PURE__ */ new Set();
  for (const feature of Object.keys(WEBGL_FEATURES)) {
    if (isFeatureSupported(gl, feature)) {
      features.add(feature);
    }
  }
  return features;
}
function isFeatureSupported(gl, feature) {
  const featureInfo = WEBGL_FEATURES[feature];
  if (!featureInfo) {
    return false;
  }
  const [webgl1Feature, webgl2Feature] = featureInfo || [];
  const featureDefinition = isWebGL2(gl) ? webgl2Feature : webgl1Feature;
  if (typeof featureDefinition === "boolean") {
    return featureDefinition;
  }
  switch (feature) {
    case "texture-renderable-rgba32float-webgl":
      return isWebGL2(gl) ? Boolean(gl.getExtension(featureDefinition)) : _checkFloat32ColorAttachment(gl);
    case "glsl-derivatives":
      return canCompileGLSLExtension(gl, featureDefinition);
    case "glsl-frag-data":
      return canCompileGLSLExtension(gl, featureDefinition, { behavior: "require" });
    case "glsl-frag-depth":
      return canCompileGLSLExtension(gl, featureDefinition);
    default:
      return Boolean(gl.getExtension(featureDefinition));
  }
}
var compiledGLSLExtensions = {};
function canCompileGLSLExtension(gl, extensionName, opts = {}) {
  if (!isOldIE(opts)) {
    return true;
  }
  if (extensionName in compiledGLSLExtensions) {
    return compiledGLSLExtensions[extensionName];
  }
  const behavior = opts.behavior || "enable";
  const source = `#extension GL_${extensionName} : ${behavior}
void main(void) {}`;
  const shader = gl.createShader(gl.VERTEX_SHADER);
  if (!shader) {
    throw new Error("shader");
  }
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  gl.deleteShader(shader);
  compiledGLSLExtensions[extensionName] = canCompile;
  return canCompile;
}
var WEBGL_FEATURES = {
  "webgl": [true, true],
  "webgl2": [false, true],
  "timer-query-webgl": ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
  "transform-feedback-webgl2": [false, true],
  // WEBGL1 SUPPORT
  "vertex-array-object-webgl1": ["OES_vertex_array_object", true],
  "instanced-rendering-webgl1": ["ANGLE_instanced_arrays", true],
  "multiple-render-targets-webgl1": ["WEBGL_draw_buffers", true],
  "index-uint32-webgl1": ["OES_element_index_uint", true],
  "blend-minmax-webgl1": ["EXT_blend_minmax", true],
  "texture-blend-float-webgl1": ["EXT_float_blend", "EXT_float_blend"],
  // TEXTURES, RENDERBUFFERS
  "texture-formats-srgb-webgl1": ["EXT_sRGB", true],
  // TEXTURES
  "texture-formats-depth-webgl1": ["WEBGL_depth_texture", true],
  "texture-formats-float32-webgl1": ["OES_texture_float", true],
  "texture-formats-float16-webgl1": ["OES_texture_half_float", true],
  "texture-filter-linear-float32-webgl": ["OES_texture_float_linear", "OES_texture_float_linear"],
  "texture-filter-linear-float16-webgl": ["OES_texture_half_float_linear", "OES_texture_half_float_linear"],
  "texture-filter-anisotropic-webgl": ["EXT_texture_filter_anisotropic", "EXT_texture_filter_anisotropic"],
  // FRAMEBUFFERS, TEXTURES AND RENDERBUFFERS
  "texture-renderable-rgba32float-webgl": ["WEBGL_color_buffer_float", "EXT_color_buffer_float"],
  // Note override check
  "texture-renderable-float32-webgl": [false, "EXT_color_buffer_float"],
  "texture-renderable-float16-webgl": ["EXT_color_buffer_half_float", "EXT_color_buffer_half_float"],
  // GLSL extensions
  "glsl-frag-data": ["WEBGL_draw_buffers", true],
  "glsl-frag-depth": ["EXT_frag_depth", true],
  "glsl-derivatives": ["OES_standard_derivatives", true],
  "glsl-texture-lod": ["EXT_shader_texture_lod", true]
};

// src/adapter/device-helpers/device-limits.ts
var import_constants7 = require("@luma.gl/constants");
function getDeviceLimits(gl) {
  const gl2 = getWebGL2Context(gl);
  return {
    maxTextureDimension1D: 0,
    // WebGL does not support 1D textures
    maxTextureDimension2D: gl.getParameter(import_constants7.GL.MAX_TEXTURE_SIZE),
    maxTextureDimension3D: gl2 ? gl2.getParameter(import_constants7.GL.MAX_3D_TEXTURE_SIZE) : 0,
    maxTextureArrayLayers: gl2 ? gl2.getParameter(import_constants7.GL.MAX_ARRAY_TEXTURE_LAYERS) : 0,
    maxBindGroups: 1,
    // TBD
    maxDynamicUniformBuffersPerPipelineLayout: 0,
    // TBD
    maxDynamicStorageBuffersPerPipelineLayout: 0,
    // TBD
    maxSampledTexturesPerShaderStage: gl.getParameter(import_constants7.GL.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    // TBD
    maxSamplersPerShaderStage: gl.getParameter(import_constants7.GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxStorageBuffersPerShaderStage: 0,
    // TBD
    maxStorageTexturesPerShaderStage: 0,
    // TBD
    maxUniformBuffersPerShaderStage: gl2 ? gl2.getParameter(import_constants7.GL.MAX_UNIFORM_BUFFER_BINDINGS) : 0,
    maxUniformBufferBindingSize: gl2 ? gl2.getParameter(import_constants7.GL.MAX_UNIFORM_BLOCK_SIZE) : 0,
    maxStorageBufferBindingSize: 0,
    minUniformBufferOffsetAlignment: gl2 ? gl2.getParameter(import_constants7.GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT) : 0,
    minStorageBufferOffsetAlignment: 0,
    // TBD
    maxVertexBuffers: 0,
    maxVertexAttributes: gl.getParameter(import_constants7.GL.MAX_VERTEX_ATTRIBS),
    maxVertexBufferArrayStride: 2048,
    // TBD, this is just the default value from WebGPU
    maxInterStageShaderComponents: gl2 ? gl2.getParameter(import_constants7.GL.MAX_VARYING_COMPONENTS) : 0,
    maxComputeWorkgroupStorageSize: 0,
    // WebGL does not support compute shaders
    maxComputeInvocationsPerWorkgroup: 0,
    // WebGL does not support compute shaders
    maxComputeWorkgroupSizeX: 0,
    // WebGL does not support compute shaders
    maxComputeWorkgroupSizeY: 0,
    // WebGL does not support compute shaders
    maxComputeWorkgroupSizeZ: 0,
    // WebGL does not support compute shaders
    maxComputeWorkgroupsPerDimension: 0
    // WebGL does not support compute shaders
  };
}
function getWebGLLimits(gl) {
  const gl2 = getWebGL2Context(gl);
  function get(pname) {
    return gl.getParameter(pname);
  }
  function get2(pname, defaultValue) {
    return gl2 ? gl2.getParameter(pname) : defaultValue || 0;
  }
  return {
    [import_constants7.GL.ALIASED_LINE_WIDTH_RANGE]: get(import_constants7.GL.ALIASED_LINE_WIDTH_RANGE),
    [import_constants7.GL.ALIASED_POINT_SIZE_RANGE]: get(import_constants7.GL.ALIASED_POINT_SIZE_RANGE),
    [import_constants7.GL.MAX_TEXTURE_SIZE]: get(import_constants7.GL.MAX_TEXTURE_SIZE),
    [import_constants7.GL.MAX_CUBE_MAP_TEXTURE_SIZE]: get(import_constants7.GL.MAX_CUBE_MAP_TEXTURE_SIZE),
    // GLint
    [import_constants7.GL.MAX_TEXTURE_IMAGE_UNITS]: get(import_constants7.GL.MAX_TEXTURE_IMAGE_UNITS),
    // GLint
    [import_constants7.GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS]: get(import_constants7.GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    // GLint
    [import_constants7.GL.MAX_VERTEX_TEXTURE_IMAGE_UNITS]: get(import_constants7.GL.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    // GLint
    [import_constants7.GL.MAX_RENDERBUFFER_SIZE]: get(import_constants7.GL.MAX_RENDERBUFFER_SIZE),
    // GLint
    [import_constants7.GL.MAX_VARYING_VECTORS]: get(import_constants7.GL.MAX_VARYING_VECTORS),
    // GLint
    [import_constants7.GL.MAX_VERTEX_ATTRIBS]: get(import_constants7.GL.MAX_VERTEX_ATTRIBS),
    // GLint
    [import_constants7.GL.MAX_VERTEX_UNIFORM_VECTORS]: get(import_constants7.GL.MAX_VERTEX_UNIFORM_VECTORS),
    // GLint
    [import_constants7.GL.MAX_FRAGMENT_UNIFORM_VECTORS]: get(import_constants7.GL.MAX_FRAGMENT_UNIFORM_VECTORS),
    // GLint
    [import_constants7.GL.MAX_VIEWPORT_DIMS]: get(import_constants7.GL.MAX_VIEWPORT_DIMS),
    // Extensions
    [import_constants7.GL.MAX_TEXTURE_MAX_ANISOTROPY_EXT]: get(import_constants7.GL.MAX_TEXTURE_MAX_ANISOTROPY_EXT),
    // getMaxAnistropy(),
    // WebGL2 Limits
    [import_constants7.GL.MAX_3D_TEXTURE_SIZE]: get2(import_constants7.GL.MAX_3D_TEXTURE_SIZE),
    //  GLint
    [import_constants7.GL.MAX_ARRAY_TEXTURE_LAYERS]: get2(import_constants7.GL.MAX_ARRAY_TEXTURE_LAYERS),
    // GLint
    [import_constants7.GL.MAX_CLIENT_WAIT_TIMEOUT_WEBGL]: get2(import_constants7.GL.MAX_CLIENT_WAIT_TIMEOUT_WEBGL),
    //  GLint64
    [import_constants7.GL.MAX_COLOR_ATTACHMENTS]: get2(import_constants7.GL.MAX_COLOR_ATTACHMENTS),
    //  GLint
    [import_constants7.GL.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS]: get2(import_constants7.GL.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS),
    // GLint64
    [import_constants7.GL.MAX_COMBINED_UNIFORM_BLOCKS]: get2(import_constants7.GL.MAX_COMBINED_UNIFORM_BLOCKS),
    //  GLint
    [import_constants7.GL.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS]: get2(import_constants7.GL.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS),
    // GLint64
    [import_constants7.GL.MAX_DRAW_BUFFERS]: get2(import_constants7.GL.MAX_DRAW_BUFFERS),
    // GLint
    [import_constants7.GL.MAX_ELEMENT_INDEX]: get2(import_constants7.GL.MAX_ELEMENT_INDEX),
    //  GLint64
    [import_constants7.GL.MAX_ELEMENTS_INDICES]: get2(import_constants7.GL.MAX_ELEMENTS_INDICES),
    // GLint
    [import_constants7.GL.MAX_ELEMENTS_VERTICES]: get2(import_constants7.GL.MAX_ELEMENTS_VERTICES),
    //  GLint
    [import_constants7.GL.MAX_FRAGMENT_INPUT_COMPONENTS]: get2(import_constants7.GL.MAX_FRAGMENT_INPUT_COMPONENTS),
    //  GLint
    [import_constants7.GL.MAX_FRAGMENT_UNIFORM_BLOCKS]: get2(import_constants7.GL.MAX_FRAGMENT_UNIFORM_BLOCKS),
    //  GLint
    [import_constants7.GL.MAX_FRAGMENT_UNIFORM_COMPONENTS]: get2(import_constants7.GL.MAX_FRAGMENT_UNIFORM_COMPONENTS),
    //  GLint
    [import_constants7.GL.MAX_SAMPLES]: get2(import_constants7.GL.MAX_SAMPLES),
    //  GLint
    [import_constants7.GL.MAX_SERVER_WAIT_TIMEOUT]: get2(import_constants7.GL.MAX_SERVER_WAIT_TIMEOUT),
    //  GLint64
    [import_constants7.GL.MAX_TEXTURE_LOD_BIAS]: get2(import_constants7.GL.MAX_TEXTURE_LOD_BIAS),
    // GLfloat
    [import_constants7.GL.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS]: get2(import_constants7.GL.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS),
    //  GLint
    [import_constants7.GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS]: get2(import_constants7.GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS),
    //  GLint
    [import_constants7.GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS]: get2(import_constants7.GL.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS),
    // GLint
    [import_constants7.GL.MAX_UNIFORM_BLOCK_SIZE]: get2(import_constants7.GL.MAX_UNIFORM_BLOCK_SIZE),
    // GLint64
    [import_constants7.GL.MAX_UNIFORM_BUFFER_BINDINGS]: get2(import_constants7.GL.MAX_UNIFORM_BUFFER_BINDINGS),
    //  GLint
    [import_constants7.GL.MAX_VARYING_COMPONENTS]: get2(import_constants7.GL.MAX_VARYING_COMPONENTS),
    // GLint
    [import_constants7.GL.MAX_VERTEX_OUTPUT_COMPONENTS]: get2(import_constants7.GL.MAX_VERTEX_OUTPUT_COMPONENTS),
    // GLint
    [import_constants7.GL.MAX_VERTEX_UNIFORM_BLOCKS]: get2(import_constants7.GL.MAX_VERTEX_UNIFORM_BLOCKS),
    //  GLint
    [import_constants7.GL.MAX_VERTEX_UNIFORM_COMPONENTS]: get2(import_constants7.GL.MAX_VERTEX_UNIFORM_COMPONENTS),
    //  GLint
    [import_constants7.GL.MIN_PROGRAM_TEXEL_OFFSET]: get2(import_constants7.GL.MIN_PROGRAM_TEXEL_OFFSET),
    // GLint
    [import_constants7.GL.MAX_PROGRAM_TEXEL_OFFSET]: get2(import_constants7.GL.MAX_PROGRAM_TEXEL_OFFSET),
    // GLint
    [import_constants7.GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT]: get2(import_constants7.GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT)
    // GLint
  };
}

// src/adapter/webgl-canvas-context.ts
var import_core14 = require("@luma.gl/core");

// src/adapter/resources/webgl-framebuffer.ts
var import_core13 = require("@luma.gl/core");
var import_constants14 = require("@luma.gl/constants");

// src/adapter/resources/webgl-texture.ts
var import_core9 = require("@luma.gl/core");
var import_constants12 = require("@luma.gl/constants");

// src/context/state-tracker/with-parameters.ts
function withGLParameters(device, parameters, func) {
  const webglDevice = WebGLDevice.attach(device);
  const gl = webglDevice.gl;
  if (isObjectEmpty2(parameters)) {
    return func(device);
  }
  const { nocatch = true } = parameters;
  pushContextState(gl);
  setGLParameters(gl, parameters);
  let value;
  if (nocatch) {
    value = func(gl);
    popContextState(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      popContextState(gl);
    }
  }
  return value;
}
function isObjectEmpty2(object) {
  for (const key in object) {
    return false;
  }
  return true;
}

// src/adapter/converters/sampler-parameters.ts
var import_constants9 = require("@luma.gl/constants");

// src/adapter/converters/device-parameters.ts
var import_core6 = require("@luma.gl/core");
var import_constants8 = require("@luma.gl/constants");
function withDeviceAndGLParameters(device, parameters, glParameters, func) {
  if ((0, import_core6.isObjectEmpty)(parameters)) {
    return func(device);
  }
  pushContextState(device.gl);
  try {
    setDeviceParameters(device, parameters);
    setGLParameters(device, glParameters);
    return func(device);
  } finally {
    popContextState(device.gl);
  }
}
function withDeviceParameters(device, parameters, func) {
  if ((0, import_core6.isObjectEmpty)(parameters)) {
    return func(device);
  }
  pushContextState(device.gl);
  try {
    setDeviceParameters(device, parameters);
    return func(device);
  } finally {
    popContextState(device.gl);
  }
}
function setDeviceParameters(device, parameters) {
  const webglDevice = WebGLDevice.attach(device);
  const { gl } = webglDevice;
  if (parameters.cullMode) {
    switch (parameters.cullMode) {
      case "none":
        gl.disable(import_constants8.GL.CULL_FACE);
        break;
      case "front":
        gl.enable(import_constants8.GL.CULL_FACE);
        gl.cullFace(import_constants8.GL.FRONT);
        break;
      case "back":
        gl.enable(import_constants8.GL.CULL_FACE);
        gl.cullFace(import_constants8.GL.BACK);
        break;
    }
  }
  if (parameters.frontFace) {
    gl.frontFace(
      map("frontFace", parameters.frontFace, {
        ccw: import_constants8.GL.CCW,
        cw: import_constants8.GL.CW
      })
    );
  }
  if (parameters.depthBias !== void 0) {
    gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);
  }
  if (parameters.depthWriteEnabled !== void 0) {
    gl.depthMask(mapBoolean("depthWriteEnabled", parameters.depthWriteEnabled));
  }
  if (parameters.depthCompare) {
    parameters.depthCompare !== "always" ? gl.enable(import_constants8.GL.DEPTH_TEST) : gl.disable(import_constants8.GL.DEPTH_TEST);
    gl.depthFunc(convertCompareFunction("depthCompare", parameters.depthCompare));
  }
  if (parameters.stencilWriteMask) {
    const mask = parameters.stencilWriteMask;
    gl.stencilMaskSeparate(import_constants8.GL.FRONT, mask);
    gl.stencilMaskSeparate(import_constants8.GL.BACK, mask);
  }
  if (parameters.stencilReadMask) {
    import_core6.log.warn("stencilReadMask not supported under WebGL");
  }
  if (parameters.stencilCompare) {
    const mask = parameters.stencilReadMask || 4294967295;
    const glValue = convertCompareFunction("depthCompare", parameters.stencilCompare);
    parameters.stencilCompare !== "always" ? gl.enable(import_constants8.GL.STENCIL_TEST) : gl.disable(import_constants8.GL.STENCIL_TEST);
    gl.stencilFuncSeparate(import_constants8.GL.FRONT, glValue, 0, mask);
    gl.stencilFuncSeparate(import_constants8.GL.BACK, glValue, 0, mask);
  }
  if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {
    const dppass = convertStencilOperation("stencilPassOperation", parameters.stencilPassOperation);
    const sfail = convertStencilOperation("stencilFailOperation", parameters.stencilFailOperation);
    const dpfail = convertStencilOperation(
      "stencilDepthFailOperation",
      parameters.stencilDepthFailOperation
    );
    gl.stencilOpSeparate(import_constants8.GL.FRONT, sfail, dpfail, dppass);
    gl.stencilOpSeparate(import_constants8.GL.BACK, sfail, dpfail, dppass);
  }
  if (parameters.blendColorOperation || parameters.blendAlphaOperation) {
    gl.enable(import_constants8.GL.BLEND);
    const colorEquation = convertBlendOperationToEquation("blendColorOperation", parameters.blendColorOperation || "add");
    const alphaEquation = convertBlendOperationToEquation("blendAlphaOperation", parameters.blendAlphaOperation || "add");
    gl.blendEquationSeparate(colorEquation, alphaEquation);
    const colorSrcFactor = convertBlendFactorToFunction("blendColorSrcFactor", parameters.blendColorSrcFactor || "one");
    const colorDstFactor = convertBlendFactorToFunction("blendColorDstFactor", parameters.blendColorDstFactor || "zero");
    const alphaSrcFactor = convertBlendFactorToFunction("blendAlphaSrcFactor", parameters.blendAlphaSrcFactor || "one");
    const alphaDstFactor = convertBlendFactorToFunction("blendAlphaDstFactor", parameters.blendAlphaDstFactor || "zero");
    gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
  }
}
function convertCompareFunction(parameter, value) {
  return map(parameter, value, {
    never: import_constants8.GL.NEVER,
    less: import_constants8.GL.LESS,
    equal: import_constants8.GL.EQUAL,
    "less-equal": import_constants8.GL.LEQUAL,
    greater: import_constants8.GL.GREATER,
    "not-equal": import_constants8.GL.NOTEQUAL,
    "greater-equal": import_constants8.GL.GEQUAL,
    always: import_constants8.GL.ALWAYS
  });
}
function convertStencilOperation(parameter, value) {
  return map(parameter, value, {
    keep: import_constants8.GL.KEEP,
    zero: import_constants8.GL.ZERO,
    replace: import_constants8.GL.REPLACE,
    invert: import_constants8.GL.INVERT,
    "increment-clamp": import_constants8.GL.INCR,
    "decrement-clamp": import_constants8.GL.DECR,
    "increment-wrap": import_constants8.GL.INCR_WRAP,
    "decrement-wrap": import_constants8.GL.DECR_WRAP
  });
}
function convertBlendOperationToEquation(parameter, value) {
  return map(parameter, value, {
    "add": import_constants8.GL.FUNC_ADD,
    "subtract": import_constants8.GL.FUNC_SUBTRACT,
    "reverse-subtract": import_constants8.GL.FUNC_REVERSE_SUBTRACT,
    // When using a WebGL 2 context, the following values are available additionally:
    "min": import_constants8.GL.MIN,
    "max": import_constants8.GL.MAX
  });
}
function convertBlendFactorToFunction(parameter, value) {
  return map(parameter, value, {
    "one": import_constants8.GL.ONE,
    "zero": import_constants8.GL.ZERO,
    "src-color": import_constants8.GL.SRC_COLOR,
    "one-minus-src-color": import_constants8.GL.ONE_MINUS_SRC_COLOR,
    "dst-color": import_constants8.GL.DST_COLOR,
    "one-minus-dst-color": import_constants8.GL.ONE_MINUS_DST_COLOR,
    "src-alpha": import_constants8.GL.SRC_ALPHA,
    "one-minus-src-alpha": import_constants8.GL.ONE_MINUS_SRC_ALPHA,
    "dst-alpha": import_constants8.GL.DST_ALPHA,
    "one-minus-dst-alpha": import_constants8.GL.ONE_MINUS_DST_ALPHA
  });
}
function message(parameter, value) {
  return `Illegal parameter ${value} for ${parameter}`;
}
function map(parameter, value, valueMap) {
  if (!(value in valueMap)) {
    throw new Error(message(parameter, value));
  }
  return valueMap[value];
}
function mapBoolean(parameter, value) {
  return value;
}

// src/adapter/converters/sampler-parameters.ts
function convertSamplerParametersToWebGL(props) {
  const params = {};
  if (props.addressModeU) {
    params[import_constants9.GL.TEXTURE_WRAP_S] = convertAddressMode(props.addressModeU);
  }
  if (props.addressModeV) {
    params[import_constants9.GL.TEXTURE_WRAP_T] = convertAddressMode(props.addressModeV);
  }
  if (props.addressModeW) {
    params[import_constants9.GL.TEXTURE_WRAP_R] = convertAddressMode(props.addressModeW);
  }
  if (props.magFilter) {
    params[import_constants9.GL.TEXTURE_MAG_FILTER] = convertMaxFilterMode(props.magFilter);
  }
  if (props.minFilter || props.mipmapFilter) {
    params[import_constants9.GL.TEXTURE_MIN_FILTER] = convertMinFilterMode(
      props.minFilter || "linear",
      props.mipmapFilter
    );
  }
  if (props.lodMinClamp !== void 0) {
    params[import_constants9.GL.TEXTURE_MIN_LOD] = props.lodMinClamp;
  }
  if (props.lodMaxClamp !== void 0) {
    params[import_constants9.GL.TEXTURE_MAX_LOD] = props.lodMaxClamp;
  }
  if (props.type === "comparison-sampler") {
    params[import_constants9.GL.TEXTURE_COMPARE_MODE] = import_constants9.GL.COMPARE_REF_TO_TEXTURE;
  }
  if (props.compare) {
    params[import_constants9.GL.TEXTURE_COMPARE_FUNC] = convertCompareFunction("compare", props.compare);
  }
  if (props.maxAnisotropy) {
    params[import_constants9.GL.TEXTURE_MAX_ANISOTROPY_EXT] = props.maxAnisotropy;
  }
  return params;
}
function updateSamplerParametersForNPOT(parameters) {
  const newParameters = { ...parameters };
  if (parameters[import_constants9.GL.TEXTURE_MIN_FILTER] !== import_constants9.GL.NEAREST) {
    newParameters[import_constants9.GL.TEXTURE_MIN_FILTER] = import_constants9.GL.LINEAR;
  }
  newParameters[import_constants9.GL.TEXTURE_WRAP_S] = import_constants9.GL.CLAMP_TO_EDGE;
  newParameters[import_constants9.GL.TEXTURE_WRAP_T] = import_constants9.GL.CLAMP_TO_EDGE;
  return newParameters;
}
function convertAddressMode(addressMode) {
  switch (addressMode) {
    case "clamp-to-edge":
      return import_constants9.GL.CLAMP_TO_EDGE;
    case "repeat":
      return import_constants9.GL.REPEAT;
    case "mirror-repeat":
      return import_constants9.GL.MIRRORED_REPEAT;
  }
}
function convertMaxFilterMode(maxFilter) {
  switch (maxFilter) {
    case "nearest":
      return import_constants9.GL.NEAREST;
    case "linear":
      return import_constants9.GL.LINEAR;
  }
}
function convertMinFilterMode(minFilter, mipmapFilter) {
  if (!mipmapFilter) {
    return convertMaxFilterMode(minFilter);
  }
  switch (minFilter) {
    case "nearest":
      return mipmapFilter === "nearest" ? import_constants9.GL.NEAREST_MIPMAP_NEAREST : import_constants9.GL.NEAREST_MIPMAP_LINEAR;
    case "linear":
      return mipmapFilter === "nearest" ? import_constants9.GL.LINEAR_MIPMAP_NEAREST : import_constants9.GL.LINEAR_MIPMAP_LINEAR;
  }
}

// src/adapter/resources/webgl-buffer.ts
var import_core7 = require("@luma.gl/core");
var import_constants10 = require("@luma.gl/constants");
var WEBGLBuffer = class extends import_core7.Buffer {
  device;
  gl;
  gl2;
  handle;
  /** Target in OpenGL defines the type of buffer */
  glTarget;
  /** Usage is a hint on how frequently the buffer will be updates */
  glUsage;
  /** Index type is needed when issuing draw calls, so we pre-compute it */
  glIndexType = import_constants10.GL.UNSIGNED_SHORT;
  /** Number of bytes allocated on the GPU for this buffer */
  byteLength;
  /** Number of bytes used */
  bytesUsed;
  constructor(device, props = {}) {
    super(device, props);
    this.device = device;
    this.gl = this.device.gl;
    this.gl2 = this.device.gl2;
    const handle = typeof props === "object" ? props.handle : void 0;
    this.handle = handle || this.gl.createBuffer();
    device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
    this.glTarget = getWebGLTarget(this.props.usage);
    this.glUsage = getWebGLUsage(this.props.usage);
    this.glIndexType = this.props.indexType === "uint32" ? import_constants10.GL.UNSIGNED_INT : import_constants10.GL.UNSIGNED_SHORT;
    if (props.data) {
      this._initWithData(props.data, props.byteOffset, props.byteLength);
    } else {
      this._initWithByteLength(props.byteLength || 0);
    }
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, byteLength, this.glUsage);
    this.gl.bufferSubData(glTarget, byteOffset, data);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(data, byteOffset, byteLength);
    this.trackAllocatedMemory(byteLength);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(byteLength) {
    (0, import_core7.assert)(byteLength >= 0);
    let data = byteLength;
    if (byteLength === 0) {
      data = new Float32Array(0);
    }
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, data, this.glUsage);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(null, 0, byteLength);
    this.trackAllocatedMemory(byteLength);
    return this;
  }
  destroy() {
    if (!this.destroyed && this.handle) {
      this.removeStats();
      this.trackDeallocatedMemory();
      this.gl.deleteBuffer(this.handle);
      this.destroyed = true;
      this.handle = null;
    }
  }
  write(data, byteOffset = 0) {
    const srcOffset = 0;
    const byteLength = void 0;
    const glTarget = this.device.isWebGL2 ? import_constants10.GL.COPY_WRITE_BUFFER : this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    if (srcOffset !== 0 || byteLength !== void 0) {
      this.device.assertWebGL2();
      this.gl2.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(glTarget, byteOffset, data);
    }
    this.gl.bindBuffer(glTarget, null);
    this._setDebugData(data, byteOffset, data.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync(byteOffset = 0, byteLength) {
    return this.readSyncWebGL2(byteOffset, byteLength);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL2(byteOffset = 0, byteLength) {
    this.device.assertWebGL2();
    byteLength = byteLength ?? this.byteLength - byteOffset;
    const data = new Uint8Array(byteLength);
    const dstOffset = 0;
    this.gl.bindBuffer(import_constants10.GL.COPY_READ_BUFFER, this.handle);
    this.gl2.getBufferSubData(import_constants10.GL.COPY_READ_BUFFER, byteOffset, data, dstOffset, byteLength);
    this.gl.bindBuffer(import_constants10.GL.COPY_READ_BUFFER, null);
    this._setDebugData(data, byteOffset, byteLength);
    return data;
  }
};
function getWebGLTarget(usage) {
  if (usage & import_core7.Buffer.INDEX) {
    return import_constants10.GL.ELEMENT_ARRAY_BUFFER;
  }
  if (usage & import_core7.Buffer.VERTEX) {
    return import_constants10.GL.ARRAY_BUFFER;
  }
  if (usage & import_core7.Buffer.UNIFORM) {
    return import_constants10.GL.UNIFORM_BUFFER;
  }
  return import_constants10.GL.ARRAY_BUFFER;
}
function getWebGLUsage(usage) {
  if (usage & import_core7.Buffer.INDEX) {
    return import_constants10.GL.STATIC_DRAW;
  }
  if (usage & import_core7.Buffer.VERTEX) {
    return import_constants10.GL.STATIC_DRAW;
  }
  if (usage & import_core7.Buffer.UNIFORM) {
    return import_constants10.GL.DYNAMIC_DRAW;
  }
  return import_constants10.GL.STATIC_DRAW;
}

// src/adapter/resources/webgl-sampler.ts
var import_core8 = require("@luma.gl/core");
var import_constants11 = require("@luma.gl/constants");
var WEBGLSampler = class extends import_core8.Sampler {
  device;
  handle;
  parameters;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    this.parameters = convertSamplerParametersToWebGL(props);
    if (this.device.isWebGL2) {
      this.handle = this.handle || this.device.gl2.createSampler();
      this._setSamplerParameters(this.parameters);
    }
  }
  destroy() {
    if (this.handle) {
      this.device.gl2.deleteSampler(this.handle);
      this.handle = void 0;
    }
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(parameters) {
    for (const [pname, value] of Object.entries(parameters)) {
      const param = Number(pname);
      switch (param) {
        case import_constants11.GL.TEXTURE_MIN_LOD:
        case import_constants11.GL.TEXTURE_MAX_LOD:
          this.device.gl2.samplerParameterf(this.handle, param, value);
          break;
        default:
          this.device.gl2.samplerParameteri(this.handle, param, value);
          break;
      }
    }
  }
};

// src/adapter/resources/webgl-texture.ts
var DEFAULT_WEBGL_TEXTURE_PROPS = {
  // deprecated
  parameters: {},
  pixelStore: {},
  pixels: null,
  border: 0,
  dataFormat: void 0,
  textureUnit: void 0,
  target: void 0
};
var _WEBGLTexture = class extends import_core9.Texture {
  MAX_ATTRIBUTES;
  device;
  gl;
  gl2;
  handle;
  /** Sampler object (currently unused) */
  sampler = void 0;
  // data;
  glFormat = void 0;
  type = void 0;
  dataFormat = void 0;
  mipmaps = void 0;
  /**
   * @note `target` cannot be modified by bind:
   * textures are special because when you first bind them to a target,
   * they get special information. When you first bind a texture as a
   * GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
   * And it will always be a 2D texture; this state cannot be changed ever.
   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
   * */
  target;
  textureUnit = void 0;
  /**
   * Program.draw() checks the loaded flag of all textures to avoid
   * Textures that are still loading from promises
   * Set to true as soon as texture has been initialized with valid data
   */
  loaded = false;
  _video;
  constructor(device, props) {
    var _a;
    super(device, { ...DEFAULT_WEBGL_TEXTURE_PROPS, format: "rgba8unorm", ...props });
    this.device = device;
    this.gl = this.device.gl;
    this.gl2 = this.device.gl2;
    this.handle = this.props.handle || this.gl.createTexture();
    this.device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
    this.glFormat = import_constants12.GL.RGBA;
    this.target = getWebGLTextureTarget(this.props);
    this.loaded = false;
    if (typeof ((_a = this.props) == null ? void 0 : _a.data) === "string") {
      Object.assign(this.props, { data: (0, import_core9.loadImage)(this.props.data) });
    }
    this.initialize(this.props);
    Object.seal(this);
  }
  destroy() {
    if (this.handle) {
      this.gl.deleteTexture(this.handle);
      this.removeStats();
      this.trackDeallocatedMemory("Texture");
      this.destroyed = true;
    }
  }
  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }
  // eslint-disable-next-line max-statements
  initialize(props = {}) {
    if (this.props.dimension === "cube") {
      return this.initializeCube(props);
    }
    let data = props.data;
    if (data instanceof Promise) {
      data.then(
        (resolvedImageData) => this.initialize(
          Object.assign({}, props, {
            pixels: resolvedImageData,
            data: resolvedImageData
          })
        )
      );
      return this;
    }
    const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
      this._video = null;
      data.addEventListener("loadeddata", () => this.initialize(props));
      return this;
    }
    const { parameters = {} } = props;
    const { pixels = null, pixelStore = {}, textureUnit = void 0 } = props;
    if (!data) {
      data = pixels;
    }
    let { width, height, dataFormat, type, compressed = false, mipmaps = true } = props;
    const { depth = 0 } = props;
    const glFormat = convertTextureFormatToGL(props.format, this.device.isWebGL2);
    ({ width, height, compressed, dataFormat, type } = this._deduceParameters({
      format: props.format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    this.width = width;
    this.height = height;
    this.glFormat = glFormat;
    this.type = type;
    this.dataFormat = dataFormat;
    this.textureUnit = textureUnit;
    if (Number.isFinite(this.textureUnit)) {
      this.gl.activeTexture(import_constants12.GL.TEXTURE0 + this.textureUnit);
      this.gl.bindTexture(this.target, this.handle);
    }
    if (mipmaps && this.device.isWebGL1 && isNPOT(this.width, this.height)) {
      import_core9.log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaps`)();
      mipmaps = false;
    }
    this.mipmaps = mipmaps;
    this.setImageData({
      data,
      width,
      height,
      depth,
      format: glFormat,
      type,
      dataFormat,
      // @ts-expect-error
      parameters: pixelStore,
      compressed
    });
    this.setSampler(props.sampler);
    this._setSamplerParameters(parameters);
    if (mipmaps) {
      this.generateMipmap();
    }
    if (isVideo) {
      this._video = {
        video: data,
        parameters,
        // @ts-expect-error
        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
      };
    }
    return this;
  }
  initializeCube(props) {
    const { mipmaps = true, parameters = {} } = props;
    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;
      if (mipmaps) {
        this.generateMipmap(props);
      }
      this.setSampler(props.sampler);
      this._setSamplerParameters(parameters);
    });
    return this;
  }
  setSampler(sampler = {}) {
    let samplerProps;
    if (sampler instanceof WEBGLSampler) {
      this.sampler = sampler;
      samplerProps = sampler.props;
    } else {
      this.sampler = new WEBGLSampler(this.device, sampler);
      samplerProps = sampler;
    }
    const parameters = convertSamplerParametersToWebGL(samplerProps);
    this._setSamplerParameters(parameters);
    return this;
  }
  /**
   * If size has changed, reinitializes with current format
   * @note note clears image and mipmaps
   */
  resize(options) {
    const { height, width, mipmaps = false } = options;
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        type: this.type,
        dataFormat: this.dataFormat,
        mipmaps
      });
    }
    return this;
  }
  /** Update external texture (video frame) */
  update() {
    if (this._video) {
      const { video, parameters, lastTime } = this._video;
      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
        return;
      }
      this.setSubImageData({
        data: video,
        parameters
      });
      if (this.mipmaps) {
        this.generateMipmap();
      }
      this._video.lastTime = video.currentTime;
    }
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(params = {}) {
    if (this.device.isWebGL1 && isNPOT(this.width, this.height)) {
      import_core9.log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();
      return this;
    }
    this.mipmaps = true;
    this.gl.bindTexture(this.target, this.handle);
    withGLParameters(this.gl, params, () => {
      this.gl.generateMipmap(this.target);
    });
    this.gl.bindTexture(this.target, null);
    return this;
  }
  /*
   * Allocates storage
   * @param {*} pixels -
   *  null - create empty texture of specified format
   *  Typed array - init from image data in typed array
   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
   *  HTMLImageElement|Image - Inits with content of image. Auto width/height
   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
   *  HTMLVideoElement - Creates video texture. Auto width/height
   *
   * @param  width -
   * @param  height -
   * @param  mipMapLevel -
   * @param {GLenum} format - format of image data.
   * @param {GLenum} type
   *  - format of array (autodetect from type) or
   *  - (WEBGL2) format of buffer
   * @param {Number} offset - (WEBGL2) offset from start of buffer
   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
   */
  // eslint-disable-next-line max-statements, complexity
  setImageData(options) {
    if (this.props.dimension === "3d" || this.props.dimension === "2d-array") {
      return this.setImageData3D(options);
    }
    this.trackDeallocatedMemory("Texture");
    const {
      target = this.target,
      pixels = null,
      level = 0,
      glFormat = this.glFormat,
      offset = 0,
      parameters = {}
    } = options;
    let {
      data = null,
      type = this.type,
      width = this.width,
      height = this.height,
      dataFormat = this.dataFormat,
      compressed = false
    } = options;
    if (!data) {
      data = pixels;
    }
    ({ type, dataFormat, compressed, width, height } = this._deduceParameters({
      format: this.props.format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    const { gl } = this;
    gl.bindTexture(this.target, this.handle);
    let dataType = null;
    ({ data, dataType } = this._getDataType({ data, compressed }));
    let gl2;
    withGLParameters(this.gl, parameters, () => {
      switch (dataType) {
        case "null":
          gl.texImage2D(
            target,
            level,
            glFormat,
            width,
            height,
            0,
            dataFormat,
            type,
            data
          );
          break;
        case "typed-array":
          gl.texImage2D(
            target,
            level,
            glFormat,
            width,
            height,
            0,
            // border (must be 0)
            dataFormat,
            type,
            data,
            // @ts-expect-error
            offset
          );
          break;
        case "buffer":
          gl2 = this.device.assertWebGL2();
          gl2.bindBuffer(import_constants12.GL.PIXEL_UNPACK_BUFFER, data.handle || data);
          gl2.texImage2D(
            target,
            level,
            glFormat,
            width,
            height,
            0,
            dataFormat,
            type,
            offset
          );
          gl2.bindBuffer(import_constants12.GL.PIXEL_UNPACK_BUFFER, null);
          break;
        case "browser-object":
          if (this.device.isWebGL2) {
            gl.texImage2D(
              target,
              level,
              glFormat,
              width,
              height,
              0,
              dataFormat,
              type,
              data
            );
          } else {
            gl.texImage2D(target, level, glFormat, dataFormat, type, data);
          }
          break;
        case "compressed":
          for (const [levelIndex, levelData] of data.entries()) {
            gl.compressedTexImage2D(
              target,
              levelIndex,
              levelData.format,
              levelData.width,
              levelData.height,
              0,
              levelData.data
            );
          }
          break;
        default:
          (0, import_core9.assert)(false, "Unknown image data type");
      }
    });
    if (data && data.byteLength) {
      this.trackAllocatedMemory(data.byteLength, "Texture");
    } else {
      const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format, this.device.isWebGL2);
      this.trackAllocatedMemory(this.width * this.height * bytesPerPixel, "Texture");
    }
    this.loaded = true;
    return this;
  }
  /**
   * Redefines an area of an existing texture
   * Note: does not allocate storage
   * Redefines an area of an existing texture
   */
  setSubImageData({
    target = this.target,
    pixels = null,
    data = null,
    x = 0,
    y = 0,
    width = this.width,
    height = this.height,
    level = 0,
    glFormat = this.glFormat,
    type = this.type,
    dataFormat = this.dataFormat,
    compressed = false,
    offset = 0,
    parameters = {}
  }) {
    ({ type, dataFormat, compressed, width, height } = this._deduceParameters({
      format: this.props.format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    (0, import_core9.assert)(this.depth === 1, "texSubImage not supported for 3D textures");
    if (!data) {
      data = pixels;
    }
    if (data && data.data) {
      const ndarray = data;
      data = ndarray.data;
      width = ndarray.shape[0];
      height = ndarray.shape[1];
    }
    if (data instanceof WEBGLBuffer) {
      data = data.handle;
    }
    this.gl.bindTexture(this.target, this.handle);
    withGLParameters(this.gl, parameters, () => {
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, glFormat, data);
      } else if (data === null) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data)) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
      } else if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
        const gl2 = this.device.assertWebGL2();
        gl2.bindBuffer(import_constants12.GL.PIXEL_UNPACK_BUFFER, data);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
        gl2.bindBuffer(import_constants12.GL.PIXEL_UNPACK_BUFFER, null);
      } else if (this.device.isWebGL2) {
        const gl2 = this.device.assertWebGL2();
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
      } else {
        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
      }
    });
    this.gl.bindTexture(this.target, null);
  }
  /**
   * Defines a two-dimensional texture image or cube-map texture image with
   * pixels from the current framebuffer (rather than from client memory).
   * (gl.copyTexImage2D wrapper)
   *
   * Note that binding a texture into a Framebuffer's color buffer and
   * rendering can be faster.
   */
  copyFramebuffer(opts = {}) {
    import_core9.log.error(
      "Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})"
    )();
    return null;
  }
  getActiveUnit() {
    return this.gl.getParameter(import_constants12.GL.ACTIVE_TEXTURE) - import_constants12.GL.TEXTURE0;
  }
  bind(textureUnit = this.textureUnit) {
    const { gl } = this;
    if (textureUnit !== void 0) {
      this.textureUnit = textureUnit;
      gl.activeTexture(gl.TEXTURE0 + textureUnit);
    }
    gl.bindTexture(this.target, this.handle);
    return textureUnit;
  }
  unbind(textureUnit = this.textureUnit) {
    const { gl } = this;
    if (textureUnit !== void 0) {
      this.textureUnit = textureUnit;
      gl.activeTexture(gl.TEXTURE0 + textureUnit);
    }
    gl.bindTexture(this.target, null);
    return textureUnit;
  }
  // PRIVATE METHODS
  _getDataType({ data, compressed = false }) {
    if (compressed) {
      return { data, dataType: "compressed" };
    }
    if (data === null) {
      return { data, dataType: "null" };
    }
    if (ArrayBuffer.isView(data)) {
      return { data, dataType: "typed-array" };
    }
    if (data instanceof WEBGLBuffer) {
      return { data: data.handle, dataType: "buffer" };
    }
    if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
      return { data, dataType: "buffer" };
    }
    return { data, dataType: "browser-object" };
  }
  // HELPER METHODS
  _deduceParameters(opts) {
    const { format, data } = opts;
    let { width, height, dataFormat, type, compressed } = opts;
    const parameters = getWebGLTextureParameters(format, this.device.isWebGL2);
    dataFormat = dataFormat || parameters.dataFormat;
    type = type || parameters.type;
    compressed = compressed || parameters.compressed;
    ({ width, height } = this._deduceImageSize(data, width, height));
    return { dataFormat, type, compressed, width, height, format, data };
  }
  // eslint-disable-next-line complexity
  _deduceImageSize(data, width, height) {
    let size;
    if (typeof ImageData !== "undefined" && data instanceof ImageData) {
      size = { width: data.width, height: data.height };
    } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
      size = { width: data.naturalWidth, height: data.naturalHeight };
    } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
      size = { width: data.width, height: data.height };
    } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
      size = { width: data.width, height: data.height };
    } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
      size = { width: data.videoWidth, height: data.videoHeight };
    } else if (!data) {
      size = { width: width >= 0 ? width : 1, height: height >= 0 ? height : 1 };
    } else {
      size = { width, height };
    }
    (0, import_core9.assert)(size, "Could not deduced texture size");
    (0, import_core9.assert)(
      width === void 0 || size.width === width,
      "Deduced texture width does not match supplied width"
    );
    (0, import_core9.assert)(
      height === void 0 || size.height === height,
      "Deduced texture height does not match supplied height"
    );
    return size;
  }
  // CUBE MAP METHODS
  /* eslint-disable max-statements, max-len */
  async setCubeMapImageData(options) {
    const { gl } = this;
    const { width, height, pixels, data, format = import_constants12.GL.RGBA, type = import_constants12.GL.UNSIGNED_BYTE } = options;
    const imageDataMap = pixels || data;
    const resolvedFaces = await Promise.all(
      _WEBGLTexture.FACES.map((face) => {
        const facePixels = imageDataMap[face];
        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
      })
    );
    this.bind();
    _WEBGLTexture.FACES.forEach((face, index) => {
      if (resolvedFaces[index].length > 1 && this.props.mipmaps !== false) {
        import_core9.log.warn(`${this.id} has mipmap and multiple LODs.`)();
      }
      resolvedFaces[index].forEach((image, lodLevel) => {
        if (width && height) {
          gl.texImage2D(face, lodLevel, format, width, height, 0, format, type, image);
        } else {
          gl.texImage2D(face, lodLevel, format, format, type, image);
        }
      });
    });
    this.unbind();
  }
  /** @todo update this method to accept LODs */
  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      format = import_constants12.GL.RGBA,
      type = import_constants12.GL.UNSIGNED_BYTE
      // generateMipmap = false // TODO
    } = options;
    const { gl } = this;
    const imageData = pixels || data;
    this.bind();
    if (imageData instanceof Promise) {
      imageData.then(
        (resolvedImageData) => this.setImageDataForFace(
          Object.assign({}, options, {
            face,
            data: resolvedImageData,
            pixels: resolvedImageData
          })
        )
      );
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, 0, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }
    return this;
  }
  /** Image 3D copies from Typed Array or WebGLBuffer */
  setImageData3D(options) {
    const {
      level = 0,
      dataFormat,
      format,
      type,
      // = GL.UNSIGNED_BYTE,
      width,
      height,
      depth = 1,
      offset = 0,
      data,
      parameters = {}
    } = options;
    this.trackDeallocatedMemory("Texture");
    this.gl.bindTexture(this.target, this.handle);
    const webglTextureFormat = getWebGLTextureParameters(format, this.device.isWebGL2);
    withGLParameters(this.gl, parameters, () => {
      if (ArrayBuffer.isView(data)) {
        this.gl.texImage3D(
          this.target,
          level,
          webglTextureFormat.format,
          width,
          height,
          depth,
          0,
          webglTextureFormat.dataFormat,
          webglTextureFormat.type,
          // dataType: getWebGL,
          data
        );
      }
      if (data instanceof WEBGLBuffer) {
        this.gl.bindBuffer(import_constants12.GL.PIXEL_UNPACK_BUFFER, data.handle);
        this.gl.texImage3D(
          this.target,
          level,
          dataFormat,
          width,
          height,
          depth,
          0,
          format,
          type,
          offset
        );
      }
    });
    if (data && data.byteLength) {
      this.trackAllocatedMemory(data.byteLength, "Texture");
    } else {
      const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format, this.device.isWebGL2);
      this.trackAllocatedMemory(this.width * this.height * this.depth * bytesPerPixel, "Texture");
    }
    this.loaded = true;
    return this;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   * @note: Applies NPOT workaround if appropriate
   */
  _setSamplerParameters(parameters) {
    if (this.device.isWebGL1 && isNPOT(this.width, this.height)) {
      parameters = updateSamplerParametersForNPOT(parameters);
    }
    if ((0, import_core9.isObjectEmpty)(parameters)) {
      return;
    }
    logParameters(parameters);
    this.gl.bindTexture(this.target, this.handle);
    for (const [pname, pvalue] of Object.entries(parameters)) {
      const param = Number(pname);
      const value = pvalue;
      switch (param) {
        case import_constants12.GL.TEXTURE_MIN_LOD:
        case import_constants12.GL.TEXTURE_MAX_LOD:
          this.gl.texParameterf(this.target, param, value);
          break;
        default:
          this.gl.texParameteri(this.target, param, value);
          break;
      }
    }
    this.gl.bindTexture(this.target, null);
    return;
  }
  /** @deprecated For LegacyTexture subclass */
  _getWebGL1NPOTParameterOverride(pname, value) {
    const npot = this.device.isWebGL1 && isNPOT(this.width, this.height);
    if (npot) {
      switch (pname) {
        case import_constants12.GL.TEXTURE_MIN_FILTER:
          if (value !== import_constants12.GL.LINEAR && value !== import_constants12.GL.NEAREST) {
            return import_constants12.GL.LINEAR;
          }
          break;
        case import_constants12.GL.TEXTURE_WRAP_S:
        case import_constants12.GL.TEXTURE_WRAP_T:
          return import_constants12.GL.CLAMP_TO_EDGE;
        default:
          break;
      }
    }
    return value;
  }
};
var WEBGLTexture = _WEBGLTexture;
// TODO - remove?
__publicField(WEBGLTexture, "FACES", [
  import_constants12.GL.TEXTURE_CUBE_MAP_POSITIVE_X,
  import_constants12.GL.TEXTURE_CUBE_MAP_NEGATIVE_X,
  import_constants12.GL.TEXTURE_CUBE_MAP_POSITIVE_Y,
  import_constants12.GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,
  import_constants12.GL.TEXTURE_CUBE_MAP_POSITIVE_Z,
  import_constants12.GL.TEXTURE_CUBE_MAP_NEGATIVE_Z
]);
function getWebGLTextureTarget(props) {
  switch (props.dimension) {
    case "2d":
      return import_constants12.GL.TEXTURE_2D;
    case "cube":
      return import_constants12.GL.TEXTURE_CUBE_MAP;
    case "2d-array":
      return import_constants12.GL.TEXTURE_2D_ARRAY;
    case "3d":
      return import_constants12.GL.TEXTURE_3D;
    case "1d":
    case "cube-array":
    default:
      throw new Error(props.dimension);
  }
}
function isNPOT(width, height) {
  if (!width || !height) {
    return false;
  }
  return !(0, import_core9.isPowerOfTwo)(width) || !(0, import_core9.isPowerOfTwo)(height);
}
function logParameters(parameters) {
  import_core9.log.log(1, "texture sampler parameters", parameters)();
}

// src/adapter/objects/webgl-renderbuffer.ts
var import_core12 = require("@luma.gl/core");
var import_constants13 = require("@luma.gl/constants");

// src/adapter/objects/webgl-resource.ts
var import_core11 = require("@luma.gl/core");

// src/adapter/objects/constants-to-keys.ts
var import_core10 = require("@luma.gl/core");
function getKeyValue(gl, name) {
  if (typeof name !== "string") {
    return name;
  }
  const number = Number(name);
  if (!isNaN(number)) {
    return number;
  }
  name = name.replace(/^.*\./, "");
  const value = gl[name];
  (0, import_core10.assert)(value !== void 0, `Accessing undefined constant GL.${name}`);
  return value;
}

// src/adapter/objects/webgl-resource.ts
var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
var WebGLResource = class extends import_core11.Resource {
  device;
  gl;
  gl2;
  _handle;
  _bound = false;
  // Only meaningful for resources that allocate GPU memory
  byteLength = 0;
  constructor(device, props, defaultProps) {
    super(device, props, defaultProps);
    this.device = WebGLDevice.attach(device);
    const gl = this.device.gl;
    assertWebGLContext(gl);
    const { id } = props || {};
    this.gl = gl;
    this.gl2 = gl;
    this.id = id || (0, import_core11.uid)(this.constructor.name);
    this._handle = props == null ? void 0 : props.handle;
    if (this._handle === void 0) {
      this._handle = this._createHandle();
    }
    this.byteLength = 0;
  }
  toString() {
    return `${this.constructor.name}(${this.id})`;
  }
  get handle() {
    return this._handle;
  }
  delete({ deleteChildren = false } = {}) {
    const children = this._handle && this._deleteHandle(this._handle);
    if (this._handle) {
      this.removeStats();
    }
    this._handle = null;
    if (children && deleteChildren) {
      children.filter(Boolean).forEach((child) => child.destroy());
    }
    return this;
  }
  bind(funcOrHandle = this.handle) {
    if (typeof funcOrHandle !== "function") {
      this._bindHandle(funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this._bindHandle(this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this._bindHandle(null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  /**
   * Query a Resource parameter
   *
   * @param name
   * @return param
   */
  getParameter(pname, props = {}) {
    pname = getKeyValue(this.gl, pname);
    (0, import_core11.assert)(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = isWebGL2(this.gl);
      const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        const webgl1Default = parameter.webgl1;
        const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
        const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
        return defaultValue;
      }
    }
    return this._getParameter(pname, props);
  }
  // Many resources support a getParameter call -
  // getParameters will get all parameters - slow but useful for debugging
  // eslint-disable-next-line complexity
  getParameters(options = {}) {
    const { parameters, keys } = options;
    const PARAMETERS = this.constructor.PARAMETERS || {};
    const isWebgl2 = isWebGL2(this.gl);
    const values = {};
    const parameterKeys = parameters || Object.keys(PARAMETERS);
    for (const pname of parameterKeys) {
      const parameter = PARAMETERS[pname];
      const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
      if (parameterAvailable) {
        const key = keys ? this.device.getGLKey(pname) : pname;
        values[key] = this.getParameter(pname, options);
        if (keys && parameter.type === "GLenum") {
          values[key] = this.device.getGLKey(values[key]);
        }
      }
    }
    return values;
  }
  /**
   * Update a Resource setting
   *
   * @todo - cache parameter to avoid issuing WebGL calls?
   *
   * @param pname - parameter (GL constant, value or key)
   * @param value {GLint|GLfloat|GLenum} 
   * @return returns self to enable chaining
   */
  setParameter(pname, value) {
    pname = getKeyValue(this.gl, pname);
    (0, import_core11.assert)(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = isWebGL2(this.gl);
      const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        throw new Error("Parameter not available on this platform");
      }
      if (parameter.type === "GLenum") {
        value = getKeyValue(value);
      }
    }
    this._setParameter(pname, value);
    return this;
  }
  /*
   * Batch update resource parameters
   * Assumes the subclass supports a setParameter call
   */
  setParameters(parameters) {
    for (const pname in parameters) {
      this.setParameter(pname, parameters[pname]);
    }
    return this;
  }
  // Install stubs for removed methods
  stubRemovedMethods(className, version, methodNames) {
    return (0, import_core11.stubRemovedMethods)(this, className, version, methodNames);
  }
  // PUBLIC VIRTUAL METHODS
  initialize(props) {
  }
  // PROTECTED METHODS - These must be overridden by subclass
  _createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _bindHandle(handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getOptsFromHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getParameter(pname, props) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _setParameter(pname, value) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  // PRIVATE METHODS
  /*
    _addStats() {
      const name = this.constructor.name;
      const stats = lumaStats.get('Resource Counts');
  
      stats.get('Resources Created').incrementCount();
      stats.get(`${name}s Created`).incrementCount();
      stats.get(`${name}s Active`).incrementCount();
    }
  
    _removeStats() {
      const name = this.constructor.name;
      const stats = lumaStats.get('Resource Counts');
  
      stats.get(`${name}s Active`).decrementCount();
    }
  
    trackAllocatedMemory(bytes, name = this.constructor.name) {
      const stats = lumaStats.get('Memory Usage');
  
      stats.get('GPU Memory').addCount(bytes);
      stats.get(`${name} Memory`).addCount(bytes);
      this.byteLength = bytes;
    }
  
    trackDeallocatedMemory(name = this.constructor.name) {
      const stats = lumaStats.get('Memory Usage');
  
      stats.get('GPU Memory').subtractCount(this.byteLength);
      stats.get(`${name} Memory`).subtractCount(this.byteLength);
      this.byteLength = 0;
    }
    */
};

// src/adapter/objects/webgl-renderbuffer.ts
var _WEBGLRenderbuffer = class extends WebGLResource {
  get [Symbol.toStringTag]() {
    return "Renderbuffer";
  }
  get width() {
    return this.props.width;
  }
  get height() {
    return this.props.height;
  }
  get format() {
    return this.props.format;
  }
  get samples() {
    return this.props.samples;
  }
  get attachment() {
    return;
  }
  /** WebGL format constant */
  glFormat;
  static isTextureFormatSupported(device, format) {
    return isRenderbufferFormatSupported(device.gl, format);
  }
  constructor(device, props) {
    if (typeof props.format === "number") {
      throw new Error("Renderbuffer");
    }
    super(device, props, _WEBGLRenderbuffer.defaultProps);
    this.glFormat = convertTextureFormatToGL(this.props.format, device.isWebGL2);
    this._initialize(this.props);
  }
  resize(size) {
    if (size.width !== this.width || size.height !== this.height) {
      Object.assign(this.props, { ...size, format: this.format, samples: this.samples });
      this._initialize(this.props);
    }
  }
  // PRIVATE METHODS
  /** Creates and initializes a renderbuffer object's data store */
  _initialize(props) {
    const { format, width, height, samples } = props;
    (0, import_core12.assert)(format, "Needs format");
    this.trackDeallocatedMemory();
    this.gl.bindRenderbuffer(import_constants13.GL.RENDERBUFFER, this.handle);
    if (samples !== 0 && this.device.isWebGL2) {
      this.gl2.renderbufferStorageMultisample(import_constants13.GL.RENDERBUFFER, samples, this.glFormat, width, height);
    } else {
      this.gl.renderbufferStorage(import_constants13.GL.RENDERBUFFER, this.glFormat, width, height);
    }
    this.gl.bindRenderbuffer(import_constants13.GL.RENDERBUFFER, null);
    this.trackAllocatedMemory(
      width * height * (samples || 1) * getTextureFormatBytesPerPixel(this.glFormat, this.device.isWebGL2)
    );
  }
  // RESOURCE IMPLEMENTATION
  _createHandle() {
    return this.gl.createRenderbuffer();
  }
  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle);
    this.trackDeallocatedMemory();
  }
  _bindHandle(handle) {
    this.gl.bindRenderbuffer(import_constants13.GL.RENDERBUFFER, handle);
  }
};
var WEBGLRenderbuffer = _WEBGLRenderbuffer;
__publicField(WEBGLRenderbuffer, "defaultProps", {
  id: void 0,
  handle: void 0,
  userData: void 0,
  format: void 0,
  // 'depth16unorm'
  width: 1,
  height: 1,
  samples: 0
});

// src/adapter/resources/webgl-framebuffer.ts
var WEBGLFramebuffer = class extends import_core13.Framebuffer {
  device;
  gl;
  handle;
  get texture() {
    return this.colorAttachments[0];
  }
  constructor(device, props) {
    super(device, props);
    const isDefaultFramebuffer = props.handle === null;
    this.device = device;
    this.gl = device.gl;
    this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
    if (!isDefaultFramebuffer) {
      device.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props });
      this.autoCreateAttachmentTextures();
      this.gl.bindFramebuffer(import_constants14.GL.FRAMEBUFFER, this.handle);
      for (let i = 0; i < this.colorAttachments.length; ++i) {
        const attachment = this.colorAttachments[i];
        const attachmentPoint = import_constants14.GL.COLOR_ATTACHMENT0 + i;
        if (attachment) {
          this._attachOne(attachmentPoint, attachment);
        }
      }
      if (this.depthStencilAttachment) {
        this._attachOne(
          getDepthStencilAttachmentWebGL(this.depthStencilAttachment.format),
          this.depthStencilAttachment
        );
      }
      this.gl.bindFramebuffer(import_constants14.GL.FRAMEBUFFER, null);
    }
    if (props.check !== false) {
      this._checkStatus();
    }
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy();
    if (!this.destroyed && this.handle !== null) {
      this.gl.deleteFramebuffer(this.handle);
    }
  }
  // PRIVATE
  /** Check the status */
  _checkStatus() {
    const { gl } = this;
    const prevHandle = gl.bindFramebuffer(import_constants14.GL.FRAMEBUFFER, this.handle);
    const status = gl.checkFramebufferStatus(import_constants14.GL.FRAMEBUFFER);
    gl.bindFramebuffer(import_constants14.GL.FRAMEBUFFER, prevHandle || null);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
      throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
    }
  }
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  createDepthStencilTexture(format) {
    return new WEBGLRenderbuffer(this.device, {
      id: `${this.id}-depth-stencil`,
      // TODO misleading if not depth and stencil?
      format,
      // dataFormat: GL.DEPTH_STENCIL,
      // type: GL.UNSIGNED_INT_24_8,
      width: this.width,
      height: this.height
    });
  }
  /** 
   * Attachment resize is expected to be a noop if size is same 
   */
  resizeAttachments(width, height) {
    if (this.handle === null) {
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }
    if (width === void 0) {
      width = this.gl.drawingBufferWidth;
    }
    if (height === void 0) {
      height = this.gl.drawingBufferHeight;
    }
    for (const colorAttachment of this.colorAttachments) {
      colorAttachment.resize({ width, height });
    }
    if (this.depthStencilAttachment) {
      this.depthStencilAttachment.resize({ width, height });
    }
    return this;
  }
  /** Attach one attachment */
  _attachOne(attachmentPoint, attachment) {
    if (attachment instanceof WEBGLRenderbuffer) {
      this._attachWEBGLRenderbuffer(attachmentPoint, attachment);
      return attachment;
    } else if (Array.isArray(attachment)) {
      const [texture, layer = 0, level = 0] = attachment;
      this._attachTexture(attachmentPoint, texture, layer, level);
      return texture;
    } else if (attachment instanceof WEBGLTexture) {
      this._attachTexture(attachmentPoint, attachment, 0, 0);
      return attachment;
    }
    throw new Error("attach");
  }
  _attachWEBGLRenderbuffer(attachment, renderbuffer) {
    this.gl.framebufferRenderbuffer(
      import_constants14.GL.FRAMEBUFFER,
      attachment,
      import_constants14.GL.RENDERBUFFER,
      renderbuffer.handle
    );
  }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level  = 0 - mipmapLevel (must be 0 in WebGL1)
   */
  _attachTexture(attachment, texture, layer, level) {
    const { gl, gl2 } = this.device;
    gl.bindTexture(texture.target, texture.handle);
    switch (texture.target) {
      case import_constants14.GL.TEXTURE_2D_ARRAY:
      case import_constants14.GL.TEXTURE_3D:
        this.device.assertWebGL2();
        gl2 == null ? void 0 : gl2.framebufferTextureLayer(import_constants14.GL.FRAMEBUFFER, attachment, texture.target, level, layer);
        break;
      case import_constants14.GL.TEXTURE_CUBE_MAP:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(import_constants14.GL.FRAMEBUFFER, attachment, face, texture.handle, level);
        break;
      case import_constants14.GL.TEXTURE_2D:
        gl.framebufferTexture2D(import_constants14.GL.FRAMEBUFFER, attachment, import_constants14.GL.TEXTURE_2D, texture.handle, level);
        break;
      default:
        (0, import_core13.assert)(false, "Illegal texture type");
    }
    gl.bindTexture(texture.target, null);
  }
};
function mapIndexToCubeMapFace(layer) {
  return layer < import_constants14.GL.TEXTURE_CUBE_MAP_POSITIVE_X ? layer + import_constants14.GL.TEXTURE_CUBE_MAP_POSITIVE_X : layer;
}
function _getFrameBufferStatus(status) {
  switch (status) {
    case import_constants14.GL.FRAMEBUFFER_COMPLETE:
      return "success";
    case import_constants14.GL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "Mismatched attachments";
    case import_constants14.GL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "No attachments";
    case import_constants14.GL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "Height/width mismatch";
    case import_constants14.GL.FRAMEBUFFER_UNSUPPORTED:
      return "Unsupported or split attachments";
    case import_constants14.GL.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
      return "Samples mismatch";
    default:
      return `${status}`;
  }
}

// src/adapter/webgl-canvas-context.ts
var WebGLCanvasContext = class extends import_core14.CanvasContext {
  device;
  presentationSize;
  _framebuffer = null;
  constructor(device, props) {
    super(props);
    this.device = device;
    this.presentationSize = [-1, -1];
    this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
    this.update();
  }
  getCurrentFramebuffer() {
    this.update();
    this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, { handle: null });
    return this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const size = this.getPixelSize();
    const sizeChanged = size[0] !== this.presentationSize[0] || size[1] !== this.presentationSize[1];
    if (sizeChanged) {
      this.presentationSize = size;
      this.resize();
    }
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(options) {
    if (!this.device.gl)
      return;
    if (this.canvas) {
      const devicePixelRatio = this.getDevicePixelRatio(options == null ? void 0 : options.useDevicePixels);
      this.setDevicePixelRatio(devicePixelRatio, options);
      return;
    }
    const ext = this.device.gl.getExtension("STACKGL_resize_drawingbuffer");
    if (ext && options && "width" in options && "height" in options) {
      ext.resize(options.width, options.height);
    }
  }
  commit() {
  }
};

// src/context/debug/spector.ts
var import_core15 = require("@luma.gl/core");
var DEFAULT_SPECTOR_PROPS = {
  spector: import_core15.log.get("spector") || import_core15.log.get("inspect")
};
var SPECTOR_CDN_URL = "https://spectorcdn.babylonjs.com/spector.bundle.js";
var LOG_LEVEL = 1;
var spector = null;
var initialized = false;
async function loadSpectorJS(props) {
  if (!globalThis.SPECTOR) {
    try {
      await (0, import_core15.loadScript)(SPECTOR_CDN_URL);
    } catch (error2) {
      import_core15.log.warn(String(error2));
    }
  }
}
function initializeSpectorJS(props) {
  props = { ...DEFAULT_SPECTOR_PROPS, ...props };
  if (!(props == null ? void 0 : props.spector)) {
    return null;
  }
  if (!spector && globalThis.SPECTOR) {
    import_core15.log.probe(LOG_LEVEL, "SPECTOR found and initialized")();
    spector = new globalThis.SPECTOR.Spector();
    if (globalThis.luma) {
      globalThis.luma.spector = spector;
    }
  }
  if (!spector) {
    return null;
  }
  if (!initialized) {
    initialized = true;
    spector.spyCanvases();
    spector == null ? void 0 : spector.onCaptureStarted.add((capture) => import_core15.log.info("Spector capture started:", capture)());
    spector == null ? void 0 : spector.onCapture.add((capture) => {
      import_core15.log.info("Spector capture complete:", capture)();
      spector == null ? void 0 : spector.getResultUI();
      spector == null ? void 0 : spector.resultView.display();
      spector == null ? void 0 : spector.resultView.addCapture(capture);
    });
  }
  if (props == null ? void 0 : props.canvas) {
    if (typeof props.spector === "string" && props.spector !== props.canvas.id) {
      return spector;
    }
    spector == null ? void 0 : spector.startCapture(props == null ? void 0 : props.canvas, 500);
    new Promise((resolve) => setTimeout(resolve, 2e3)).then((_) => {
      import_core15.log.info("Spector capture stopped after 2 seconds")();
      spector == null ? void 0 : spector.stopCapture();
    });
  }
  return spector;
}

// src/context/debug/webgl-developer-tools.ts
var import_core16 = require("@luma.gl/core");
var import_constants15 = require("@luma.gl/constants");
var import_env = require("@probe.gl/env");
var WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function getContextData2(gl) {
  gl.luma = gl.luma || {};
  return gl.luma;
}
async function loadWebGLDeveloperTools() {
  if ((0, import_env.isBrowser)() && !globalThis.WebGLDebugUtils) {
    globalThis.global = globalThis.global || globalThis;
    globalThis.global.module = {};
    await (0, import_core16.loadScript)(WEBGL_DEBUG_CDN_URL);
  }
}
function makeDebugContext(gl, props = {}) {
  if (!gl) {
    return null;
  }
  return props.debug ? getDebugContext(gl, props) : getRealContext(gl);
}
function getRealContext(gl) {
  const data = getContextData2(gl);
  return data.realContext ? data.realContext : gl;
}
function getDebugContext(gl, props) {
  if (!globalThis.WebGLDebugUtils) {
    import_core16.log.warn("webgl-debug not loaded")();
    return gl;
  }
  const data = getContextData2(gl);
  if (data.debugContext) {
    return data.debugContext;
  }
  globalThis.WebGLDebugUtils.init({ ...import_constants15.GL, ...gl });
  const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(
    gl,
    onGLError.bind(null, props),
    onValidateGLFunc.bind(null, props)
  );
  for (const key in import_constants15.GL) {
    if (!(key in glDebug) && typeof import_constants15.GL[key] === "number") {
      glDebug[key] = import_constants15.GL[key];
    }
  }
  class WebGLDebugContext {
  }
  Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
  Object.setPrototypeOf(WebGLDebugContext, glDebug);
  const debugContext = Object.create(WebGLDebugContext);
  data.realContext = gl;
  data.debugContext = debugContext;
  debugContext.debug = true;
  return debugContext;
}
function getFunctionString(functionName, functionArgs) {
  functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
  let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
  args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
  return `gl.${functionName}(${args})`;
}
function onGLError(props, err, functionName, args) {
  args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
  const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
  const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
  const glName = props.webgl2 ? "gl2" : "gl1";
  const message2 = `${errorMessage} in ${glName}.${functionName}(${functionArgs})`;
  import_core16.log.error(message2)();
  debugger;
  if (props.throwOnError) {
    throw new Error(message2);
  }
}
function onValidateGLFunc(props, functionName, functionArgs) {
  let functionString = "";
  if (import_core16.log.level >= 1) {
    functionString = getFunctionString(functionName, functionArgs);
    import_core16.log.log(1, functionString)();
  }
  if (props.break && props.break.length > 0) {
    functionString = functionString || getFunctionString(functionName, functionArgs);
    const isBreakpoint = props.break.every((breakOn) => functionString.indexOf(breakOn) !== -1);
    if (isBreakpoint) {
      debugger;
    }
  }
  for (const arg of functionArgs) {
    if (arg === void 0) {
      functionString = functionString || getFunctionString(functionName, functionArgs);
      if (props.throwOnError) {
        throw new Error(`Undefined argument: ${functionString}`);
      } else {
        import_core16.log.error(`Undefined argument: ${functionString}`)();
        debugger;
      }
    }
  }
}

// src/adapter/resources/webgl-shader.ts
var import_core17 = require("@luma.gl/core");
var import_constants16 = require("@luma.gl/constants");

// src/adapter/helpers/parse-shader-compiler-log.ts
function parseShaderCompilerLog(errLog) {
  const lines = errLog.split(/\r?\n/);
  const messages = [];
  for (const line of lines) {
    if (line.length <= 1) {
      continue;
    }
    const segments = line.split(":");
    if (segments.length === 2) {
      const [messageType2, message2] = segments;
      messages.push({
        message: message2.trim(),
        type: getMessageType(messageType2),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [messageType, linePosition, lineNumber, ...rest] = segments;
    let lineNum = parseInt(lineNumber, 10);
    if (isNaN(lineNum)) {
      lineNum = 0;
    }
    let linePos = parseInt(linePosition, 10);
    if (isNaN(linePos)) {
      linePos = 0;
    }
    messages.push({
      message: rest.join(":").trim(),
      type: getMessageType(messageType),
      lineNum,
      linePos
      // TODO
    });
  }
  return messages;
}
function getMessageType(messageType) {
  const MESSAGE_TYPES = ["warning", "error", "info"];
  const lowerCaseType = messageType.toLowerCase();
  return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
}

// src/adapter/resources/webgl-shader.ts
var WEBGLShader = class extends import_core17.Shader {
  device;
  handle;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    switch (this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(import_constants16.GL.VERTEX_SHADER);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(import_constants16.GL.FRAGMENT_SHADER);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    if (this.handle) {
      this.removeStats();
      this.device.gl.deleteShader(this.handle);
      this.destroyed = true;
    }
  }
  async getCompilationInfo() {
    return this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const log9 = this.device.gl.getShaderInfoLog(this.handle);
    return parseShaderCompilerLog(log9);
  }
  // PRIVATE METHODS
  _compile(source) {
    const addGLSLVersion = (source2) => source2.startsWith("#version ") ? source2 : `#version 100
${source2}`;
    source = addGLSLVersion(source);
    const { gl } = this.device;
    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);
    this.compilationStatus = gl.getShaderParameter(this.handle, import_constants16.GL.COMPILE_STATUS) ? "success" : "error";
    this.debugShader();
    if (this.compilationStatus === "error") {
      throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
    }
  }
};

// src/adapter/resources/webgl-render-pass.ts
var import_core18 = require("@luma.gl/core");
var import_constants17 = require("@luma.gl/constants");
var GL_DEPTH_BUFFER_BIT = 256;
var GL_STENCIL_BUFFER_BIT = 1024;
var GL_COLOR_BUFFER_BIT = 16384;
var GL_COLOR = 6144;
var WEBGLRenderPass = class extends import_core18.RenderPass {
  device;
  /** Parameters that should be applied before each draw call */
  glParameters;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    pushContextState(this.device.gl);
    this.setParameters(this.props.parameters);
    this.clear();
  }
  end() {
    popContextState(this.device.gl);
    if (this.props.framebuffer) {
      setGLParameters(this.device, { framebuffer: null });
    }
  }
  pushDebugGroup(groupLabel) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(markerLabel) {
  }
  // writeTimestamp(querySet: GPUQuerySet, queryIndex: number): void;
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(parameters = {}) {
    const glParameters = {};
    if (this.props.framebuffer) {
      glParameters.framebuffer = this.props.framebuffer;
    }
    if (this.props.depthReadOnly) {
      glParameters.depthMask = !this.props.depthReadOnly;
    }
    glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
    glParameters[import_constants17.GL.RASTERIZER_DISCARD] = this.props.discard;
    if (parameters.viewport) {
      if (parameters.viewport.length >= 6) {
        glParameters.viewport = parameters.viewport.slice(0, 4);
        glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];
      } else {
        glParameters.viewport = parameters.viewport;
      }
    }
    glParameters.scissorTest = Boolean(parameters.scissorRect);
    if (parameters.scissorRect) {
      glParameters.scissor = parameters.scissorRect;
    }
    if (parameters.blendConstant) {
      glParameters.blendColor = parameters.blendConstant;
    }
    if (parameters.stencilReference) {
      console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
      parameters[import_constants17.GL.STENCIL_REF] = parameters.stencilReference;
    }
    this.glParameters = glParameters;
    setGLParameters(this.device, glParameters);
  }
  // Internal
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const glParameters = { ...this.glParameters };
    let clearMask = 0;
    if (this.props.clearColor !== false) {
      clearMask |= GL_COLOR_BUFFER_BIT;
      glParameters.clearColor = this.props.clearColor;
    }
    if (this.props.clearDepth !== false) {
      clearMask |= GL_DEPTH_BUFFER_BIT;
      glParameters.clearDepth = this.props.clearDepth;
    }
    if (this.props.clearStencil !== false) {
      clearMask |= GL_STENCIL_BUFFER_BIT;
      glParameters.clearStencil = this.props.clearStencil;
    }
    if (clearMask !== 0) {
      withGLParameters(this.device, glParameters, () => {
        this.device.gl.clear(clearMask);
      });
    }
  }
  /** 
   * WebGL2 - clear a specific color buffer 
   */
  clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
    withGLParameters(this.device.gl2, { framebuffer: this.props.framebuffer }, () => {
      switch (value.constructor) {
        case Int32Array:
          this.device.gl2.clearBufferiv(GL_COLOR, drawBuffer, value);
          break;
        case Uint32Array:
          this.device.gl2.clearBufferuiv(GL_COLOR, drawBuffer, value);
          break;
        case Float32Array:
        default:
          this.device.gl2.clearBufferfv(GL_COLOR, drawBuffer, value);
          break;
      }
    });
  }
  // clearDepthStencil() {
  // const GL_DEPTH = 0x1801;
  // const GL_STENCIL = 0x1802;
  // const GL_DEPTH_STENCIL = 0x84f9;
  //     case GL_DEPTH:
  //       this.device.gl2.clearBufferfv(GL_DEPTH, 0, [value]);
  //       break;
  //     case GL_STENCIL:
  //       this.device.gl2.clearBufferiv(GL_STENCIL, 0, [value]);
  //       break;
  //     case GL_DEPTH_STENCIL:
  //       const [depth, stencil] = value;
  //       this.device.gl2.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
  //       break;
  //     default:
  //       assert(false, ERR_ARGUMENTS);
  //   }
  // });
};

// src/adapter/resources/webgl-render-pipeline.ts
var import_core20 = require("@luma.gl/core");
var import_core21 = require("@luma.gl/core");
var import_constants24 = require("@luma.gl/constants");

// src/adapter/helpers/get-shader-layout.ts
var import_constants21 = require("@luma.gl/constants");

// src/classic/accessor.ts
var import_core19 = require("@luma.gl/core");
var import_constants19 = require("@luma.gl/constants");

// src/classic/typed-array-utils.ts
var import_constants18 = require("@luma.gl/constants");
var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return import_constants18.GL.FLOAT;
    case Uint16Array:
      return import_constants18.GL.UNSIGNED_SHORT;
    case Uint32Array:
      return import_constants18.GL.UNSIGNED_INT;
    case Uint8Array:
      return import_constants18.GL.UNSIGNED_BYTE;
    case Uint8ClampedArray:
      return import_constants18.GL.UNSIGNED_BYTE;
    case Int8Array:
      return import_constants18.GL.BYTE;
    case Int16Array:
      return import_constants18.GL.SHORT;
    case Int32Array:
      return import_constants18.GL.INT;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType, options) {
  const { clamped = true } = options || {};
  switch (glType) {
    case import_constants18.GL.FLOAT:
      return Float32Array;
    case import_constants18.GL.UNSIGNED_SHORT:
    case import_constants18.GL.UNSIGNED_SHORT_5_6_5:
    case import_constants18.GL.UNSIGNED_SHORT_4_4_4_4:
    case import_constants18.GL.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case import_constants18.GL.UNSIGNED_INT:
      return Uint32Array;
    case import_constants18.GL.UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case import_constants18.GL.BYTE:
      return Int8Array;
    case import_constants18.GL.SHORT:
      return Int16Array;
    case import_constants18.GL.INT:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}

// src/classic/accessor.ts
var DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: import_constants19.GL.FLOAT,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
var PROP_CHECKS = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
var Accessor = class {
  offset;
  stride;
  type;
  size;
  divisor;
  normalized;
  integer;
  buffer;
  index;
  static getBytesPerElement(accessor) {
    const ArrayType = getTypedArrayFromGLType(accessor.type || import_constants19.GL.FLOAT);
    return ArrayType.BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(accessor) {
    (0, import_core19.assert)(accessor.size);
    const ArrayType = getTypedArrayFromGLType(accessor.type || import_constants19.GL.FLOAT);
    return ArrayType.BYTES_PER_ELEMENT * accessor.size;
  }
  // Combines (merges) a list of accessors. On top of default values
  // Usually [programAccessor, bufferAccessor, appAccessor]
  // All props will be set in the returned object.
  // TODO check for conflicts between values in the supplied accessors
  static resolve(...accessors) {
    return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
  }
  constructor(...accessors) {
    accessors.forEach((accessor) => this._assign(accessor));
    Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  // ACCESSORS
  // TODO - remove>
  get BYTES_PER_ELEMENT() {
    return Accessor.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return Accessor.getBytesPerVertex(this);
  }
  // PRIVATE
  // eslint-disable-next-line complexity, max-statements
  _assign(props = {}) {
    props = (0, import_core19.checkProps)("Accessor", props, PROP_CHECKS);
    if (props.type !== void 0) {
      this.type = props.type;
      if (props.type === import_constants19.GL.INT || props.type === import_constants19.GL.UNSIGNED_INT) {
        this.integer = true;
      }
    }
    if (props.size !== void 0) {
      this.size = props.size;
    }
    if (props.offset !== void 0) {
      this.offset = props.offset;
    }
    if (props.stride !== void 0) {
      this.stride = props.stride;
    }
    if (props.normalize !== void 0) {
      this.normalized = props.normalize;
    }
    if (props.normalized !== void 0) {
      this.normalized = props.normalized;
    }
    if (props.integer !== void 0) {
      this.integer = props.integer;
    }
    if (props.divisor !== void 0) {
      this.divisor = props.divisor;
    }
    if (props.buffer !== void 0) {
      this.buffer = props.buffer;
    }
    if (props.index !== void 0) {
      if (typeof props.index === "boolean") {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }
    if (props.instanced !== void 0) {
      this.divisor = props.instanced ? 1 : 0;
    }
    if (props.isInstanced !== void 0) {
      this.divisor = props.isInstanced ? 1 : 0;
    }
    if (this.offset === void 0)
      delete this.offset;
    if (this.stride === void 0)
      delete this.stride;
    if (this.type === void 0)
      delete this.type;
    if (this.size === void 0)
      delete this.size;
    if (this.divisor === void 0)
      delete this.divisor;
    if (this.normalized === void 0)
      delete this.normalized;
    if (this.integer === void 0)
      delete this.integer;
    if (this.buffer === void 0)
      delete this.buffer;
    if (this.index === void 0)
      delete this.index;
    return this;
  }
};

// src/adapter/helpers/decode-webgl-types.ts
var import_constants20 = require("@luma.gl/constants");
function isSamplerUniform(type) {
  return SAMPLER_TYPES.includes(type);
}
var SAMPLER_TYPES = [
  import_constants20.GL.SAMPLER_2D,
  import_constants20.GL.SAMPLER_CUBE,
  import_constants20.GL.SAMPLER_3D,
  import_constants20.GL.SAMPLER_2D_SHADOW,
  import_constants20.GL.SAMPLER_2D_ARRAY,
  import_constants20.GL.SAMPLER_2D_ARRAY_SHADOW,
  import_constants20.GL.SAMPLER_CUBE_SHADOW,
  import_constants20.GL.INT_SAMPLER_2D,
  import_constants20.GL.INT_SAMPLER_3D,
  import_constants20.GL.INT_SAMPLER_CUBE,
  import_constants20.GL.INT_SAMPLER_2D_ARRAY,
  import_constants20.GL.UNSIGNED_INT_SAMPLER_2D,
  import_constants20.GL.UNSIGNED_INT_SAMPLER_3D,
  import_constants20.GL.UNSIGNED_INT_SAMPLER_CUBE,
  import_constants20.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY
];
var COMPOSITE_GL_TYPES = {
  [import_constants20.GL.FLOAT]: [import_constants20.GL.FLOAT, 1, "float", "f32", "float32"],
  [import_constants20.GL.FLOAT_VEC2]: [import_constants20.GL.FLOAT, 2, "vec2", "vec2<f32>", "float32x2"],
  [import_constants20.GL.FLOAT_VEC3]: [import_constants20.GL.FLOAT, 3, "vec3", "vec3<f32>", "float32x3"],
  [import_constants20.GL.FLOAT_VEC4]: [import_constants20.GL.FLOAT, 4, "vec4", "vec4<f32>", "float32x4"],
  [import_constants20.GL.INT]: [import_constants20.GL.INT, 1, "int", "i32", "sint32"],
  [import_constants20.GL.INT_VEC2]: [import_constants20.GL.INT, 2, "ivec2", "vec2<i32>", "sint32x2"],
  [import_constants20.GL.INT_VEC3]: [import_constants20.GL.INT, 3, "ivec3", "vec3<i32>", "sint32x3"],
  [import_constants20.GL.INT_VEC4]: [import_constants20.GL.INT, 4, "ivec4", "vec4<i32>", "sint32x4"],
  [import_constants20.GL.UNSIGNED_INT]: [import_constants20.GL.UNSIGNED_INT, 1, "uint", "u32", "uint32"],
  [import_constants20.GL.UNSIGNED_INT_VEC2]: [import_constants20.GL.UNSIGNED_INT, 2, "uvec2", "vec2<u32>", "uint32x2"],
  [import_constants20.GL.UNSIGNED_INT_VEC3]: [import_constants20.GL.UNSIGNED_INT, 3, "uvec3", "vec3<u32>", "uint32x3"],
  [import_constants20.GL.UNSIGNED_INT_VEC4]: [import_constants20.GL.UNSIGNED_INT, 4, "uvec4", "vec4<u32>", "uint32x4"],
  [import_constants20.GL.BOOL]: [import_constants20.GL.FLOAT, 1, "bool", "f32", "float32"],
  [import_constants20.GL.BOOL_VEC2]: [import_constants20.GL.FLOAT, 2, "bvec2", "vec2<f32>", "float32x2"],
  [import_constants20.GL.BOOL_VEC3]: [import_constants20.GL.FLOAT, 3, "bvec3", "vec3<f32>", "float32x3"],
  [import_constants20.GL.BOOL_VEC4]: [import_constants20.GL.FLOAT, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  [import_constants20.GL.FLOAT_MAT2]: [import_constants20.GL.FLOAT, 8, "mat2", "mat2x2<f32>"],
  // 4
  [import_constants20.GL.FLOAT_MAT2x3]: [import_constants20.GL.FLOAT, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  [import_constants20.GL.FLOAT_MAT2x4]: [import_constants20.GL.FLOAT, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  [import_constants20.GL.FLOAT_MAT3x2]: [import_constants20.GL.FLOAT, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  [import_constants20.GL.FLOAT_MAT3]: [import_constants20.GL.FLOAT, 12, "mat3", "mat3x3<f32>"],
  // 9
  [import_constants20.GL.FLOAT_MAT3x4]: [import_constants20.GL.FLOAT, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  [import_constants20.GL.FLOAT_MAT4x2]: [import_constants20.GL.FLOAT, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  [import_constants20.GL.FLOAT_MAT4x3]: [import_constants20.GL.FLOAT, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  [import_constants20.GL.FLOAT_MAT4]: [import_constants20.GL.FLOAT, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function decodeGLUniformType(glUniformType) {
  const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];
  if (!typeAndSize) {
    throw new Error("uniform");
  }
  const [glType, components, , format] = typeAndSize;
  return { format, components, glType };
}
function decodeGLAttributeType(glAttributeType) {
  const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];
  if (!typeAndSize) {
    throw new Error("attribute");
  }
  const [, components, , shaderType, vertexFormat] = typeAndSize;
  const attributeType = shaderType;
  return { attributeType, vertexFormat, components };
}

// src/adapter/helpers/get-shader-layout.ts
function getShaderLayout(gl, program) {
  const shaderLayout = {
    attributes: [],
    bindings: []
  };
  shaderLayout.attributes = readAttributeDeclarations(gl, program);
  const uniformBlocks = readUniformBlocks(gl, program);
  for (const uniformBlock of uniformBlocks) {
    const uniforms2 = uniformBlock.uniforms.map((uniform) => ({
      name: uniform.name,
      format: uniform.format,
      byteOffset: uniform.byteOffset,
      byteStride: uniform.byteStride,
      arrayLength: uniform.arrayLength
    }));
    shaderLayout.bindings.push({
      type: "uniform",
      name: uniformBlock.name,
      location: uniformBlock.location,
      visibility: (uniformBlock.vertex ? 1 : 0) & (uniformBlock.fragment ? 2 : 0),
      minBindingSize: uniformBlock.byteLength,
      uniforms: uniforms2
    });
  }
  const uniforms = readUniformBindings(gl, program);
  let textureUnit = 0;
  for (const uniform of uniforms) {
    if (isSamplerUniform(uniform.type)) {
      const { viewDimension, sampleType } = getSamplerInfo(uniform.type);
      shaderLayout.bindings.push({
        type: "texture",
        name: uniform.name,
        location: textureUnit,
        viewDimension,
        sampleType
      });
      uniform.textureUnit = textureUnit;
      textureUnit += 1;
    }
  }
  if (uniforms.length) {
    shaderLayout.uniforms = uniforms;
  }
  const varyings = readVaryings(gl, program);
  if (varyings == null ? void 0 : varyings.length) {
    shaderLayout.varyings = varyings;
  }
  return shaderLayout;
}
function readAttributeDeclarations(gl, program) {
  const attributes = [];
  const count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let index = 0; index < count; index++) {
    const activeInfo = gl.getActiveAttrib(program, index);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const {
      name,
      type: compositeType
      /* , size*/
    } = activeInfo;
    const location = gl.getAttribLocation(program, name);
    if (location >= 0) {
      const { attributeType } = decodeGLAttributeType(compositeType);
      const stepMode = /instance/i.test(name) ? "instance" : "vertex";
      attributes.push({
        name,
        location,
        stepMode,
        type: attributeType
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  attributes.sort((a, b) => a.location - b.location);
  return attributes;
}
function readVaryings(gl, program) {
  if (!isWebGL2(gl)) {
    return [];
  }
  const gl2 = gl;
  const varyings = [];
  const count = gl.getProgramParameter(program, import_constants21.GL.TRANSFORM_FEEDBACK_VARYINGS);
  for (let location = 0; location < count; location++) {
    const activeInfo = gl2.getTransformFeedbackVarying(program, location);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const { name, type: compositeType, size } = activeInfo;
    const { glType, components } = decodeGLUniformType(compositeType);
    const accessor = new Accessor({ type: glType, size: size * components });
    const varying = { location, name, accessor };
    varyings.push(varying);
  }
  varyings.sort((a, b) => a.location - b.location);
  return varyings;
}
function readUniformBindings(gl, program) {
  const uniforms = [];
  const uniformCount = gl.getProgramParameter(program, import_constants21.GL.ACTIVE_UNIFORMS);
  for (let i = 0; i < uniformCount; i++) {
    const activeInfo = gl.getActiveUniform(program, i);
    if (!activeInfo) {
      throw new Error("activeInfo");
    }
    const { name: rawName, size, type } = activeInfo;
    const { name, isArray: isArray2 } = parseUniformName(rawName);
    let webglLocation = gl.getUniformLocation(program, name);
    const uniformInfo = {
      // WebGL locations are uniquely typed but just numbers
      location: webglLocation,
      name,
      size,
      type,
      isArray: isArray2
    };
    uniforms.push(uniformInfo);
    if (uniformInfo.size > 1) {
      for (let j = 0; j < uniformInfo.size; j++) {
        const elementName = `${name}[${j}]`;
        webglLocation = gl.getUniformLocation(program, elementName);
        const arrayElementUniformInfo = {
          ...uniformInfo,
          name: elementName,
          location: webglLocation
        };
        uniforms.push(arrayElementUniformInfo);
      }
    }
  }
  return uniforms;
}
function readUniformBlocks(gl, program) {
  if (!isWebGL2(gl)) {
    return [];
  }
  const gl2 = gl;
  const getBlockParameter = (blockIndex, pname) => gl2.getActiveUniformBlockParameter(program, blockIndex, pname);
  const uniformBlocks = [];
  const blockCount = gl2.getProgramParameter(program, import_constants21.GL.ACTIVE_UNIFORM_BLOCKS);
  for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
    const blockInfo = {
      name: gl2.getActiveUniformBlockName(program, blockIndex) || "",
      location: getBlockParameter(blockIndex, import_constants21.GL.UNIFORM_BLOCK_BINDING),
      byteLength: getBlockParameter(blockIndex, import_constants21.GL.UNIFORM_BLOCK_DATA_SIZE),
      vertex: getBlockParameter(blockIndex, import_constants21.GL.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
      fragment: getBlockParameter(blockIndex, import_constants21.GL.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
      uniformCount: getBlockParameter(blockIndex, import_constants21.GL.UNIFORM_BLOCK_ACTIVE_UNIFORMS),
      uniforms: []
    };
    const uniformIndices = getBlockParameter(blockIndex, import_constants21.GL.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES) || [];
    const uniformType = gl2.getActiveUniforms(program, uniformIndices, import_constants21.GL.UNIFORM_TYPE);
    const uniformArrayLength = gl2.getActiveUniforms(program, uniformIndices, import_constants21.GL.UNIFORM_SIZE);
    const uniformOffset = gl2.getActiveUniforms(program, uniformIndices, import_constants21.GL.UNIFORM_OFFSET);
    const uniformStride = gl2.getActiveUniforms(program, uniformIndices, import_constants21.GL.UNIFORM_ARRAY_STRIDE);
    for (let i = 0; i < blockInfo.uniformCount; ++i) {
      const activeInfo = gl2.getActiveUniform(program, uniformIndices[i]);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      blockInfo.uniforms.push({
        name: activeInfo.name,
        format: decodeGLUniformType(uniformType[i]).format,
        type: uniformType[i],
        arrayLength: uniformArrayLength[i],
        byteOffset: uniformOffset[i],
        byteStride: uniformStride[i]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    uniformBlocks.push(blockInfo);
  }
  uniformBlocks.sort((a, b) => a.location - b.location);
  return uniformBlocks;
}
var SAMPLER_UNIFORMS_GL_TO_GPU = {
  [import_constants21.GL.SAMPLER_2D]: ["2d", "float"],
  [import_constants21.GL.SAMPLER_CUBE]: ["cube", "float"],
  [import_constants21.GL.SAMPLER_3D]: ["3d", "float"],
  [import_constants21.GL.SAMPLER_2D_SHADOW]: ["3d", "depth"],
  [import_constants21.GL.SAMPLER_2D_ARRAY]: ["2d-array", "float"],
  [import_constants21.GL.SAMPLER_2D_ARRAY_SHADOW]: ["2d-array", "depth"],
  [import_constants21.GL.SAMPLER_CUBE_SHADOW]: ["cube", "float"],
  [import_constants21.GL.INT_SAMPLER_2D]: ["2d", "sint"],
  [import_constants21.GL.INT_SAMPLER_3D]: ["3d", "sint"],
  [import_constants21.GL.INT_SAMPLER_CUBE]: ["cube", "sint"],
  [import_constants21.GL.INT_SAMPLER_2D_ARRAY]: ["2d-array", "uint"],
  [import_constants21.GL.UNSIGNED_INT_SAMPLER_2D]: ["2d", "uint"],
  [import_constants21.GL.UNSIGNED_INT_SAMPLER_3D]: ["3d", "uint"],
  [import_constants21.GL.UNSIGNED_INT_SAMPLER_CUBE]: ["cube", "uint"],
  [import_constants21.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY]: ["2d-array", "uint"]
};
function getSamplerInfo(type) {
  const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
  if (!sampler) {
    throw new Error("sampler");
  }
  const [viewDimension, sampleType] = sampler;
  return { viewDimension, sampleType };
}
function parseUniformName(name) {
  if (name[name.length - 1] !== "]") {
    return {
      name,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches = UNIFORM_NAME_REGEXP.exec(name);
  if (!matches || matches.length < 2) {
    throw new Error(`Failed to parse GLSL uniform name ${name}`);
  }
  return {
    name: matches[1],
    length: matches[2] ? 1 : 0,
    isArray: Boolean(matches[2])
  };
}

// src/adapter/helpers/set-uniform.ts
var import_constants22 = require("@luma.gl/constants");
function setUniform(gl, location, type, value) {
  const gl2 = gl;
  let uniformValue = value;
  if (uniformValue === true) {
    uniformValue = 1;
  }
  if (uniformValue === false) {
    uniformValue = 0;
  }
  const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
  switch (type) {
    case import_constants22.GL.SAMPLER_2D:
    case import_constants22.GL.SAMPLER_CUBE:
    case import_constants22.GL.SAMPLER_3D:
    case import_constants22.GL.SAMPLER_2D_SHADOW:
    case import_constants22.GL.SAMPLER_2D_ARRAY:
    case import_constants22.GL.SAMPLER_2D_ARRAY_SHADOW:
    case import_constants22.GL.SAMPLER_CUBE_SHADOW:
    case import_constants22.GL.INT_SAMPLER_2D:
    case import_constants22.GL.INT_SAMPLER_3D:
    case import_constants22.GL.INT_SAMPLER_CUBE:
    case import_constants22.GL.INT_SAMPLER_2D_ARRAY:
    case import_constants22.GL.UNSIGNED_INT_SAMPLER_2D:
    case import_constants22.GL.UNSIGNED_INT_SAMPLER_3D:
    case import_constants22.GL.UNSIGNED_INT_SAMPLER_CUBE:
    case import_constants22.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY:
      if (typeof value !== "number") {
        throw new Error("samplers must be set to integers");
      }
      return gl.uniform1i(location, value);
    case import_constants22.GL.FLOAT:
      return gl.uniform1fv(location, arrayValue);
    case import_constants22.GL.FLOAT_VEC2:
      return gl.uniform2fv(location, arrayValue);
    case import_constants22.GL.FLOAT_VEC3:
      return gl.uniform3fv(location, arrayValue);
    case import_constants22.GL.FLOAT_VEC4:
      return gl.uniform4fv(location, arrayValue);
    case import_constants22.GL.INT:
      return gl.uniform1iv(location, arrayValue);
    case import_constants22.GL.INT_VEC2:
      return gl.uniform2iv(location, arrayValue);
    case import_constants22.GL.INT_VEC3:
      return gl.uniform3iv(location, arrayValue);
    case import_constants22.GL.INT_VEC4:
      return gl.uniform4iv(location, arrayValue);
    case import_constants22.GL.BOOL:
      return gl.uniform1iv(location, arrayValue);
    case import_constants22.GL.BOOL_VEC2:
      return gl.uniform2iv(location, arrayValue);
    case import_constants22.GL.BOOL_VEC3:
      return gl.uniform3iv(location, arrayValue);
    case import_constants22.GL.BOOL_VEC4:
      return gl.uniform4iv(location, arrayValue);
    case import_constants22.GL.UNSIGNED_INT:
      return gl2.uniform1uiv(location, arrayValue, 1);
    case import_constants22.GL.UNSIGNED_INT_VEC2:
      return gl2.uniform2uiv(location, arrayValue, 2);
    case import_constants22.GL.UNSIGNED_INT_VEC3:
      return gl2.uniform3uiv(location, arrayValue, 3);
    case import_constants22.GL.UNSIGNED_INT_VEC4:
      return gl2.uniform4uiv(location, arrayValue, 4);
    case import_constants22.GL.FLOAT_MAT2:
      return gl.uniformMatrix2fv(location, false, arrayValue);
    case import_constants22.GL.FLOAT_MAT3:
      return gl.uniformMatrix3fv(location, false, arrayValue);
    case import_constants22.GL.FLOAT_MAT4:
      return gl.uniformMatrix4fv(location, false, arrayValue);
    case import_constants22.GL.FLOAT_MAT2x3:
      return gl2.uniformMatrix2x3fv(location, false, arrayValue);
    case import_constants22.GL.FLOAT_MAT2x4:
      return gl2.uniformMatrix2x4fv(location, false, arrayValue);
    case import_constants22.GL.FLOAT_MAT3x2:
      return gl2.uniformMatrix3x2fv(location, false, arrayValue);
    case import_constants22.GL.FLOAT_MAT3x4:
      return gl2.uniformMatrix3x4fv(location, false, arrayValue);
    case import_constants22.GL.FLOAT_MAT4x2:
      return gl2.uniformMatrix4x2fv(location, false, arrayValue);
    case import_constants22.GL.FLOAT_MAT4x3:
      return gl2.uniformMatrix4x3fv(location, false, arrayValue);
  }
  throw new Error("Illegal uniform");
}

// src/adapter/helpers/webgl-topology-utils.ts
var import_constants23 = require("@luma.gl/constants");
function getGLDrawMode(topology) {
  switch (topology) {
    case "point-list":
      return import_constants23.GL.POINTS;
    case "line-list":
      return import_constants23.GL.LINES;
    case "line-strip":
      return import_constants23.GL.LINE_STRIP;
    case "line-loop-webgl":
      return import_constants23.GL.LINE_LOOP;
    case "triangle-list":
      return import_constants23.GL.TRIANGLES;
    case "triangle-strip":
      return import_constants23.GL.TRIANGLE_STRIP;
    case "triangle-fan-webgl":
      return import_constants23.GL.TRIANGLE_FAN;
    default:
      throw new Error(topology);
  }
}
function getGLPrimitive(topology) {
  switch (topology) {
    case "point-list":
      return import_constants23.GL.POINTS;
    case "line-list":
      return import_constants23.GL.LINES;
    case "line-strip":
      return import_constants23.GL.LINES;
    case "line-loop-webgl":
      return import_constants23.GL.LINES;
    case "triangle-list":
      return import_constants23.GL.TRIANGLES;
    case "triangle-strip":
      return import_constants23.GL.TRIANGLES;
    case "triangle-fan-webgl":
      return import_constants23.GL.TRIANGLES;
    default:
      throw new Error(topology);
  }
}

// src/adapter/resources/webgl-render-pipeline.ts
var LOG_PROGRAM_PERF_PRIORITY = 4;
var WEBGLRenderPipeline = class extends import_core20.RenderPipeline {
  /** The WebGL device that created this render pipeline */
  device;
  /** Handle to underlying WebGL program */
  handle;
  /** vertex shader */
  vs;
  /** fragment shader */
  fs;
  /** The layout extracted from shader by WebGL introspection APIs */
  introspectedLayout;
  /** Uniforms set on this model */
  uniforms = {};
  /** Bindings set on this model */
  bindings = {};
  /** WebGL varyings */
  varyings = null;
  _uniformCount = 0;
  _uniformSetters = {};
  // TODO are these used?
  constructor(device, props) {
    var _a;
    super(device, props);
    this.device = device;
    this.handle = this.props.handle || this.device.gl.createProgram();
    this.device.setSpectorMetadata(this.handle, { id: this.props.id });
    this.vs = (0, import_core20.cast)(props.vs);
    this.fs = (0, import_core20.cast)(props.fs);
    const { varyings, bufferMode = import_constants24.GL.SEPARATE_ATTRIBS } = props;
    if (varyings && varyings.length > 0) {
      this.device.assertWebGL2();
      this.varyings = varyings;
      (_a = this.device.gl2) == null ? void 0 : _a.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }
    this._compileAndLink();
    this.introspectedLayout = getShaderLayout(this.device.gl, this.handle);
    this.shaderLayout = (0, import_core21.mergeShaderLayout)(this.introspectedLayout, props.shaderLayout);
    switch (this.props.topology) {
      case "triangle-fan-webgl":
      case "line-loop-webgl":
        import_core20.log.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
        break;
      default:
    }
  }
  destroy() {
    if (this.handle) {
      this.device.gl.deleteProgram(this.handle);
      this.destroyed = true;
    }
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(bindings) {
    for (const [name, value] of Object.entries(bindings)) {
      const binding = this.shaderLayout.bindings.find((binding2) => binding2.name === name) || this.shaderLayout.bindings.find((binding2) => binding2.name === `${name}Uniforms`);
      if (!binding) {
        const validBindings = this.shaderLayout.bindings.map((binding2) => `"${binding2.name}"`).join(", ");
        import_core20.log.warn(
          `Unknown binding "${name}" in render pipeline "${this.id}", expected one of ${validBindings}`
        )();
        continue;
      }
      if (!value) {
        import_core20.log.warn(`Unsetting binding "${name}" in render pipeline "${this.id}"`)();
      }
      switch (binding.type) {
        case "uniform":
          if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
            throw new Error("buffer value");
          }
          break;
        case "texture":
          if (!(value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error("texture value");
          }
          break;
        case "sampler":
          import_core20.log.warn(`Ignoring sampler ${name}`)();
          break;
        default:
          throw new Error(binding.type);
      }
      this.bindings[name] = value;
    }
  }
  /** This function is @deprecated, use uniform buffers */
  setUniforms(uniforms) {
    const { bindings } = (0, import_core20.splitUniformsAndBindings)(uniforms);
    Object.keys(bindings).forEach((name) => {
      import_core20.log.warn(
        `Unsupported value "${JSON.stringify(bindings[name])}" used in setUniforms() for key ${name}. Use setBindings() instead?`
      )();
    });
    Object.assign(this.uniforms, uniforms);
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(options) {
    var _a;
    const {
      renderPass,
      vertexArray,
      vertexCount,
      // indexCount,
      instanceCount,
      firstVertex = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback
    } = options;
    const glDrawMode = getGLDrawMode(this.props.topology);
    const isIndexed = Boolean(vertexArray.indexBuffer);
    const glIndexType = (_a = vertexArray.indexBuffer) == null ? void 0 : _a.glIndexType;
    const isInstanced = Number(instanceCount) > 0;
    if (!this._areTexturesRenderable() || vertexCount === 0) {
      return false;
    }
    this.device.gl.useProgram(this.handle);
    vertexArray.bindBeforeRender(renderPass);
    if (transformFeedback) {
      transformFeedback.begin(this.props.topology);
    }
    this._applyBindings();
    this._applyUniforms();
    const webglRenderPass = renderPass;
    withDeviceAndGLParameters(
      this.device,
      this.props.parameters,
      webglRenderPass.glParameters,
      () => {
        var _a2, _b;
        if (isIndexed && isInstanced) {
          (_a2 = this.device.gl2) == null ? void 0 : _a2.drawElementsInstanced(
            glDrawMode,
            vertexCount || 0,
            // indexCount?
            glIndexType,
            firstVertex,
            instanceCount || 0
          );
        } else if (isIndexed) {
          this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
        } else if (isInstanced) {
          (_b = this.device.gl2) == null ? void 0 : _b.drawArraysInstanced(
            glDrawMode,
            firstVertex,
            vertexCount || 0,
            instanceCount || 0
          );
        } else {
          this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
        }
        if (transformFeedback) {
          transformFeedback.end();
        }
      }
    );
    vertexArray.unbindAfterRender(renderPass);
    return true;
  }
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  _compileAndLink() {
    const { gl } = this.device;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    import_core20.log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    gl.linkProgram(this.handle);
    import_core20.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    if (!gl.debug && import_core20.log.level === 0) {
    }
    const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);
    if (!linked) {
      throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);
    }
    gl.validateProgram(this.handle);
    const validated = gl.getProgramParameter(this.handle, gl.VALIDATE_STATUS);
    if (!validated) {
      throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);
    }
  }
  // PRIVATE METHODS
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let texturesRenderable = true;
    for (const [, texture] of Object.entries(this.bindings)) {
      if (texture instanceof WEBGLTexture) {
        texture.update();
        texturesRenderable = texturesRenderable && texture.loaded;
      }
    }
    return texturesRenderable;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    this.device.gl.useProgram(this.handle);
    const { gl2 } = this.device;
    if (!gl2) {
      throw new Error("bindings");
    }
    let textureUnit = 0;
    let uniformBufferIndex = 0;
    for (const binding of this.shaderLayout.bindings) {
      const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
      if (!value) {
        throw new Error(`No value for binding ${binding.name} in ${this.id}`);
      }
      switch (binding.type) {
        case "uniform":
          const { name } = binding;
          const location = gl2.getUniformBlockIndex(this.handle, name);
          if (location === import_constants24.GL.INVALID_INDEX) {
            throw new Error(`Invalid uniform block name ${name}`);
          }
          gl2.uniformBlockBinding(this.handle, uniformBufferIndex, location);
          if (value instanceof WEBGLBuffer) {
            gl2.bindBufferBase(import_constants24.GL.UNIFORM_BUFFER, uniformBufferIndex, value.handle);
          } else {
            gl2.bindBufferRange(
              import_constants24.GL.UNIFORM_BUFFER,
              uniformBufferIndex,
              // @ts-expect-error
              value.buffer.handle,
              // @ts-expect-error
              value.offset || 0,
              // @ts-expect-error
              value.size || value.buffer.byteLength - value.offset
            );
          }
          uniformBufferIndex += 1;
          break;
        case "texture":
          if (!(value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error("texture");
          }
          let texture;
          if (value instanceof WEBGLTexture) {
            texture = value;
          } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTexture) {
            import_core20.log.warn(
              "Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead"
            )();
            texture = value.colorAttachments[0];
          } else {
            throw new Error("No texture");
          }
          gl2.activeTexture(import_constants24.GL.TEXTURE0 + textureUnit);
          gl2.bindTexture(texture.target, texture.handle);
          textureUnit += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${binding.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const uniformLayout of this.shaderLayout.uniforms || []) {
      const { name, location, type, textureUnit } = uniformLayout;
      const value = this.uniforms[name] ?? textureUnit;
      if (value !== void 0) {
        setUniform(this.device.gl, location, type, value);
      }
    }
  }
};

// src/adapter/resources/webgl-command-encoder.ts
var import_core23 = require("@luma.gl/core");

// src/adapter/resources/webgl-command-buffer.ts
var import_core22 = require("@luma.gl/core");
var import_constants25 = require("@luma.gl/constants");
function cast2(value) {
  return value;
}
var WEBGLCommandBuffer = class extends import_core22.CommandBuffer {
  device;
  commands = [];
  constructor(device) {
    super(device, {});
    this.device = device;
  }
  submitCommands(commands = this.commands) {
    for (const command of commands) {
      switch (command.name) {
        case "copy-buffer-to-buffer":
          _copyBufferToBuffer(this.device, command.options);
          break;
        case "copy-buffer-to-texture":
          _copyBufferToTexture(this.device, command.options);
          break;
        case "copy-texture-to-buffer":
          _copyTextureToBuffer(this.device, command.options);
          break;
        case "copy-texture-to-texture":
          _copyTextureToTexture(this.device, command.options);
          break;
      }
    }
  }
};
function _copyBufferToBuffer(device, options) {
  const source = cast2(options.source);
  const destination = cast2(options.destination);
  const gl2 = device.assertWebGL2();
  if (gl2) {
    gl2.bindBuffer(import_constants25.GL.COPY_READ_BUFFER, source.handle);
    gl2.bindBuffer(import_constants25.GL.COPY_WRITE_BUFFER, destination.handle);
    gl2.copyBufferSubData(
      import_constants25.GL.COPY_READ_BUFFER,
      import_constants25.GL.COPY_WRITE_BUFFER,
      options.sourceOffset ?? 0,
      options.destinationOffset ?? 0,
      options.size
    );
    gl2.bindBuffer(import_constants25.GL.COPY_READ_BUFFER, null);
    gl2.bindBuffer(import_constants25.GL.COPY_WRITE_BUFFER, null);
  } else {
    throw new Error("copyBufferToBuffer not implemented in WebGL1");
  }
}
function _copyBufferToTexture(device, options) {
  throw new Error("Not implemented");
}
function _copyTextureToBuffer(device, options) {
  const {
    /** Texture to copy to/from. */
    source,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect = "all",
    /** Width to copy */
    width = options.source.width,
    /** Height to copy */
    height = options.source.height,
    depthOrArrayLayers = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin = [0, 0],
    /** Destination buffer */
    destination,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage
  } = options;
  if (aspect !== "all") {
    throw new Error("not supported");
  }
  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
    throw new Error("not implemented");
  }
  const gl2 = device.assertWebGL2();
  const { framebuffer, destroyFramebuffer } = getFramebuffer(source);
  try {
    const webglBuffer = destination;
    const sourceWidth = width || framebuffer.width;
    const sourceHeight = height || framebuffer.height;
    const sourceParams = getWebGLTextureParameters(framebuffer.texture.format, true);
    const sourceFormat = sourceParams.dataFormat;
    const sourceType = sourceParams.type;
    gl2.bindBuffer(import_constants25.GL.PIXEL_PACK_BUFFER, webglBuffer.handle);
    gl2.bindFramebuffer(import_constants25.GL.FRAMEBUFFER, framebuffer.handle);
    gl2.readPixels(
      origin[0],
      origin[1],
      sourceWidth,
      sourceHeight,
      sourceFormat,
      sourceType,
      byteOffset
    );
  } finally {
    gl2.bindBuffer(import_constants25.GL.PIXEL_PACK_BUFFER, null);
    gl2.bindFramebuffer(import_constants25.GL.FRAMEBUFFER, null);
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
}
function _copyTextureToTexture(device, options) {
  const {
    /** Texture to copy to/from. */
    source,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // mipLevel = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin = [0, 0],
    /** Texture to copy to/from. */
    destination
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = options;
  let {
    width = options.destination.width,
    height = options.destination.width
    // depthOrArrayLayers = 0
  } = options;
  const destinationMipmaplevel = 0;
  const destinationInternalFormat = import_constants25.GL.RGBA;
  const { framebuffer, destroyFramebuffer } = getFramebuffer(source);
  const [sourceX, sourceY] = origin;
  const isSubCopy = false;
  device.gl.bindFramebuffer(import_constants25.GL.FRAMEBUFFER, framebuffer.handle);
  let texture = null;
  let textureTarget;
  if (destination instanceof WEBGLTexture) {
    texture = destination;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    textureTarget = texture.destination;
  } else {
    throw new Error("whoops");
  }
  if (!isSubCopy) {
    device.gl.copyTexImage2D(
      textureTarget,
      destinationMipmaplevel,
      destinationInternalFormat,
      sourceX,
      sourceY,
      width,
      height,
      0
      /* border must be 0 */
    );
  } else {
  }
  if (texture) {
    texture.unbind();
  }
  if (destroyFramebuffer) {
    framebuffer.destroy();
  }
  return texture;
}
function getFramebuffer(source) {
  if (source instanceof import_core22.Texture) {
    const { width, height, id } = source;
    const framebuffer = source.device.createFramebuffer({
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [source]
    });
    return { framebuffer, destroyFramebuffer: true };
  }
  return { framebuffer: source, destroyFramebuffer: false };
}

// src/adapter/resources/webgl-command-encoder.ts
var WEBGLCommandEncoder = class extends import_core23.CommandEncoder {
  device;
  commandBuffer;
  constructor(device, props) {
    super(device, props);
    this.device = device;
    this.commandBuffer = new WEBGLCommandBuffer(device);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(options) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options });
  }
  copyBufferToTexture(options) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options });
  }
  copyTextureToBuffer(options) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options });
  }
  copyTextureToTexture(options) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options });
  }
  pushDebugGroup(groupLabel) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(markerLabel) {
  }
  // writeTimestamp(querySet: Query, queryIndex: number): void {}
  // resolveQuerySet(options: {
  //   querySet: GPUQuerySet,
  //   firstQuery: number,
  //   queryCount: number,
  //   destination: Buffer,
  //   destinationOffset?: number;
  // }): void;
};

// src/adapter/resources/webgl-vertex-array.ts
var import_core24 = require("@luma.gl/core");
var import_constants26 = require("@luma.gl/constants");
var import_env2 = require("@probe.gl/env");
var WEBGLVertexArray = class extends import_core24.VertexArray {
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  device;
  handle;
  /** Attribute 0 buffer constant */
  buffer = null;
  bufferValue = null;
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(device) {
    return device.info.type === "webgl2" || (0, import_env2.getBrowser)() === "Chrome";
  }
  // Create a VertexArray
  constructor(device, props) {
    super(device, props);
    this.device = device;
    this.handle = this.device.gl2.createVertexArray();
  }
  destroy() {
    var _a;
    super.destroy();
    if (this.buffer) {
      (_a = this.buffer) == null ? void 0 : _a.destroy();
    }
    if (this.handle) {
      this.device.gl2.deleteVertexArray(this.handle);
      this.handle = void 0;
    }
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   * 
   * @param elementBuffer 
   */
  setIndexBuffer(indexBuffer) {
    const buffer = indexBuffer;
    if (buffer && buffer.glTarget !== import_constants26.GL.ELEMENT_ARRAY_BUFFER) {
      throw new Error("Use .setBuffer()");
    }
    this.device.gl2.bindVertexArray(this.handle);
    this.device.gl2.bindBuffer(import_constants26.GL.ELEMENT_ARRAY_BUFFER, buffer ? buffer.handle : null);
    this.indexBuffer = buffer;
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(location, attributeBuffer) {
    const buffer = attributeBuffer;
    if (buffer.glTarget === import_constants26.GL.ELEMENT_ARRAY_BUFFER) {
      throw new Error("Use .setIndexBuffer()");
    }
    const { size, type, stride, offset, normalized, integer, divisor } = this._getAccessor(location);
    this.device.gl2.bindVertexArray(this.handle);
    this.device.gl.bindBuffer(import_constants26.GL.ARRAY_BUFFER, buffer.handle);
    if (integer) {
      this.device.assertWebGL2();
      this.device.gl2.vertexAttribIPointer(location, size, type, stride, offset);
    } else {
      this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
    }
    this.device.gl.enableVertexAttribArray(location);
    this.device.gl2.vertexAttribDivisor(location, divisor || 0);
    this.attributes[location] = buffer;
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstant(location, value) {
    this._enable(location, false);
    this.attributes[location] = value;
  }
  init = false;
  bindBeforeRender() {
    this.device.gl2.bindVertexArray(this.handle);
    if (!this.init) {
      const webglBuffer = this.indexBuffer;
      this.device.gl2.bindBuffer(import_constants26.GL.ELEMENT_ARRAY_BUFFER, (webglBuffer == null ? void 0 : webglBuffer.handle) || null);
      this.init = true;
    }
    this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl2.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let location = 0; location < this.maxVertexAttributes; ++location) {
      const constant = this.attributes[location];
      if (ArrayBuffer.isView(constant)) {
        this.device.setConstantAttribute(location, constant);
      }
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.assertWebGL2();
  //     this.device.gl2.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl2.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(location) {
    const attributeInfo = this.attributeInfos[location];
    if (!attributeInfo) {
      throw new Error(`Unknown attribute location ${location}`);
    }
    const glType = getGLFromVertexType(attributeInfo.bufferDataType);
    return {
      size: attributeInfo.bufferComponents,
      type: glType,
      stride: attributeInfo.byteStride,
      offset: attributeInfo.byteOffset,
      normalized: attributeInfo.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: attributeInfo.integer,
      divisor: attributeInfo.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(location, enable2 = true) {
    const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
    const canDisableAttribute = canDisableAttributeZero || location !== 0;
    if (enable2 || canDisableAttribute) {
      location = Number(location);
      this.device.gl2.bindVertexArray(this.handle);
      if (enable2) {
        this.device.gl.enableVertexAttribArray(location);
      } else {
        this.device.gl.disableVertexAttribArray(location);
      }
      this.device.gl2.bindVertexArray(null);
    }
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(elementCount, value) {
    const constantValue = normalizeConstantArrayValue(value);
    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    if (this.buffer && byteLength !== this.buffer.byteLength) {
      throw new Error(
        `Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`
      );
    }
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || this.device.createBuffer({ byteLength });
    updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);
    if (updateNeeded) {
      const typedArray = (0, import_core24.getScratchArray)(value.constructor, length);
      (0, import_core24.fillArray)({ target: typedArray, source: constantValue, start: 0, count: length });
      this.buffer.write(typedArray);
      this.bufferValue = value;
    }
    return this.buffer;
  }
};
function normalizeConstantArrayValue(arrayValue) {
  if (Array.isArray(arrayValue)) {
    return new Float32Array(arrayValue);
  }
  return arrayValue;
}
function compareConstantArrayValues(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i = 0; i < v1.length; ++i) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
}

// src/adapter/resources/webgl-transform-feedback.ts
var import_core25 = require("@luma.gl/core");
var import_constants27 = require("@luma.gl/constants");
var WEBGLTransformFeedback = class extends import_core25.TransformFeedback {
  device;
  gl2;
  handle;
  /**
   * NOTE: The Model already has this information while drawing, but
   * TransformFeedback currently needs it internally, to look up
   * varying information outside of a draw() call.
   */
  layout;
  buffers = {};
  unusedBuffers = {};
  /**
   * Allows us to avoid a Chrome bug where a buffer that is already bound to a
   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
   */
  bindOnUse = true;
  _bound = false;
  constructor(device, props) {
    super(device, props);
    device.assertWebGL2();
    this.device = device;
    this.gl2 = device.gl2;
    this.handle = this.props.handle || this.gl2.createTransformFeedback();
    this.layout = this.props.layout;
    if (props.buffers) {
      this.setBuffers(props.buffers);
    }
    Object.seal(this);
  }
  destroy() {
    this.gl2.deleteTransformFeedback(this.handle);
    super.destroy();
  }
  begin(topology = "point-list") {
    this.gl2.bindTransformFeedback(import_constants27.GL.TRANSFORM_FEEDBACK, this.handle);
    if (this.bindOnUse) {
      this._bindBuffers();
    }
    this.gl2.beginTransformFeedback(getGLPrimitive(topology));
  }
  end() {
    this.gl2.endTransformFeedback();
    if (!this.bindOnUse) {
      this._unbindBuffers();
    }
    this.gl2.bindTransformFeedback(import_constants27.GL.TRANSFORM_FEEDBACK, null);
  }
  // SUBCLASS
  setBuffers(buffers) {
    this.buffers = {};
    this.unusedBuffers = {};
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
  }
  setBuffer(locationOrName, bufferOrRange) {
    const location = this._getVaryingIndex(locationOrName);
    const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
    if (location < 0) {
      this.unusedBuffers[locationOrName] = buffer;
      import_core25.log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
      return;
    }
    this.buffers[location] = { buffer, byteLength, byteOffset };
    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteLength);
    }
  }
  getBuffer(locationOrName) {
    if (isIndex(locationOrName)) {
      return this.buffers[locationOrName] || null;
    }
    const location = this._getVaryingIndex(locationOrName);
    return location >= 0 ? this.buffers[location] : null;
  }
  bind(funcOrHandle = this.handle) {
    if (typeof funcOrHandle !== "function") {
      this.gl2.bindTransformFeedback(import_constants27.GL.TRANSFORM_FEEDBACK, funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this.gl2.bindTransformFeedback(import_constants27.GL.TRANSFORM_FEEDBACK, this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this.gl2.bindTransformFeedback(import_constants27.GL.TRANSFORM_FEEDBACK, null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(bufferOrRange) {
    if (bufferOrRange instanceof WEBGLBuffer) {
      return { buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength };
    }
    const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
    return { buffer, byteOffset, byteLength };
  }
  _getVaryingIndex(locationOrName) {
    if (isIndex(locationOrName)) {
      return Number(locationOrName);
    }
    for (const varying of this.layout.varyings) {
      if (locationOrName === varying.name) {
        return varying.location;
      }
    }
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const bufferIndex in this.buffers) {
      const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
      this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
    }
  }
  _unbindBuffers() {
    for (const bufferIndex in this.buffers) {
      this.gl2.bindBufferBase(import_constants27.GL.TRANSFORM_FEEDBACK_BUFFER, Number(bufferIndex), null);
    }
  }
  _bindBuffer(index, buffer, byteOffset = 0, byteLength) {
    const handle = buffer && buffer.handle;
    if (!handle || byteLength === void 0) {
      this.gl2.bindBufferBase(import_constants27.GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);
    } else {
      this.gl2.bindBufferRange(import_constants27.GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteLength);
    }
  }
};
function isIndex(value) {
  if (typeof value === "number") {
    return Number.isInteger(value);
  }
  return /^\d+$/.test(value);
}

// src/classic/copy-and-blit.ts
var import_core27 = require("@luma.gl/core");
var import_constants29 = require("@luma.gl/constants");

// src/classic/format-utils.ts
var import_core26 = require("@luma.gl/core");
var import_constants28 = require("@luma.gl/constants");
function glFormatToComponents(format) {
  switch (format) {
    case import_constants28.GL.ALPHA:
    case import_constants28.GL.R32F:
    case import_constants28.GL.RED:
      return 1;
    case import_constants28.GL.RG32F:
    case import_constants28.GL.RG:
      return 2;
    case import_constants28.GL.RGB:
    case import_constants28.GL.RGB32F:
      return 3;
    case import_constants28.GL.RGBA:
    case import_constants28.GL.RGBA32F:
      return 4;
    default:
      (0, import_core26.assert)(false);
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case import_constants28.GL.UNSIGNED_BYTE:
      return 1;
    case import_constants28.GL.UNSIGNED_SHORT_5_6_5:
    case import_constants28.GL.UNSIGNED_SHORT_4_4_4_4:
    case import_constants28.GL.UNSIGNED_SHORT_5_5_5_1:
      return 2;
    case import_constants28.GL.FLOAT:
      return 4;
    default:
      (0, import_core26.assert)(false);
      return 0;
  }
}

// src/classic/copy-and-blit.ts
function readPixelsToArray(source, options) {
  var _a;
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = import_constants29.GL.RGBA,
    sourceAttachment = import_constants29.GL.COLOR_ATTACHMENT0
    // TODO - support gl.readBuffer
  } = options || {};
  let {
    target = null,
    // following parameters are auto deduced if not provided
    sourceWidth,
    sourceHeight,
    sourceType
  } = options || {};
  const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
  (0, import_core27.assert)(framebuffer);
  const { gl, handle } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const attachment = sourceAttachment - import_constants29.GL.COLOR_ATTACHMENT0;
  sourceType = sourceType || ((_a = framebuffer.colorAttachments[attachment]) == null ? void 0 : _a.type) || import_constants29.GL.UNSIGNED_BYTE;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || getGLTypeFromTypedArray(target);
  const prevHandle = gl.bindFramebuffer(import_constants29.GL.FRAMEBUFFER, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(import_constants29.GL.FRAMEBUFFER, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return target;
}
function readPixelsToBuffer(source, options) {
  const { target, sourceX = 0, sourceY = 0, sourceFormat = import_constants29.GL.RGBA, targetByteOffset = 0 } = options || {};
  let { sourceWidth, sourceHeight, sourceType } = options || {};
  const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
  (0, import_core27.assert)(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const webglFramebuffer = framebuffer;
  sourceType = sourceType || import_constants29.GL.UNSIGNED_BYTE;
  let webglBufferTarget = target;
  if (!webglBufferTarget) {
    const components = glFormatToComponents(sourceFormat);
    const byteCount = glTypeToBytes(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    webglBufferTarget = webglFramebuffer.device.createBuffer({ byteLength });
  }
  const commandEncoder = source.device.createCommandEncoder();
  commandEncoder.copyTextureToBuffer({
    source,
    width: sourceWidth,
    height: sourceHeight,
    origin: [sourceX, sourceY],
    destination: webglBufferTarget,
    byteOffset: targetByteOffset
  });
  commandEncoder.destroy();
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return webglBufferTarget;
}
function getFramebuffer2(source) {
  if (!(source instanceof import_core27.Framebuffer)) {
    return { framebuffer: toFramebuffer(source), deleteFramebuffer: true };
  }
  return { framebuffer: source, deleteFramebuffer: false };
}
function toFramebuffer(texture, props) {
  const { device, width, height, id } = texture;
  const framebuffer = device.createFramebuffer({
    ...props,
    id: `framebuffer-for-${id}`,
    width,
    height,
    colorAttachments: [texture]
  });
  return framebuffer;
}
function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  type = type || import_constants29.GL.UNSIGNED_BYTE;
  const ArrayType = getTypedArrayFromGLType(type, { clamped: false });
  const components = glFormatToComponents(format);
  return new ArrayType(width * height * components);
}

// src/classic/clear.ts
var import_core28 = require("@luma.gl/core");
var GL_DEPTH_BUFFER_BIT2 = 256;
var GL_STENCIL_BUFFER_BIT2 = 1024;
var GL_COLOR_BUFFER_BIT2 = 16384;
var ERR_ARGUMENTS = "clear: bad arguments";
function clear(gl, options) {
  const device = WebGLDevice.attach(gl);
  const { framebuffer = null, color = null, depth = null, stencil = null } = options || {};
  const parameters = {};
  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }
  let clearFlags = 0;
  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT2;
    if (color !== true) {
      parameters.clearColor = color;
    }
  }
  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT2;
    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }
  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT2;
    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }
  (0, import_core28.assert)(clearFlags !== 0, ERR_ARGUMENTS);
  withGLParameters(device.gl, parameters, () => {
    device.gl.clear(clearFlags);
  });
}

// src/adapter/webgl-device.ts
var LOG_LEVEL2 = 1;
var _WebGLDevice = class extends import_core29.Device {
  static isSupported() {
    return typeof WebGLRenderingContext !== "undefined" || isHeadlessGLRegistered();
  }
  info;
  canvasContext;
  handle;
  get features() {
    this._features = this._features || getDeviceFeatures(this.gl);
    return this._features;
  }
  get limits() {
    this._limits = this._limits || getDeviceLimits(this.gl);
    return this._limits;
  }
  lost;
  _resolveContextLost;
  _features;
  _limits;
  //
  // Static methods, expected to be present by `luma.createDevice()`
  //
  /**
   * Get a device instance from a GL context
   * Creates and instruments the device if not already created
   * @param gl
   * @returns
   */
  static attach(gl) {
    if (gl instanceof _WebGLDevice) {
      return gl;
    }
    if ((gl == null ? void 0 : gl.device) instanceof import_core29.Device) {
      return gl.device;
    }
    if (!isWebGL3(gl)) {
      throw new Error("Invalid WebGLRenderingContext");
    }
    return new _WebGLDevice({ gl });
  }
  static async create(props = {}) {
    import_core29.log.groupCollapsed(LOG_LEVEL2, "WebGLDevice created")();
    if (typeof props.canvas === "string") {
      await import_core29.CanvasContext.pageLoaded;
    }
    if (import_core29.log.get("debug") || props.debug) {
      await loadWebGLDeveloperTools();
    }
    const { spector: spector2 } = props;
    if (import_core29.log.get("spector") || spector2) {
      await loadSpectorJS();
    }
    import_core29.log.probe(LOG_LEVEL2 + 1, "DOM is loaded")();
    if (props.gl && props.gl.device) {
      return _WebGLDevice.attach(props.gl);
    }
    const device = new _WebGLDevice(props);
    const message2 = `Created ${device.info.type}${device.debug ? " debug" : ""} context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
    import_core29.log.probe(LOG_LEVEL2, message2)();
    import_core29.log.table(LOG_LEVEL2, device.info)();
    import_core29.log.groupEnd(LOG_LEVEL2)();
    return device;
  }
  //
  // Public API
  //
  constructor(props) {
    var _a, _b;
    super({ ...props, id: props.id || (0, import_core29.uid)("webgl-device") });
    const device = (_a = props.gl) == null ? void 0 : _a.device;
    if (device) {
      throw new Error(`WebGL context already attached to device ${device.id}`);
    }
    const canvas = props.canvas || ((_b = props.gl) == null ? void 0 : _b.canvas);
    this.canvasContext = new WebGLCanvasContext(this, { ...props, canvas });
    this.lost = new Promise((resolve) => {
      this._resolveContextLost = resolve;
    });
    const onContextLost = (event) => {
      var _a2;
      return (_a2 = this._resolveContextLost) == null ? void 0 : _a2.call(this, {
        reason: "destroyed",
        message: "Computer entered sleep mode, or too many apps or browser tabs are using the GPU."
      });
    };
    let gl = props.gl || null;
    gl = gl || ((0, import_env3.isBrowser)() ? createBrowserContext(this.canvasContext.canvas, { ...props, onContextLost }) : null);
    gl = gl || (!(0, import_env3.isBrowser)() ? createHeadlessContext({ ...props, onContextLost }) : null);
    if (!gl) {
      throw new Error("WebGL context creation failed");
    }
    this.handle = gl;
    this.gl = this.handle;
    this.gl2 = this.gl;
    this.isWebGL2 = isWebGL22(this.gl);
    this.isWebGL1 = !this.isWebGL2;
    this.canvasContext.resize();
    this.info = getDeviceInfo(this.gl);
    this.gl.device = this;
    this.gl._version = this.isWebGL2 ? 2 : 1;
    polyfillContext(this.gl);
    const { enable: enable2 = true, copyState = false } = props;
    trackContextState(this.gl, {
      enable: enable2,
      copyState,
      log: (...args) => import_core29.log.log(1, ...args)()
    });
    if ((0, import_env3.isBrowser)() && props.debug) {
      this.gl = makeDebugContext(this.gl, { ...props, webgl2: this.isWebGL2, throwOnError: true });
      this.gl2 = this.gl;
      this.debug = true;
      import_core29.log.level = Math.max(import_core29.log.level, 1);
      import_core29.log.warn("WebGL debug mode activated. Performance reduced.")();
    }
    if ((0, import_env3.isBrowser)() && props.spector) {
      const canvas2 = this.handle.canvas || props.canvas;
      this.spector = initializeSpectorJS({ ...this.props, canvas: canvas2 });
    }
  }
  /**
   * Destroys the context
   * @note Has no effect for browser contexts, there is no browser API for destroying contexts
   */
  destroy() {
    const ext = this.gl.getExtension("STACKGL_destroy_context");
    if (ext) {
      ext.destroy();
    }
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  getSize() {
    return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
  }
  isTextureFormatSupported(format) {
    return isTextureFormatSupported(this.gl, format);
  }
  isTextureFormatFilterable(format) {
    return isTextureFormatFilterable(this.gl, format);
  }
  isTextureFormatRenderable(format) {
    return isTextureFormatRenderable(this.gl, format);
  }
  // WEBGL SPECIFIC METHODS
  /** Returns a WebGL2RenderingContext or throws an error */
  assertWebGL2() {
    if (!this.gl2) {
      throw new Error("Requires WebGL2");
    }
    return this.gl2;
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(props) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(props) {
    const newProps = this._getBufferProps(props);
    return new WEBGLBuffer(this, newProps);
  }
  _createTexture(props) {
    return new WEBGLTexture(this, props);
  }
  createExternalTexture(props) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(props) {
    return new WEBGLSampler(this, props);
  }
  createShader(props) {
    return new WEBGLShader(this, props);
  }
  createFramebuffer(props) {
    return new WEBGLFramebuffer(this, props);
  }
  createRenderPipeline(props) {
    return new WEBGLRenderPipeline(this, props);
  }
  createVertexArray(props) {
    return new WEBGLVertexArray(this, props);
  }
  beginRenderPass(props) {
    return new WEBGLRenderPass(this, props);
  }
  createComputePipeline(props) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(props) {
    throw new Error("ComputePass not supported in WebGL");
  }
  createTransformFeedback(props) {
    return new WEBGLTransformFeedback(this, props);
  }
  renderPass = null;
  getDefaultRenderPass() {
    this.renderPass = this.renderPass || this.beginRenderPass({
      framebuffer: this.canvasContext.getCurrentFramebuffer()
    });
    return this.renderPass;
  }
  createCommandEncoder(props) {
    return new WEBGLCommandEncoder(this, props);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    var _a;
    (_a = this.renderPass) == null ? void 0 : _a.end();
    this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  // 
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(source, options) {
    return readPixelsToArray(source, options);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(source, options) {
    return readPixelsToBuffer(source, options);
  }
  setParametersWebGL(parameters) {
    setGLParameters(this, parameters);
  }
  getParametersWebGL(parameters) {
    return getGLParameters(this, parameters);
  }
  withParametersWebGL(parameters, func) {
    withGLParameters(this, parameters, func);
  }
  clearWebGL(options) {
    clear(this, options);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /** WebGL1 typed context. Can always be used. */
  gl;
  /** WebGL2 typed context. Need to check isWebGL2 or isWebGL1 before using. */
  gl2 = null;
  debug = false;
  /** `true` if this is a WebGL1 context. @note `false` if WebGL2 */
  isWebGL1;
  /** `true` if this is a WebGL2 context. @note `false` if WebGL1 */
  isWebGL2;
  /** State used by luma.gl classes: TODO - move to canvasContext*/
  _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
  /** State used by luma.gl classes - TODO - not used? */
  _extensions = {};
  _polyfilled = false;
  /** Instance of Spector.js (if initialized) */
  spector;
  _webglLimits;
  /** Return WebGL specific limits */
  get webglLimits() {
    this._webglLimits = this._webglLimits || getWebGLLimits(this.gl);
    return this._webglLimits;
  }
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    var _a;
    let deviceLossTriggered = false;
    const ext = this.gl.getExtension("WEBGL_lose_context");
    if (ext) {
      deviceLossTriggered = true;
      ext.loseContext();
    }
    (_a = this._resolveContextLost) == null ? void 0 : _a.call(this, {
      reason: "destroyed",
      message: "Application triggered context loss"
    });
    return deviceLossTriggered;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    pushContextState(this.gl);
  }
  /** Restores previously saved context state */
  popState() {
    popContextState(this.gl);
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(handle, props) {
    handle.__SPECTOR_Metadata = props;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(value, gl) {
    gl = gl || this.gl2 || this.gl;
    const number = Number(value);
    for (const key in gl) {
      if (gl[key] === number) {
        return `GL.${key}`;
      }
    }
    return String(value);
  }
  /** Store constants */
  _constants;
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttribute(location, constant) {
    this._constants = this._constants || new Array(this.limits.maxVertexAttributes).fill(null);
    const currentConstant = this._constants[location];
    if (currentConstant && compareConstantArrayValues2(currentConstant, constant)) {
      import_core29.log.info(1, `setConstantAttribute(${location}) could have been skipped, value unchanged`)();
    }
    this._constants[location] = constant;
    switch (constant.constructor) {
      case Float32Array:
        setConstantFloatArray(this, location, constant);
        break;
      case Int32Array:
        setConstantIntArray(this, location, constant);
        break;
      case Uint32Array:
        setConstantUintArray(this, location, constant);
        break;
      default:
        (0, import_core29.assert)(false);
    }
  }
};
var WebGLDevice = _WebGLDevice;
//
// Public `Device` API
//
__publicField(WebGLDevice, "type", "webgl");
function isWebGL3(gl) {
  if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL22(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function setConstantFloatArray(device, location, array) {
  switch (array.length) {
    case 1:
      device.gl.vertexAttrib1fv(location, array);
      break;
    case 2:
      device.gl.vertexAttrib2fv(location, array);
      break;
    case 3:
      device.gl.vertexAttrib3fv(location, array);
      break;
    case 4:
      device.gl.vertexAttrib4fv(location, array);
      break;
    default:
      (0, import_core29.assert)(false);
  }
}
function setConstantIntArray(device, location, array) {
  var _a;
  device.assertWebGL2();
  (_a = device.gl2) == null ? void 0 : _a.vertexAttribI4iv(location, array);
}
function setConstantUintArray(device, location, array) {
  var _a;
  device.assertWebGL2();
  (_a = device.gl2) == null ? void 0 : _a.vertexAttribI4uiv(location, array);
}
function compareConstantArrayValues2(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i = 0; i < v1.length; ++i) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
}
