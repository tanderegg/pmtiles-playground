import { isWebGL2 } from "../../context/context/webgl-checks.js";
import { Accessor } from "../../classic/accessor.js";
import { decodeGLUniformType, decodeGLAttributeType, isSamplerUniform } from "./decode-webgl-types.js";
export function getShaderLayout(gl, program) {
  const shaderLayout = {
    attributes: [],
    bindings: []
  };
  shaderLayout.attributes = readAttributeDeclarations(gl, program);
  const uniformBlocks = readUniformBlocks(gl, program);
  for (const uniformBlock of uniformBlocks) {
    const uniforms = uniformBlock.uniforms.map(uniform => ({
      name: uniform.name,
      format: uniform.format,
      byteOffset: uniform.byteOffset,
      byteStride: uniform.byteStride,
      arrayLength: uniform.arrayLength
    }));
    shaderLayout.bindings.push({
      type: 'uniform',
      name: uniformBlock.name,
      location: uniformBlock.location,
      visibility: (uniformBlock.vertex ? 0x1 : 0) & (uniformBlock.fragment ? 0x2 : 0),
      minBindingSize: uniformBlock.byteLength,
      uniforms
    });
  }
  const uniforms = readUniformBindings(gl, program);
  let textureUnit = 0;
  for (const uniform of uniforms) {
    if (isSamplerUniform(uniform.type)) {
      const {
        viewDimension,
        sampleType
      } = getSamplerInfo(uniform.type);
      shaderLayout.bindings.push({
        type: 'texture',
        name: uniform.name,
        location: textureUnit,
        viewDimension,
        sampleType
      });
      uniform.textureUnit = textureUnit;
      textureUnit += 1;
    }
  }
  if (uniforms.length) {
    shaderLayout.uniforms = uniforms;
  }
  const varyings = readVaryings(gl, program);
  if (varyings !== null && varyings !== void 0 && varyings.length) {
    shaderLayout.varyings = varyings;
  }
  return shaderLayout;
}
function readAttributeDeclarations(gl, program) {
  const attributes = [];
  const count = gl.getProgramParameter(program, 35721);
  for (let index = 0; index < count; index++) {
    const activeInfo = gl.getActiveAttrib(program, index);
    if (!activeInfo) {
      throw new Error('activeInfo');
    }
    const {
      name,
      type: compositeType
    } = activeInfo;
    const location = gl.getAttribLocation(program, name);
    if (location >= 0) {
      const {
        attributeType
      } = decodeGLAttributeType(compositeType);
      const stepMode = /instance/i.test(name) ? 'instance' : 'vertex';
      attributes.push({
        name,
        location,
        stepMode,
        type: attributeType
      });
    }
  }
  attributes.sort((a, b) => a.location - b.location);
  return attributes;
}
function readVaryings(gl, program) {
  if (!isWebGL2(gl)) {
    return [];
  }
  const gl2 = gl;
  const varyings = [];
  const count = gl.getProgramParameter(program, 35971);
  for (let location = 0; location < count; location++) {
    const activeInfo = gl2.getTransformFeedbackVarying(program, location);
    if (!activeInfo) {
      throw new Error('activeInfo');
    }
    const {
      name,
      type: compositeType,
      size
    } = activeInfo;
    const {
      glType,
      components
    } = decodeGLUniformType(compositeType);
    const accessor = new Accessor({
      type: glType,
      size: size * components
    });
    const varying = {
      location,
      name,
      accessor
    };
    varyings.push(varying);
  }
  varyings.sort((a, b) => a.location - b.location);
  return varyings;
}
function readUniformBindings(gl, program) {
  const uniforms = [];
  const uniformCount = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < uniformCount; i++) {
    const activeInfo = gl.getActiveUniform(program, i);
    if (!activeInfo) {
      throw new Error('activeInfo');
    }
    const {
      name: rawName,
      size,
      type
    } = activeInfo;
    const {
      name,
      isArray
    } = parseUniformName(rawName);
    let webglLocation = gl.getUniformLocation(program, name);
    const uniformInfo = {
      location: webglLocation,
      name,
      size,
      type,
      isArray
    };
    uniforms.push(uniformInfo);
    if (uniformInfo.size > 1) {
      for (let j = 0; j < uniformInfo.size; j++) {
        const elementName = `${name}[${j}]`;
        webglLocation = gl.getUniformLocation(program, elementName);
        const arrayElementUniformInfo = {
          ...uniformInfo,
          name: elementName,
          location: webglLocation
        };
        uniforms.push(arrayElementUniformInfo);
      }
    }
  }
  return uniforms;
}
function readUniformBlocks(gl, program) {
  if (!isWebGL2(gl)) {
    return [];
  }
  const gl2 = gl;
  const getBlockParameter = (blockIndex, pname) => gl2.getActiveUniformBlockParameter(program, blockIndex, pname);
  const uniformBlocks = [];
  const blockCount = gl2.getProgramParameter(program, 35382);
  for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
    const blockInfo = {
      name: gl2.getActiveUniformBlockName(program, blockIndex) || '',
      location: getBlockParameter(blockIndex, 35391),
      byteLength: getBlockParameter(blockIndex, 35392),
      vertex: getBlockParameter(blockIndex, 35396),
      fragment: getBlockParameter(blockIndex, 35398),
      uniformCount: getBlockParameter(blockIndex, 35394),
      uniforms: []
    };
    const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
    const uniformType = gl2.getActiveUniforms(program, uniformIndices, 35383);
    const uniformArrayLength = gl2.getActiveUniforms(program, uniformIndices, 35384);
    const uniformOffset = gl2.getActiveUniforms(program, uniformIndices, 35387);
    const uniformStride = gl2.getActiveUniforms(program, uniformIndices, 35388);
    for (let i = 0; i < blockInfo.uniformCount; ++i) {
      const activeInfo = gl2.getActiveUniform(program, uniformIndices[i]);
      if (!activeInfo) {
        throw new Error('activeInfo');
      }
      blockInfo.uniforms.push({
        name: activeInfo.name,
        format: decodeGLUniformType(uniformType[i]).format,
        type: uniformType[i],
        arrayLength: uniformArrayLength[i],
        byteOffset: uniformOffset[i],
        byteStride: uniformStride[i]
      });
    }
    uniformBlocks.push(blockInfo);
  }
  uniformBlocks.sort((a, b) => a.location - b.location);
  return uniformBlocks;
}
const SAMPLER_UNIFORMS_GL_TO_GPU = {
  [35678]: ['2d', 'float'],
  [35680]: ['cube', 'float'],
  [35679]: ['3d', 'float'],
  [35682]: ['3d', 'depth'],
  [36289]: ['2d-array', 'float'],
  [36292]: ['2d-array', 'depth'],
  [36293]: ['cube', 'float'],
  [36298]: ['2d', 'sint'],
  [36299]: ['3d', 'sint'],
  [36300]: ['cube', 'sint'],
  [36303]: ['2d-array', 'uint'],
  [36306]: ['2d', 'uint'],
  [36307]: ['3d', 'uint'],
  [36308]: ['cube', 'uint'],
  [36311]: ['2d-array', 'uint']
};
function getSamplerInfo(type) {
  const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
  if (!sampler) {
    throw new Error('sampler');
  }
  const [viewDimension, sampleType] = sampler;
  return {
    viewDimension,
    sampleType
  };
}
function parseUniformName(name) {
  if (name[name.length - 1] !== ']') {
    return {
      name,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches = UNIFORM_NAME_REGEXP.exec(name);
  if (!matches || matches.length < 2) {
    throw new Error(`Failed to parse GLSL uniform name ${name}`);
  }
  return {
    name: matches[1],
    length: matches[2] ? 1 : 0,
    isArray: Boolean(matches[2])
  };
}
//# sourceMappingURL=get-shader-layout.js.map