import type { DeviceProps, DeviceInfo, DeviceLimits, DeviceFeature, CanvasContextProps, TextureFormat, VertexArray, VertexArrayProps, Framebuffer, Buffer, Texture, TypedArray } from '@luma.gl/core';
import { Device, CanvasContext } from '@luma.gl/core';
import { WebGLLimits } from './device-helpers/device-limits';
import { WebGLCanvasContext } from './webgl-canvas-context';
import type { BufferProps, ShaderProps, SamplerProps, TextureProps, ExternalTexture, ExternalTextureProps, FramebufferProps, RenderPipelineProps, ComputePipeline, ComputePipelineProps, RenderPassProps, ComputePass, ComputePassProps, CommandEncoderProps, TransformFeedbackProps } from '@luma.gl/core';
import { WEBGLBuffer } from './resources/webgl-buffer';
import { WEBGLShader } from './resources/webgl-shader';
import { WEBGLSampler } from './resources/webgl-sampler';
import { WEBGLTexture } from './resources/webgl-texture';
import { WEBGLFramebuffer } from './resources/webgl-framebuffer';
import { WEBGLRenderPass } from './resources/webgl-render-pass';
import { WEBGLRenderPipeline } from './resources/webgl-render-pipeline';
import { WEBGLCommandEncoder } from './resources/webgl-command-encoder';
import { WEBGLTransformFeedback } from './resources/webgl-transform-feedback';
/** WebGPU style Device API for a WebGL context */
export declare class WebGLDevice extends Device {
    static type: string;
    static isSupported(): boolean;
    readonly info: DeviceInfo;
    readonly canvasContext: WebGLCanvasContext;
    readonly handle: WebGLRenderingContext;
    get features(): Set<DeviceFeature>;
    get limits(): DeviceLimits;
    readonly lost: Promise<{
        reason: 'destroyed';
        message: string;
    }>;
    private _resolveContextLost?;
    private _features?;
    private _limits?;
    /**
     * Get a device instance from a GL context
     * Creates and instruments the device if not already created
     * @param gl
     * @returns
     */
    static attach(gl: Device | WebGLRenderingContext | WebGL2RenderingContext): WebGLDevice;
    static create(props?: DeviceProps): Promise<WebGLDevice>;
    constructor(props: DeviceProps);
    /**
     * Destroys the context
     * @note Has no effect for browser contexts, there is no browser API for destroying contexts
     */
    destroy(): void;
    get isLost(): boolean;
    getSize(): [number, number];
    isTextureFormatSupported(format: TextureFormat): boolean;
    isTextureFormatFilterable(format: TextureFormat): boolean;
    isTextureFormatRenderable(format: TextureFormat): boolean;
    /** Returns a WebGL2RenderingContext or throws an error */
    assertWebGL2(): WebGL2RenderingContext;
    createCanvasContext(props?: CanvasContextProps): CanvasContext;
    createBuffer(props: BufferProps | ArrayBuffer | ArrayBufferView): WEBGLBuffer;
    _createTexture(props: TextureProps): WEBGLTexture;
    createExternalTexture(props: ExternalTextureProps): ExternalTexture;
    createSampler(props: SamplerProps): WEBGLSampler;
    createShader(props: ShaderProps): WEBGLShader;
    createFramebuffer(props: FramebufferProps): WEBGLFramebuffer;
    createRenderPipeline(props: RenderPipelineProps): WEBGLRenderPipeline;
    createVertexArray(props: VertexArrayProps): VertexArray;
    beginRenderPass(props: RenderPassProps): WEBGLRenderPass;
    createComputePipeline(props?: ComputePipelineProps): ComputePipeline;
    beginComputePass(props: ComputePassProps): ComputePass;
    createTransformFeedback(props: TransformFeedbackProps): WEBGLTransformFeedback;
    private renderPass;
    getDefaultRenderPass(): WEBGLRenderPass;
    createCommandEncoder(props?: CommandEncoderProps): WEBGLCommandEncoder;
    /**
     * Offscreen Canvas Support: Commit the frame
     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/commit
     * Chrome's offscreen canvas does not require gl.commit
     */
    submit(): void;
    /** @deprecated - should use command encoder */
    readPixelsToArrayWebGL(source: Framebuffer | Texture, options?: {
        sourceX?: number;
        sourceY?: number;
        sourceFormat?: number;
        sourceAttachment?: number;
        target?: Uint8Array | Uint16Array | Float32Array;
        sourceWidth?: number;
        sourceHeight?: number;
        sourceType?: number;
    }): Uint8Array | Uint16Array | Float32Array;
    /** @deprecated - should use command encoder */
    readPixelsToBufferWebGL(source: Framebuffer | Texture, options?: {
        sourceX?: number;
        sourceY?: number;
        sourceFormat?: number;
        target?: Buffer;
        targetByteOffset?: number;
        sourceWidth?: number;
        sourceHeight?: number;
        sourceType?: number;
    }): Buffer;
    setParametersWebGL(parameters: any): void;
    getParametersWebGL(parameters: any): any;
    withParametersWebGL(parameters: any, func: any): any;
    clearWebGL(options?: {
        framebuffer?: Framebuffer;
        color?: any;
        depth?: any;
        stencil?: any;
    }): void;
    /** WebGL1 typed context. Can always be used. */
    readonly gl: WebGLRenderingContext;
    /** WebGL2 typed context. Need to check isWebGL2 or isWebGL1 before using. */
    readonly gl2: WebGL2RenderingContext | null;
    readonly debug: boolean;
    /** `true` if this is a WebGL1 context. @note `false` if WebGL2 */
    readonly isWebGL1: boolean;
    /** `true` if this is a WebGL2 context. @note `false` if WebGL1 */
    readonly isWebGL2: boolean;
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    readonly _canvasSizeInfo: {
        clientWidth: number;
        clientHeight: number;
        devicePixelRatio: number;
    };
    /** State used by luma.gl classes - TODO - not used? */
    readonly _extensions: Record<string, any>;
    _polyfilled: boolean;
    /** Instance of Spector.js (if initialized) */
    spector: any;
    private _webglLimits?;
    /** Return WebGL specific limits */
    get webglLimits(): WebGLLimits;
    /**
     * Triggers device (or WebGL context) loss.
     * @note primarily intended for testing how application reacts to device loss
     */
    loseDevice(): boolean;
    /** Save current WebGL context state onto an internal stack */
    pushState(): void;
    /** Restores previously saved context state */
    popState(): void;
    /**
     * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
     * luma.gl ids and props can be inspected
     */
    setSpectorMetadata(handle: unknown, props: Record<string, unknown>): void;
    /**
     * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
     * Be aware that there are some duplicates especially for constants that are 0,
     * so this isn't guaranteed to return the right key in all cases.
     */
    getGLKey(value: unknown, gl?: WebGLRenderingContext): string;
    /** Store constants */
    _constants: (TypedArray | null)[];
    /**
     * Set a constant value for a location. Disabled attributes at that location will read from this value
     * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
     * so they need to be updated before every render
     * @todo - remember/cache values to avoid setting them unnecessarily?
     */
    setConstantAttribute(location: number, constant: TypedArray): void;
}
//# sourceMappingURL=webgl-device.d.ts.map