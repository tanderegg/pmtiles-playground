import { RenderPipeline, cast, splitUniformsAndBindings, log } from '@luma.gl/core';
import { mergeShaderLayout } from '@luma.gl/core';
import { getShaderLayout } from "../helpers/get-shader-layout.js";
import { withDeviceAndGLParameters } from "../converters/device-parameters.js";
import { setUniform } from "../helpers/set-uniform.js";
import { WEBGLBuffer } from "./webgl-buffer.js";
import { WEBGLFramebuffer } from "./webgl-framebuffer.js";
import { WEBGLTexture } from "./webgl-texture.js";
import { getGLDrawMode } from "../helpers/webgl-topology-utils.js";
const LOG_PROGRAM_PERF_PRIORITY = 4;
export class WEBGLRenderPipeline extends RenderPipeline {
  constructor(device, props) {
    super(device, props);
    this.device = void 0;
    this.handle = void 0;
    this.vs = void 0;
    this.fs = void 0;
    this.introspectedLayout = void 0;
    this.uniforms = {};
    this.bindings = {};
    this.varyings = null;
    this._uniformCount = 0;
    this._uniformSetters = {};
    this.device = device;
    this.handle = this.props.handle || this.device.gl.createProgram();
    this.device.setSpectorMetadata(this.handle, {
      id: this.props.id
    });
    this.vs = cast(props.vs);
    this.fs = cast(props.fs);
    const {
      varyings,
      bufferMode = 35981
    } = props;
    if (varyings && varyings.length > 0) {
      var _this$device$gl;
      this.device.assertWebGL2();
      this.varyings = varyings;
      (_this$device$gl = this.device.gl2) === null || _this$device$gl === void 0 ? void 0 : _this$device$gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }
    this._compileAndLink();
    this.introspectedLayout = getShaderLayout(this.device.gl, this.handle);
    this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);
    switch (this.props.topology) {
      case 'triangle-fan-webgl':
      case 'line-loop-webgl':
        log.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
        break;
      default:
    }
  }
  destroy() {
    if (this.handle) {
      this.device.gl.deleteProgram(this.handle);
      this.destroyed = true;
    }
  }
  setBindings(bindings) {
    for (const [name, value] of Object.entries(bindings)) {
      const binding = this.shaderLayout.bindings.find(binding => binding.name === name) || this.shaderLayout.bindings.find(binding => binding.name === `${name}Uniforms`);
      if (!binding) {
        const validBindings = this.shaderLayout.bindings.map(binding => `"${binding.name}"`).join(', ');
        log.warn(`Unknown binding "${name}" in render pipeline "${this.id}", expected one of ${validBindings}`)();
        continue;
      }
      if (!value) {
        log.warn(`Unsetting binding "${name}" in render pipeline "${this.id}"`)();
      }
      switch (binding.type) {
        case 'uniform':
          if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
            throw new Error('buffer value');
          }
          break;
        case 'texture':
          if (!(value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error('texture value');
          }
          break;
        case 'sampler':
          log.warn(`Ignoring sampler ${name}`)();
          break;
        default:
          throw new Error(binding.type);
      }
      this.bindings[name] = value;
    }
  }
  setUniforms(uniforms) {
    const {
      bindings
    } = splitUniformsAndBindings(uniforms);
    Object.keys(bindings).forEach(name => {
      log.warn(`Unsupported value "${JSON.stringify(bindings[name])}" used in setUniforms() for key ${name}. Use setBindings() instead?`)();
    });
    Object.assign(this.uniforms, uniforms);
  }
  draw(options) {
    var _vertexArray$indexBuf;
    const {
      renderPass,
      vertexArray,
      vertexCount,
      instanceCount,
      firstVertex = 0,
      transformFeedback
    } = options;
    const glDrawMode = getGLDrawMode(this.props.topology);
    const isIndexed = Boolean(vertexArray.indexBuffer);
    const glIndexType = (_vertexArray$indexBuf = vertexArray.indexBuffer) === null || _vertexArray$indexBuf === void 0 ? void 0 : _vertexArray$indexBuf.glIndexType;
    const isInstanced = Number(instanceCount) > 0;
    if (!this._areTexturesRenderable() || vertexCount === 0) {
      return false;
    }
    this.device.gl.useProgram(this.handle);
    vertexArray.bindBeforeRender(renderPass);
    if (transformFeedback) {
      transformFeedback.begin(this.props.topology);
    }
    this._applyBindings();
    this._applyUniforms();
    const webglRenderPass = renderPass;
    withDeviceAndGLParameters(this.device, this.props.parameters, webglRenderPass.glParameters, () => {
      if (isIndexed && isInstanced) {
        var _this$device$gl2;
        (_this$device$gl2 = this.device.gl2) === null || _this$device$gl2 === void 0 ? void 0 : _this$device$gl2.drawElementsInstanced(glDrawMode, vertexCount || 0, glIndexType, firstVertex, instanceCount || 0);
      } else if (isIndexed) {
        this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
      } else if (isInstanced) {
        var _this$device$gl3;
        (_this$device$gl3 = this.device.gl2) === null || _this$device$gl3 === void 0 ? void 0 : _this$device$gl3.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
      } else {
        this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
      }
      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    vertexArray.unbindAfterRender(renderPass);
    return true;
  }
  _compileAndLink() {
    const {
      gl
    } = this.device;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    gl.linkProgram(this.handle);
    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
    if (!gl.debug && log.level === 0) {}
    const linked = gl.getProgramParameter(this.handle, 35714);
    if (!linked) {
      throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);
    }
    gl.validateProgram(this.handle);
    const validated = gl.getProgramParameter(this.handle, 35715);
    if (!validated) {
      throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);
    }
  }
  _areTexturesRenderable() {
    let texturesRenderable = true;
    for (const [, texture] of Object.entries(this.bindings)) {
      if (texture instanceof WEBGLTexture) {
        texture.update();
        texturesRenderable = texturesRenderable && texture.loaded;
      }
    }
    return texturesRenderable;
  }
  _applyBindings() {
    this.device.gl.useProgram(this.handle);
    const {
      gl2
    } = this.device;
    if (!gl2) {
      throw new Error('bindings');
    }
    let textureUnit = 0;
    let uniformBufferIndex = 0;
    for (const binding of this.shaderLayout.bindings) {
      const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, '')];
      if (!value) {
        throw new Error(`No value for binding ${binding.name} in ${this.id}`);
      }
      switch (binding.type) {
        case 'uniform':
          const {
            name
          } = binding;
          const location = gl2.getUniformBlockIndex(this.handle, name);
          if (location === 4294967295) {
            throw new Error(`Invalid uniform block name ${name}`);
          }
          gl2.uniformBlockBinding(this.handle, uniformBufferIndex, location);
          if (value instanceof WEBGLBuffer) {
            gl2.bindBufferBase(35345, uniformBufferIndex, value.handle);
          } else {
            gl2.bindBufferRange(35345, uniformBufferIndex, value.buffer.handle, value.offset || 0, value.size || value.buffer.byteLength - value.offset);
          }
          uniformBufferIndex += 1;
          break;
        case 'texture':
          if (!(value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
            throw new Error('texture');
          }
          let texture;
          if (value instanceof WEBGLTexture) {
            texture = value;
          } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTexture) {
            log.warn('Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead')();
            texture = value.colorAttachments[0];
          } else {
            throw new Error('No texture');
          }
          gl2.activeTexture(33984 + textureUnit);
          gl2.bindTexture(texture.target, texture.handle);
          textureUnit += 1;
          break;
        case 'sampler':
          break;
        case 'storage':
        case 'read-only-storage':
          throw new Error(`binding type '${binding.type}' not supported in WebGL`);
      }
    }
  }
  _applyUniforms() {
    for (const uniformLayout of this.shaderLayout.uniforms || []) {
      var _this$uniforms$name;
      const {
        name,
        location,
        type,
        textureUnit
      } = uniformLayout;
      const value = (_this$uniforms$name = this.uniforms[name]) !== null && _this$uniforms$name !== void 0 ? _this$uniforms$name : textureUnit;
      if (value !== undefined) {
        setUniform(this.device.gl, location, type, value);
      }
    }
  }
}
//# sourceMappingURL=webgl-render-pipeline.js.map