import { log, TransformFeedback } from '@luma.gl/core';
import { WEBGLBuffer } from "../../index.js";
import { getGLPrimitive } from "../helpers/webgl-topology-utils.js";
export class WEBGLTransformFeedback extends TransformFeedback {
  constructor(device, props) {
    super(device, props);
    this.device = void 0;
    this.gl2 = void 0;
    this.handle = void 0;
    this.layout = void 0;
    this.buffers = {};
    this.unusedBuffers = {};
    this.bindOnUse = true;
    this._bound = false;
    device.assertWebGL2();
    this.device = device;
    this.gl2 = device.gl2;
    this.handle = this.props.handle || this.gl2.createTransformFeedback();
    this.layout = this.props.layout;
    if (props.buffers) {
      this.setBuffers(props.buffers);
    }
    Object.seal(this);
  }
  destroy() {
    this.gl2.deleteTransformFeedback(this.handle);
    super.destroy();
  }
  begin() {
    let topology = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'point-list';
    this.gl2.bindTransformFeedback(36386, this.handle);
    if (this.bindOnUse) {
      this._bindBuffers();
    }
    this.gl2.beginTransformFeedback(getGLPrimitive(topology));
  }
  end() {
    this.gl2.endTransformFeedback();
    if (!this.bindOnUse) {
      this._unbindBuffers();
    }
    this.gl2.bindTransformFeedback(36386, null);
  }
  setBuffers(buffers) {
    this.buffers = {};
    this.unusedBuffers = {};
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
  }
  setBuffer(locationOrName, bufferOrRange) {
    const location = this._getVaryingIndex(locationOrName);
    const {
      buffer,
      byteLength,
      byteOffset
    } = this._getBufferRange(bufferOrRange);
    if (location < 0) {
      this.unusedBuffers[locationOrName] = buffer;
      log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
      return;
    }
    this.buffers[location] = {
      buffer,
      byteLength,
      byteOffset
    };
    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteLength);
    }
  }
  getBuffer(locationOrName) {
    if (isIndex(locationOrName)) {
      return this.buffers[locationOrName] || null;
    }
    const location = this._getVaryingIndex(locationOrName);
    return location >= 0 ? this.buffers[location] : null;
  }
  bind() {
    let funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;
    if (typeof funcOrHandle !== 'function') {
      this.gl2.bindTransformFeedback(36386, funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this.gl2.bindTransformFeedback(36386, this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this.gl2.bindTransformFeedback(36386, null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  _getBufferRange(bufferOrRange) {
    if (bufferOrRange instanceof WEBGLBuffer) {
      return {
        buffer: bufferOrRange,
        byteOffset: 0,
        byteLength: bufferOrRange.byteLength
      };
    }
    const {
      buffer,
      byteOffset = 0,
      byteLength = bufferOrRange.buffer.byteLength
    } = bufferOrRange;
    return {
      buffer,
      byteOffset,
      byteLength
    };
  }
  _getVaryingIndex(locationOrName) {
    if (isIndex(locationOrName)) {
      return Number(locationOrName);
    }
    for (const varying of this.layout.varyings) {
      if (locationOrName === varying.name) {
        return varying.location;
      }
    }
    return -1;
  }
  _bindBuffers() {
    for (const bufferIndex in this.buffers) {
      const {
        buffer,
        byteLength,
        byteOffset
      } = this._getBufferRange(this.buffers[bufferIndex]);
      this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
    }
  }
  _unbindBuffers() {
    for (const bufferIndex in this.buffers) {
      this.gl2.bindBufferBase(35982, Number(bufferIndex), null);
    }
  }
  _bindBuffer(index, buffer) {
    let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let byteLength = arguments.length > 3 ? arguments[3] : undefined;
    const handle = buffer && buffer.handle;
    if (!handle || byteLength === undefined) {
      this.gl2.bindBufferBase(35982, index, handle);
    } else {
      this.gl2.bindBufferRange(35982, index, handle, byteOffset, byteLength);
    }
  }
}
function isIndex(value) {
  if (typeof value === 'number') {
    return Number.isInteger(value);
  }
  return /^\d+$/.test(value);
}
//# sourceMappingURL=webgl-transform-feedback.js.map