{"version":3,"file":"webgl-command-buffer.js","names":["CommandBuffer","Texture","WEBGLTexture","getWebGLTextureParameters","cast","value","WEBGLCommandBuffer","constructor","device","commands","submitCommands","arguments","length","undefined","command","name","_copyBufferToBuffer","options","_copyBufferToTexture","_copyTextureToBuffer","_copyTextureToTexture","source","destination","gl2","assertWebGL2","_options$sourceOffset","_options$destinationO","bindBuffer","handle","copyBufferSubData","sourceOffset","destinationOffset","size","Error","mipLevel","aspect","width","height","depthOrArrayLayers","origin","byteOffset","bytesPerRow","rowsPerImage","framebuffer","destroyFramebuffer","getFramebuffer","webglBuffer","sourceWidth","sourceHeight","sourceParams","texture","format","sourceFormat","dataFormat","sourceType","type","bindFramebuffer","readPixels","destroy","destinationMipmaplevel","destinationInternalFormat","sourceX","sourceY","isSubCopy","gl","textureTarget","Number","isFinite","bind","copyTexImage2D","unbind","glFormatToComponents","glTypeToBytes","id","createFramebuffer","colorAttachments"],"sources":["../../../src/adapter/resources/webgl-command-buffer.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport type {\n  CopyBufferToBufferOptions,\n  CopyBufferToTextureOptions,\n  CopyTextureToBufferOptions,\n  CopyTextureToTextureOptions\n} from '@luma.gl/core';\nimport {CommandBuffer, Texture, Framebuffer} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\n\nimport {WebGLDevice} from '../webgl-device';\nimport {WEBGLBuffer} from './webgl-buffer';\nimport {WEBGLTexture} from './webgl-texture';\nimport {WEBGLFramebuffer} from './webgl-framebuffer';\nimport {getWebGLTextureParameters} from '../converters/texture-formats';\n\nfunction cast<T>(value: unknown): T {\n  return value as T;\n}\n\ntype CopyBufferToBufferCommand = {\n  name: 'copy-buffer-to-buffer';\n  options: CopyBufferToBufferOptions;\n};\n\ntype CopyBufferToTextureCommand = {\n  name: 'copy-buffer-to-texture';\n  options: CopyBufferToTextureOptions;\n};\n\ntype CopyTextureToBufferCommand = {\n  name: 'copy-texture-to-buffer';\n  options: CopyTextureToBufferOptions;\n};\n\ntype CopyTextureToTextureCommand = {\n  name: 'copy-texture-to-texture';\n  options: CopyTextureToTextureOptions;\n};\n\ntype Command =\n  | CopyBufferToBufferCommand\n  | CopyBufferToTextureCommand\n  | CopyTextureToBufferCommand\n  | CopyTextureToTextureCommand;\n\nexport class WEBGLCommandBuffer extends CommandBuffer {\n  device: WebGLDevice;\n  commands: Command[] = [];\n\n  constructor(device: WebGLDevice) {\n    super(device, {});\n    this.device = device;\n  }\n\n  submitCommands(commands: Command[] = this.commands) {\n    for (const command of commands) {\n      switch (command.name) {\n        case 'copy-buffer-to-buffer':\n          _copyBufferToBuffer(this.device, command.options);\n          break;\n        case 'copy-buffer-to-texture':\n          _copyBufferToTexture(this.device, command.options);\n          break;\n        case 'copy-texture-to-buffer':\n          _copyTextureToBuffer(this.device, command.options);\n          break;\n        case 'copy-texture-to-texture':\n          _copyTextureToTexture(this.device, command.options);\n          break;\n      }\n    }\n  }\n}\n\nfunction _copyBufferToBuffer(device: WebGLDevice, options: CopyBufferToBufferOptions): void {\n  const source = cast<WEBGLBuffer>(options.source);\n  const destination = cast<WEBGLBuffer>(options.destination);\n\n  const gl2 = device.assertWebGL2();\n  if (gl2) {\n    // In WebGL2 we can perform the copy on the GPU\n    // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n    gl2.bindBuffer(GL.COPY_READ_BUFFER, source.handle);\n    gl2.bindBuffer(GL.COPY_WRITE_BUFFER, destination.handle);\n    gl2.copyBufferSubData(\n      GL.COPY_READ_BUFFER,\n      GL.COPY_WRITE_BUFFER,\n      options.sourceOffset ?? 0,\n      options.destinationOffset ?? 0,\n      options.size\n    );\n    gl2.bindBuffer(GL.COPY_READ_BUFFER, null);\n    gl2.bindBuffer(GL.COPY_WRITE_BUFFER, null);\n  } else {\n    // TODO - in WebGL1 we would have to read back to CPU\n    // read / write buffer from / to CPU\n    throw new Error('copyBufferToBuffer not implemented in WebGL1');\n  }\n}\n\n/**\n * Copies data from a Buffer object into a Texture object\n * NOTE: doesn't wait for copy to be complete\n */\nfunction _copyBufferToTexture(device: WebGLDevice, options: CopyBufferToTextureOptions): void {\n  throw new Error('Not implemented');\n}\n\n/**\n * Copies data from a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete\n */\nfunction _copyTextureToBuffer(device: WebGLDevice, options: CopyTextureToBufferOptions): void {\n  const {\n    /** Texture to copy to/from. */\n    source,\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    mipLevel = 0,\n    /** Defines which aspects of the texture to copy to/from. */\n    aspect = 'all',\n\n    /** Width to copy */\n    width = options.source.width,\n    /** Height to copy */\n    height = options.source.height,\n    depthOrArrayLayers = 0,\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    origin = [0, 0],\n\n    /** Destination buffer */\n    destination,\n    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */\n    byteOffset = 0,\n    /**\n     * The stride, in bytes, between the beginning of each block row and the subsequent block row.\n     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).\n     */\n    bytesPerRow,\n    /**\n     * Number of block rows per single image of the texture.\n     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.\n     * Required if there are multiple images (i.e. the copy depth is more than one).\n     */\n    rowsPerImage\n  } = options;\n\n  // TODO - Not possible to read just stencil or depth part in WebGL?\n  if (aspect !== 'all') {\n    throw new Error('not supported');\n  }\n\n  // TODO - mipLevels are set when attaching texture to framebuffer\n  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {\n    throw new Error('not implemented');\n  }\n\n  // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const gl2 = device.assertWebGL2();\n\n  const {framebuffer, destroyFramebuffer} = getFramebuffer(source);\n  try {\n    const webglBuffer = destination as WEBGLBuffer;\n    const sourceWidth = width || framebuffer.width;\n    const sourceHeight = height || framebuffer.height;\n    const sourceParams = getWebGLTextureParameters(framebuffer.texture.format, true);\n    const sourceFormat = sourceParams.dataFormat;\n    const sourceType = sourceParams.type;\n\n    // if (!target) {\n    //   // Create new buffer with enough size\n    //   const components = glFormatToComponents(sourceFormat);\n    //   const byteCount = glTypeToBytes(sourceType);\n    //   const byteLength = byteOffset + sourceWidth * sourceHeight * components * byteCount;\n    //   target = device.createBuffer({byteLength});\n    // }\n\n    gl2.bindBuffer(GL.PIXEL_PACK_BUFFER, webglBuffer.handle);\n    gl2.bindFramebuffer(GL.FRAMEBUFFER, framebuffer.handle);\n\n    gl2.readPixels(\n      origin[0],\n      origin[1],\n      sourceWidth,\n      sourceHeight,\n      sourceFormat,\n      sourceType,\n      byteOffset\n    );\n  } finally {\n    gl2.bindBuffer(GL.PIXEL_PACK_BUFFER, null);\n    gl2.bindFramebuffer(GL.FRAMEBUFFER, null);\n\n    if (destroyFramebuffer) {\n      framebuffer.destroy();\n    }\n  }\n}\n\n/**\n * Copies data from a Framebuffer or a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transfer.\nexport function readPixelsToBuffer(\n  source: Framebuffer | Texture,\n  options?: {\n    sourceX?: number;\n    sourceY?: number;\n    sourceFormat?: number;\n    target?: Buffer; // A new Buffer object is created when not provided.\n    targetByteOffset?: number; // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth?: number;\n    sourceHeight?: number;\n    sourceType?: number;\n  }\n): Buffer\n */\n\n/**\n * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n */\n// eslint-disable-next-line complexity, max-statements\nfunction _copyTextureToTexture(device: WebGLDevice, options: CopyTextureToTextureOptions): void {\n  const {\n    /** Texture to copy to/from. */\n    source,\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    // mipLevel = 0,\n    /** Defines which aspects of the texture to copy to/from. */\n    // aspect = 'all',\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    origin = [0, 0],\n\n    /** Texture to copy to/from. */\n    destination,\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    // destinationMipLevel = options.mipLevel,\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    // destinationOrigin = [0, 0],\n    /** Defines which aspects of the texture to copy to/from. */\n    // destinationAspect = options.aspect,\n\n  } = options;\n\n  let {\n    width = options.destination.width,\n    height = options.destination.width,\n    // depthOrArrayLayers = 0\n  } = options;\n\n  const destinationMipmaplevel = 0;\n  const destinationInternalFormat = GL.RGBA;\n\n  const {framebuffer, destroyFramebuffer} = getFramebuffer(source);\n  const [sourceX, sourceY] = origin;\n\n  const isSubCopy = false;\n  // typeof destinationX !== 'undefined' ||\n  // typeof destinationY !== 'undefined' ||\n  // typeof destinationZ !== 'undefined';\n\n  // destinationX = destinationX || 0;\n  // destinationY = destinationY || 0;\n  // destinationZ = destinationZ || 0;\n  device.gl.bindFramebuffer(GL.FRAMEBUFFER, framebuffer.handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n\n  let texture = null;\n  let textureTarget: GL;\n  if (destination instanceof WEBGLTexture) {\n    texture = destination;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    textureTarget = texture.destination;\n  } else {\n    throw new Error('whoops');\n    //  textureTarget = destination;\n  }\n\n  if (!isSubCopy) {\n    device.gl.copyTexImage2D(\n      textureTarget,\n      destinationMipmaplevel,\n      destinationInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    // switch (textureTarget) {\n    //   case GL.TEXTURE_2D:\n    //   case GL.TEXTURE_CUBE_MAP:\n    //     device.gl.copyTexSubImage2D(\n    //       textureTarget,\n    //       destinationMipmaplevel,\n    //       destinationX,\n    //       destinationY,\n    //       sourceX,\n    //       sourceY,\n    //       width,\n    //       height\n    //     );\n    //     break;\n    //   case GL.TEXTURE_2D_ARRAY:\n    //   case GL.TEXTURE_3D:\n    //     const gl2 = device.assertWebGL2();\n    //     gl2.copyTexSubImage3D(\n    //       textureTarget,\n    //       destinationMipmaplevel,\n    //       destinationX,\n    //       destinationY,\n    //       destinationZ,\n    //       sourceX,\n    //       sourceY,\n    //       width,\n    //       height\n    //     );\n    //     break;\n    //   default:\n    // }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // ts-expect-error\n  // device.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (destroyFramebuffer) {\n    framebuffer.destroy();\n  }\n  return texture;\n}\n\n// Returns number of components in a specific readPixels WebGL format\nexport function glFormatToComponents(format): 1 | 2 | 3 | 4 {\n  switch (format) {\n    case GL.ALPHA:\n    case GL.R32F:\n    case GL.RED:\n      return 1;\n    case GL.RG32F:\n    case GL.RG:\n      return 2;\n    case GL.RGB:\n    case GL.RGB32F:\n      return 3;\n    case GL.RGBA:\n    case GL.RGBA32F:\n      return 4;\n    // TODO: Add support for additional WebGL2 formats\n    default:\n      throw new Error('GLFormat');\n  }\n}\n\n// Return byte count for given readPixels WebGL type\nexport function glTypeToBytes(type: GL): 1 | 2 | 4 {\n  switch (type) {\n    case GL.UNSIGNED_BYTE:\n      return 1;\n    case GL.UNSIGNED_SHORT_5_6_5:\n    case GL.UNSIGNED_SHORT_4_4_4_4:\n    case GL.UNSIGNED_SHORT_5_5_5_1:\n      return 2;\n    case GL.FLOAT:\n      return 4;\n    // TODO: Add support for additional WebGL2 types\n    default:\n      throw new Error('GLType');\n  }\n}\n\n// Helper methods\n\nfunction getFramebuffer(source: Texture | Framebuffer): {\n  framebuffer: WEBGLFramebuffer;\n  destroyFramebuffer: boolean;\n} {\n  if (source instanceof Texture) {\n    const {width, height, id} = source;\n    const framebuffer = source.device.createFramebuffer({\n      id: `framebuffer-for-${id}`,\n      width,\n      height,\n      colorAttachments: [source]\n    }) as unknown as WEBGLFramebuffer;\n\n    return {framebuffer, destroyFramebuffer: true};\n  }\n  return {framebuffer: source as unknown as WEBGLFramebuffer, destroyFramebuffer: false};\n}\n"],"mappings":"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"}