import { RenderPass } from '@luma.gl/core';
import { withGLParameters } from "../../context/state-tracker/with-parameters.js";
import { setGLParameters } from "../../context/parameters/unified-parameter-api.js";
import { pushContextState, popContextState } from "../../context/state-tracker/track-context-state.js";
const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_COLOR_BUFFER_BIT = 0x00004000;
const GL_COLOR = 0x1800;
export class WEBGLRenderPass extends RenderPass {
  constructor(device, props) {
    super(device, props);
    this.device = void 0;
    this.glParameters = void 0;
    this.device = device;
    pushContextState(this.device.gl);
    this.setParameters(this.props.parameters);
    this.clear();
  }
  end() {
    popContextState(this.device.gl);
    if (this.props.framebuffer) {
      setGLParameters(this.device, {
        framebuffer: null
      });
    }
  }
  pushDebugGroup(groupLabel) {}
  popDebugGroup() {}
  insertDebugMarker(markerLabel) {}
  setParameters() {
    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const glParameters = {};
    if (this.props.framebuffer) {
      glParameters.framebuffer = this.props.framebuffer;
    }
    if (this.props.depthReadOnly) {
      glParameters.depthMask = !this.props.depthReadOnly;
    }
    glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
    glParameters[35977] = this.props.discard;
    if (parameters.viewport) {
      if (parameters.viewport.length >= 6) {
        glParameters.viewport = parameters.viewport.slice(0, 4);
        glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];
      } else {
        glParameters.viewport = parameters.viewport;
      }
    }
    glParameters.scissorTest = Boolean(parameters.scissorRect);
    if (parameters.scissorRect) {
      glParameters.scissor = parameters.scissorRect;
    }
    if (parameters.blendConstant) {
      glParameters.blendColor = parameters.blendConstant;
    }
    if (parameters.stencilReference) {
      console.warn('RenderPassParameters.stencilReference not yet implemented in WebGL');
      parameters[2967] = parameters.stencilReference;
    }
    this.glParameters = glParameters;
    setGLParameters(this.device, glParameters);
  }
  clear() {
    const glParameters = {
      ...this.glParameters
    };
    let clearMask = 0;
    if (this.props.clearColor !== false) {
      clearMask |= GL_COLOR_BUFFER_BIT;
      glParameters.clearColor = this.props.clearColor;
    }
    if (this.props.clearDepth !== false) {
      clearMask |= GL_DEPTH_BUFFER_BIT;
      glParameters.clearDepth = this.props.clearDepth;
    }
    if (this.props.clearStencil !== false) {
      clearMask |= GL_STENCIL_BUFFER_BIT;
      glParameters.clearStencil = this.props.clearStencil;
    }
    if (clearMask !== 0) {
      withGLParameters(this.device, glParameters, () => {
        this.device.gl.clear(clearMask);
      });
    }
  }
  clearColorBuffer() {
    let drawBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0];
    withGLParameters(this.device.gl2, {
      framebuffer: this.props.framebuffer
    }, () => {
      switch (value.constructor) {
        case Int32Array:
          this.device.gl2.clearBufferiv(GL_COLOR, drawBuffer, value);
          break;
        case Uint32Array:
          this.device.gl2.clearBufferuiv(GL_COLOR, drawBuffer, value);
          break;
        case Float32Array:
        default:
          this.device.gl2.clearBufferfv(GL_COLOR, drawBuffer, value);
          break;
      }
    });
  }
}
//# sourceMappingURL=webgl-render-pass.js.map