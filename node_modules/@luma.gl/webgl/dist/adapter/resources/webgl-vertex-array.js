let _Symbol$toStringTag;
import { VertexArray, getScratchArray, fillArray } from '@luma.gl/core';
import { getBrowser } from '@probe.gl/env';
import { getGLFromVertexType } from "../converters/vertex-formats.js";
_Symbol$toStringTag = Symbol.toStringTag;
export class WEBGLVertexArray extends VertexArray {
  get [_Symbol$toStringTag]() {
    return 'VertexArray';
  }
  static isConstantAttributeZeroSupported(device) {
    return device.info.type === 'webgl2' || getBrowser() === 'Chrome';
  }
  constructor(device, props) {
    super(device, props);
    this.device = void 0;
    this.handle = void 0;
    this.buffer = null;
    this.bufferValue = null;
    this.init = false;
    this.device = device;
    this.handle = this.device.gl2.createVertexArray();
  }
  destroy() {
    super.destroy();
    if (this.buffer) {
      var _this$buffer;
      (_this$buffer = this.buffer) === null || _this$buffer === void 0 ? void 0 : _this$buffer.destroy();
    }
    if (this.handle) {
      this.device.gl2.deleteVertexArray(this.handle);
      this.handle = undefined;
    }
  }
  setIndexBuffer(indexBuffer) {
    const buffer = indexBuffer;
    if (buffer && buffer.glTarget !== 34963) {
      throw new Error('Use .setBuffer()');
    }
    this.device.gl2.bindVertexArray(this.handle);
    this.device.gl2.bindBuffer(34963, buffer ? buffer.handle : null);
    this.indexBuffer = buffer;
  }
  setBuffer(location, attributeBuffer) {
    const buffer = attributeBuffer;
    if (buffer.glTarget === 34963) {
      throw new Error('Use .setIndexBuffer()');
    }
    const {
      size,
      type,
      stride,
      offset,
      normalized,
      integer,
      divisor
    } = this._getAccessor(location);
    this.device.gl2.bindVertexArray(this.handle);
    this.device.gl.bindBuffer(34962, buffer.handle);
    if (integer) {
      this.device.assertWebGL2();
      this.device.gl2.vertexAttribIPointer(location, size, type, stride, offset);
    } else {
      this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
    }
    this.device.gl.enableVertexAttribArray(location);
    this.device.gl2.vertexAttribDivisor(location, divisor || 0);
    this.attributes[location] = buffer;
  }
  setConstant(location, value) {
    this._enable(location, false);
    this.attributes[location] = value;
  }
  bindBeforeRender() {
    this.device.gl2.bindVertexArray(this.handle);
    if (!this.init) {
      const webglBuffer = this.indexBuffer;
      this.device.gl2.bindBuffer(34963, (webglBuffer === null || webglBuffer === void 0 ? void 0 : webglBuffer.handle) || null);
      this.init = true;
    }
    this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl2.bindVertexArray(null);
  }
  _applyConstantAttributes() {
    for (let location = 0; location < this.maxVertexAttributes; ++location) {
      const constant = this.attributes[location];
      if (ArrayBuffer.isView(constant)) {
        this.device.setConstantAttribute(location, constant);
      }
    }
  }
  _getAccessor(location) {
    const attributeInfo = this.attributeInfos[location];
    if (!attributeInfo) {
      throw new Error(`Unknown attribute location ${location}`);
    }
    const glType = getGLFromVertexType(attributeInfo.bufferDataType);
    return {
      size: attributeInfo.bufferComponents,
      type: glType,
      stride: attributeInfo.byteStride,
      offset: attributeInfo.byteOffset,
      normalized: attributeInfo.normalized,
      integer: attributeInfo.integer,
      divisor: attributeInfo.stepMode === 'instance' ? 1 : 0
    };
  }
  _enable(location) {
    let enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
    const canDisableAttribute = canDisableAttributeZero || location !== 0;
    if (enable || canDisableAttribute) {
      location = Number(location);
      this.device.gl2.bindVertexArray(this.handle);
      if (enable) {
        this.device.gl.enableVertexAttribArray(location);
      } else {
        this.device.gl.disableVertexAttribArray(location);
      }
      this.device.gl2.bindVertexArray(null);
    }
  }
  getConstantBuffer(elementCount, value) {
    const constantValue = normalizeConstantArrayValue(value);
    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    if (this.buffer && byteLength !== this.buffer.byteLength) {
      throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
    }
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || this.device.createBuffer({
      byteLength
    });
    updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);
    if (updateNeeded) {
      const typedArray = getScratchArray(value.constructor, length);
      fillArray({
        target: typedArray,
        source: constantValue,
        start: 0,
        count: length
      });
      this.buffer.write(typedArray);
      this.bufferValue = value;
    }
    return this.buffer;
  }
}
function normalizeConstantArrayValue(arrayValue) {
  if (Array.isArray(arrayValue)) {
    return new Float32Array(arrayValue);
  }
  return arrayValue;
}
function compareConstantArrayValues(v1, v2) {
  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
    return false;
  }
  for (let i = 0; i < v1.length; ++i) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
}
//# sourceMappingURL=webgl-vertex-array.js.map