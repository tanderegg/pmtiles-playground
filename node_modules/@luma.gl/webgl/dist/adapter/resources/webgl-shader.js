import { Shader } from '@luma.gl/core';
import { parseShaderCompilerLog } from "../helpers/parse-shader-compiler-log.js";
export class WEBGLShader extends Shader {
  constructor(device, props) {
    super(device, props);
    this.device = void 0;
    this.handle = void 0;
    this.device = device;
    switch (this.props.stage) {
      case 'vertex':
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case 'fragment':
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    if (this.handle) {
      this.removeStats();
      this.device.gl.deleteShader(this.handle);
      this.destroyed = true;
    }
  }
  async getCompilationInfo() {
    return this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const log = this.device.gl.getShaderInfoLog(this.handle);
    return parseShaderCompilerLog(log);
  }
  _compile(source) {
    const addGLSLVersion = source => source.startsWith('#version ') ? source : `#version 100\n${source}`;
    source = addGLSLVersion(source);
    const {
      gl
    } = this.device;
    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);
    this.compilationStatus = gl.getShaderParameter(this.handle, 35713) ? 'success' : 'error';
    this.debugShader();
    if (this.compilationStatus === 'error') {
      throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
    }
  }
}
//# sourceMappingURL=webgl-shader.js.map