import { CommandBuffer, Texture } from '@luma.gl/core';
import { WEBGLTexture } from "./webgl-texture.js";
import { getWebGLTextureParameters } from "../converters/texture-formats.js";
function cast(value) {
  return value;
}
export class WEBGLCommandBuffer extends CommandBuffer {
  constructor(device) {
    super(device, {});
    this.device = void 0;
    this.commands = [];
    this.device = device;
  }
  submitCommands() {
    let commands = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.commands;
    for (const command of commands) {
      switch (command.name) {
        case 'copy-buffer-to-buffer':
          _copyBufferToBuffer(this.device, command.options);
          break;
        case 'copy-buffer-to-texture':
          _copyBufferToTexture(this.device, command.options);
          break;
        case 'copy-texture-to-buffer':
          _copyTextureToBuffer(this.device, command.options);
          break;
        case 'copy-texture-to-texture':
          _copyTextureToTexture(this.device, command.options);
          break;
      }
    }
  }
}
function _copyBufferToBuffer(device, options) {
  const source = cast(options.source);
  const destination = cast(options.destination);
  const gl2 = device.assertWebGL2();
  if (gl2) {
    var _options$sourceOffset, _options$destinationO;
    gl2.bindBuffer(36662, source.handle);
    gl2.bindBuffer(36663, destination.handle);
    gl2.copyBufferSubData(36662, 36663, (_options$sourceOffset = options.sourceOffset) !== null && _options$sourceOffset !== void 0 ? _options$sourceOffset : 0, (_options$destinationO = options.destinationOffset) !== null && _options$destinationO !== void 0 ? _options$destinationO : 0, options.size);
    gl2.bindBuffer(36662, null);
    gl2.bindBuffer(36663, null);
  } else {
    throw new Error('copyBufferToBuffer not implemented in WebGL1');
  }
}
function _copyBufferToTexture(device, options) {
  throw new Error('Not implemented');
}
function _copyTextureToBuffer(device, options) {
  const {
    source,
    mipLevel = 0,
    aspect = 'all',
    width = options.source.width,
    height = options.source.height,
    depthOrArrayLayers = 0,
    origin = [0, 0],
    destination,
    byteOffset = 0,
    bytesPerRow,
    rowsPerImage
  } = options;
  if (aspect !== 'all') {
    throw new Error('not supported');
  }
  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
    throw new Error('not implemented');
  }
  const gl2 = device.assertWebGL2();
  const {
    framebuffer,
    destroyFramebuffer
  } = getFramebuffer(source);
  try {
    const webglBuffer = destination;
    const sourceWidth = width || framebuffer.width;
    const sourceHeight = height || framebuffer.height;
    const sourceParams = getWebGLTextureParameters(framebuffer.texture.format, true);
    const sourceFormat = sourceParams.dataFormat;
    const sourceType = sourceParams.type;
    gl2.bindBuffer(35051, webglBuffer.handle);
    gl2.bindFramebuffer(36160, framebuffer.handle);
    gl2.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
  } finally {
    gl2.bindBuffer(35051, null);
    gl2.bindFramebuffer(36160, null);
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
}
function _copyTextureToTexture(device, options) {
  const {
    source,
    origin = [0, 0],
    destination
  } = options;
  let {
    width = options.destination.width,
    height = options.destination.width
  } = options;
  const destinationMipmaplevel = 0;
  const destinationInternalFormat = 6408;
  const {
    framebuffer,
    destroyFramebuffer
  } = getFramebuffer(source);
  const [sourceX, sourceY] = origin;
  const isSubCopy = false;
  device.gl.bindFramebuffer(36160, framebuffer.handle);
  let texture = null;
  let textureTarget;
  if (destination instanceof WEBGLTexture) {
    texture = destination;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    textureTarget = texture.destination;
  } else {
    throw new Error('whoops');
  }
  if (!isSubCopy) {
    device.gl.copyTexImage2D(textureTarget, destinationMipmaplevel, destinationInternalFormat, sourceX, sourceY, width, height, 0);
  } else {}
  if (texture) {
    texture.unbind();
  }
  if (destroyFramebuffer) {
    framebuffer.destroy();
  }
  return texture;
}
export function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      throw new Error('GLFormat');
  }
}
export function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    default:
      throw new Error('GLType');
  }
}
function getFramebuffer(source) {
  if (source instanceof Texture) {
    const {
      width,
      height,
      id
    } = source;
    const framebuffer = source.device.createFramebuffer({
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [source]
    });
    return {
      framebuffer,
      destroyFramebuffer: true
    };
  }
  return {
    framebuffer: source,
    destroyFramebuffer: false
  };
}
//# sourceMappingURL=webgl-command-buffer.js.map