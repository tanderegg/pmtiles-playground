import { Framebuffer, assert } from '@luma.gl/core';
import { WEBGLTexture } from "./webgl-texture.js";
import { WEBGLRenderbuffer } from "../objects/webgl-renderbuffer.js";
import { getDepthStencilAttachmentWebGL } from "../converters/texture-formats.js";
export class WEBGLFramebuffer extends Framebuffer {
  get texture() {
    return this.colorAttachments[0];
  }
  constructor(device, props) {
    super(device, props);
    this.device = void 0;
    this.gl = void 0;
    this.handle = void 0;
    const isDefaultFramebuffer = props.handle === null;
    this.device = device;
    this.gl = device.gl;
    this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
    if (!isDefaultFramebuffer) {
      device.setSpectorMetadata(this.handle, {
        id: this.props.id,
        props: this.props
      });
      this.autoCreateAttachmentTextures();
      this.gl.bindFramebuffer(36160, this.handle);
      for (let i = 0; i < this.colorAttachments.length; ++i) {
        const attachment = this.colorAttachments[i];
        const attachmentPoint = 36064 + i;
        if (attachment) {
          this._attachOne(attachmentPoint, attachment);
        }
      }
      if (this.depthStencilAttachment) {
        this._attachOne(getDepthStencilAttachmentWebGL(this.depthStencilAttachment.format), this.depthStencilAttachment);
      }
      this.gl.bindFramebuffer(36160, null);
    }
    if (props.check !== false) {
      this._checkStatus();
    }
  }
  destroy() {
    super.destroy();
    if (!this.destroyed && this.handle !== null) {
      this.gl.deleteFramebuffer(this.handle);
    }
  }
  _checkStatus() {
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    const status = gl.checkFramebufferStatus(36160);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (status !== 36053) {
      throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
    }
  }
  createDepthStencilTexture(format) {
    return new WEBGLRenderbuffer(this.device, {
      id: `${this.id}-depth-stencil`,
      format,
      width: this.width,
      height: this.height
    });
  }
  resizeAttachments(width, height) {
    if (this.handle === null) {
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }
    if (width === undefined) {
      width = this.gl.drawingBufferWidth;
    }
    if (height === undefined) {
      height = this.gl.drawingBufferHeight;
    }
    for (const colorAttachment of this.colorAttachments) {
      colorAttachment.resize({
        width,
        height
      });
    }
    if (this.depthStencilAttachment) {
      this.depthStencilAttachment.resize({
        width,
        height
      });
    }
    return this;
  }
  _attachOne(attachmentPoint, attachment) {
    if (attachment instanceof WEBGLRenderbuffer) {
      this._attachWEBGLRenderbuffer(attachmentPoint, attachment);
      return attachment;
    } else if (Array.isArray(attachment)) {
      const [texture, layer = 0, level = 0] = attachment;
      this._attachTexture(attachmentPoint, texture, layer, level);
      return texture;
    } else if (attachment instanceof WEBGLTexture) {
      this._attachTexture(attachmentPoint, attachment, 0, 0);
      return attachment;
    }
    throw new Error('attach');
  }
  _attachWEBGLRenderbuffer(attachment, renderbuffer) {
    this.gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
  }
  _attachTexture(attachment, texture, layer, level) {
    const {
      gl,
      gl2
    } = this.device;
    gl.bindTexture(texture.target, texture.handle);
    switch (texture.target) {
      case 35866:
      case 32879:
        this.device.assertWebGL2();
        gl2 === null || gl2 === void 0 ? void 0 : gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
        break;
      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;
      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;
      default:
        assert(false, 'Illegal texture type');
    }
    gl.bindTexture(texture.target, null);
  }
}
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  switch (status) {
    case 36053:
      return 'success';
    case 36054:
      return 'Mismatched attachments';
    case 36055:
      return 'No attachments';
    case 36057:
      return 'Height/width mismatch';
    case 36061:
      return 'Unsupported or split attachments';
    case 36182:
      return 'Samples mismatch';
    default:
      return `${status}`;
  }
}
//# sourceMappingURL=webgl-framebuffer.js.map