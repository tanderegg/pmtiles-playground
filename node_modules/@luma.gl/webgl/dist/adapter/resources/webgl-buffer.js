import { Buffer, assert } from '@luma.gl/core';
export class WEBGLBuffer extends Buffer {
  constructor(device) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(device, props);
    this.device = void 0;
    this.gl = void 0;
    this.gl2 = void 0;
    this.handle = void 0;
    this.glTarget = void 0;
    this.glUsage = void 0;
    this.glIndexType = 5123;
    this.byteLength = void 0;
    this.bytesUsed = void 0;
    this.device = device;
    this.gl = this.device.gl;
    this.gl2 = this.device.gl2;
    const handle = typeof props === 'object' ? props.handle : undefined;
    this.handle = handle || this.gl.createBuffer();
    device.setSpectorMetadata(this.handle, {
      ...this.props,
      data: typeof this.props.data
    });
    this.glTarget = getWebGLTarget(this.props.usage);
    this.glUsage = getWebGLUsage(this.props.usage);
    this.glIndexType = this.props.indexType === 'uint32' ? 5125 : 5123;
    if (props.data) {
      this._initWithData(props.data, props.byteOffset, props.byteLength);
    } else {
      this._initWithByteLength(props.byteLength || 0);
    }
  }
  _initWithData(data) {
    let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + byteOffset;
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, byteLength, this.glUsage);
    this.gl.bufferSubData(glTarget, byteOffset, data);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(data, byteOffset, byteLength);
    this.trackAllocatedMemory(byteLength);
  }
  _initWithByteLength(byteLength) {
    assert(byteLength >= 0);
    let data = byteLength;
    if (byteLength === 0) {
      data = new Float32Array(0);
    }
    const glTarget = this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    this.gl.bufferData(glTarget, data, this.glUsage);
    this.gl.bindBuffer(glTarget, null);
    this.bytesUsed = byteLength;
    this.byteLength = byteLength;
    this._setDebugData(null, 0, byteLength);
    this.trackAllocatedMemory(byteLength);
    return this;
  }
  destroy() {
    if (!this.destroyed && this.handle) {
      this.removeStats();
      this.trackDeallocatedMemory();
      this.gl.deleteBuffer(this.handle);
      this.destroyed = true;
      this.handle = null;
    }
  }
  write(data) {
    let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const srcOffset = 0;
    const byteLength = undefined;
    const glTarget = this.device.isWebGL2 ? 36663 : this.glTarget;
    this.gl.bindBuffer(glTarget, this.handle);
    if (srcOffset !== 0 || byteLength !== undefined) {
      this.device.assertWebGL2();
      this.gl2.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(glTarget, byteOffset, data);
    }
    this.gl.bindBuffer(glTarget, null);
    this._setDebugData(data, byteOffset, data.byteLength);
  }
  async readAsync() {
    let byteOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let byteLength = arguments.length > 1 ? arguments[1] : undefined;
    return this.readSyncWebGL2(byteOffset, byteLength);
  }
  readSyncWebGL2() {
    var _byteLength;
    let byteOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let byteLength = arguments.length > 1 ? arguments[1] : undefined;
    this.device.assertWebGL2();
    byteLength = (_byteLength = byteLength) !== null && _byteLength !== void 0 ? _byteLength : this.byteLength - byteOffset;
    const data = new Uint8Array(byteLength);
    const dstOffset = 0;
    this.gl.bindBuffer(36662, this.handle);
    this.gl2.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
    this.gl.bindBuffer(36662, null);
    this._setDebugData(data, byteOffset, byteLength);
    return data;
  }
}
function getWebGLTarget(usage) {
  if (usage & Buffer.INDEX) {
    return 34963;
  }
  if (usage & Buffer.VERTEX) {
    return 34962;
  }
  if (usage & Buffer.UNIFORM) {
    return 35345;
  }
  return 34962;
}
function getWebGLUsage(usage) {
  if (usage & Buffer.INDEX) {
    return 35044;
  }
  if (usage & Buffer.VERTEX) {
    return 35044;
  }
  if (usage & Buffer.UNIFORM) {
    return 35048;
  }
  return 35044;
}
//# sourceMappingURL=webgl-buffer.js.map