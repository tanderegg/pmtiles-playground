{"version":3,"file":"webgl-external-texture.js","names":[],"sources":["../../../src/adapter/resources/webgl-external-texture.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\n/*\nexport class WEBGLExternalTexture extends WEBGLTexture {\n  readonly device: WebGLDevice;\n  readonly gl: WebGLRenderingContext;\n  readonly gl2: WebGL2RenderingContext | null;\n  readonly handle: WebGLTexture;\n\n  data;\n\n  width: number = undefined;\n  height: number = undefined;\n  depth: number = undefined;\n\n  format = undefined;\n  type = undefined;\n  dataFormat = undefined;\n  border = undefined;\n  mipmaps: boolean = undefined;\n\n  textureUnit: number = undefined;\n\n  sampler: WEBGLSampler;\n\n  // Program.draw() checks the loaded flag of all textures to avoid\n  // Textures that are still loading from promises\n  // Set to true as soon as texture has been initialized with valid data\n  loaded = false;\n  _video;\n\n  readonly target: GL;\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_3D will give rise to an error\n  // (while run-time).\n\n  static isSupported(device: WebGLDevice, options?: TextureSupportOptions): boolean {\n    const {format, linearFiltering} = options;\n    let supported = true;\n    if (format) {\n      supported = supported && isFormatSupported(device.gl, format);\n      supported = supported && (!linearFiltering || isTextureFormatFilterable(device.gl, format));\n    }\n    return supported;\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(device: Device | WebGLRenderingContext, props: TextureProps) {\n    super(WebGLDevice.attach(device), {id: uid('texture'), ...props});\n\n    this.glTarget = getWebGLTextureTarget(props);\n\n    this.device = WebGLDevice.attach(device);\n    this.gl = this.device.gl;\n    this.gl2 = this.device.gl2;\n    this.handle = this.props.handle || this.gl.createTexture();\n\n    let data = props.data;\n\n    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;\n    // @ts-expect-error\n    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {\n      this._video = null; // Declare member before the object is sealed\n      data.addEventListener('loadeddata', () => this.initialize(props));\n      return this;\n    }\n\n  update(): this {\n    if (this._video) {\n      const {video, parameters, lastTime} = this._video;\n      // @ts-expect-error\n      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {\n        return;\n      }\n      this.setSubImageData({\n        data: video,\n        parameters\n      });\n      if (this.mipmaps) {\n        this.generateMipmap();\n      }\n      this._video.lastTime = video.currentTime;\n    }\n  }\n\n\n*/"],"mappings":""}