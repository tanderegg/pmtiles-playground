import type { UniformValue, RenderPipelineProps, Binding } from '@luma.gl/core';
import type { ShaderLayout } from '@luma.gl/core';
import type { RenderPass, VertexArray } from '@luma.gl/core';
import { RenderPipeline } from '@luma.gl/core';
import { WebGLDevice } from '../webgl-device';
import { WEBGLShader } from './webgl-shader';
import { WEBGLTransformFeedback } from './webgl-transform-feedback';
/** Creates a new render pipeline */
export declare class WEBGLRenderPipeline extends RenderPipeline {
    /** The WebGL device that created this render pipeline */
    device: WebGLDevice;
    /** Handle to underlying WebGL program */
    handle: WebGLProgram;
    /** vertex shader */
    vs: WEBGLShader;
    /** fragment shader */
    fs: WEBGLShader;
    /** The layout extracted from shader by WebGL introspection APIs */
    introspectedLayout: ShaderLayout;
    /** Uniforms set on this model */
    uniforms: Record<string, UniformValue>;
    /** Bindings set on this model */
    bindings: Record<string, Binding>;
    /** WebGL varyings */
    varyings: string[] | null;
    _uniformCount: number;
    _uniformSetters: Record<string, Function>;
    constructor(device: WebGLDevice, props: RenderPipelineProps);
    destroy(): void;
    /**
     * Bindings include: textures, samplers and uniform buffers
     * @todo needed for portable model
     */
    setBindings(bindings: Record<string, Binding>): void;
    /** This function is @deprecated, use uniform buffers */
    setUniforms(uniforms: Record<string, UniformValue>): void;
    /** @todo needed for portable model
     * @note The WebGL API is offers many ways to draw things
     * This function unifies those ways into a single call using common parameters with sane defaults
     */
    draw(options: {
        renderPass: RenderPass;
        /** vertex attributes */
        vertexArray: VertexArray;
        vertexCount?: number;
        indexCount?: number;
        instanceCount?: number;
        firstVertex?: number;
        firstIndex?: number;
        firstInstance?: number;
        baseVertex?: number;
        transformFeedback?: WEBGLTransformFeedback;
    }): boolean;
    protected _compileAndLink(): void;
    /**
     * Checks if all texture-values uniforms are renderable (i.e. loaded)
     * Update a texture if needed (e.g. from video)
     * Note: This is currently done before every draw call
     */
    _areTexturesRenderable(): boolean;
    /** Apply any bindings (before each draw call) */
    _applyBindings(): void;
    /**
     * Due to program sharing, uniforms need to be reset before every draw call
     * (though caching will avoid redundant WebGL calls)
     */
    _applyUniforms(): void;
}
//# sourceMappingURL=webgl-render-pipeline.d.ts.map