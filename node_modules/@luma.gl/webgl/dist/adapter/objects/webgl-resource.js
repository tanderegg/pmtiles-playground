import { Resource, assert, uid, stubRemovedMethods } from '@luma.gl/core';
import { isWebGL2, assertWebGLContext } from "../../context/context/webgl-checks.js";
import { WebGLDevice } from "../webgl-device.js";
import { getKeyValue } from "./constants-to-keys.js";
const ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';
export class WebGLResource extends Resource {
  constructor(device, props, defaultProps) {
    super(device, props, defaultProps);
    this.device = void 0;
    this.gl = void 0;
    this.gl2 = void 0;
    this._handle = void 0;
    this._bound = false;
    this.byteLength = 0;
    this.device = WebGLDevice.attach(device);
    const gl = this.device.gl;
    assertWebGLContext(gl);
    const {
      id
    } = props || {};
    this.gl = gl;
    this.gl2 = gl;
    this.id = id || uid(this.constructor.name);
    this._handle = props === null || props === void 0 ? void 0 : props.handle;
    if (this._handle === undefined) {
      this._handle = this._createHandle();
    }
    this.byteLength = 0;
  }
  toString() {
    return `${this.constructor.name}(${this.id})`;
  }
  get handle() {
    return this._handle;
  }
  delete() {
    let {
      deleteChildren = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const children = this._handle && this._deleteHandle(this._handle);
    if (this._handle) {
      this.removeStats();
    }
    this._handle = null;
    if (children && deleteChildren) {
      children.filter(Boolean).forEach(child => child.destroy());
    }
    return this;
  }
  bind() {
    let funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;
    if (typeof funcOrHandle !== 'function') {
      this._bindHandle(funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this._bindHandle(this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this._bindHandle(null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  getParameter(pname) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    pname = getKeyValue(this.gl, pname);
    assert(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = isWebGL2(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        const webgl1Default = parameter.webgl1;
        const webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
        const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
        return defaultValue;
      }
    }
    return this._getParameter(pname, props);
  }
  getParameters() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      parameters,
      keys
    } = options;
    const PARAMETERS = this.constructor.PARAMETERS || {};
    const isWebgl2 = isWebGL2(this.gl);
    const values = {};
    const parameterKeys = parameters || Object.keys(PARAMETERS);
    for (const pname of parameterKeys) {
      const parameter = PARAMETERS[pname];
      const parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (parameterAvailable) {
        const key = keys ? this.device.getGLKey(pname) : pname;
        values[key] = this.getParameter(pname, options);
        if (keys && parameter.type === 'GLenum') {
          values[key] = this.device.getGLKey(values[key]);
        }
      }
    }
    return values;
  }
  setParameter(pname, value) {
    pname = getKeyValue(this.gl, pname);
    assert(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = isWebGL2(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        throw new Error('Parameter not available on this platform');
      }
      if (parameter.type === 'GLenum') {
        value = getKeyValue(value);
      }
    }
    this._setParameter(pname, value);
    return this;
  }
  setParameters(parameters) {
    for (const pname in parameters) {
      this.setParameter(pname, parameters[pname]);
    }
    return this;
  }
  stubRemovedMethods(className, version, methodNames) {
    return stubRemovedMethods(this, className, version, methodNames);
  }
  initialize(props) {}
  _createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _bindHandle(handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getOptsFromHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getParameter(pname, props) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _setParameter(pname, value) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
}
//# sourceMappingURL=webgl-resource.js.map