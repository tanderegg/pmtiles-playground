{"version":3,"file":"sampler-parameters.js","names":["convertCompareFunction","convertSamplerParametersToWebGL","props","params","addressModeU","convertAddressMode","addressModeV","addressModeW","magFilter","convertMaxFilterMode","minFilter","mipmapFilter","convertMinFilterMode","lodMinClamp","undefined","lodMaxClamp","type","compare","maxAnisotropy","updateSamplerParametersForNPOT","parameters","newParameters","addressMode","maxFilter"],"sources":["../../../src/adapter/converters/sampler-parameters.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\n// SAMPLER FILTERS\nimport {SamplerProps} from '@luma.gl/core';\nimport {GL, GLSamplerParameters} from '@luma.gl/constants';\nimport {convertCompareFunction} from './device-parameters';\n\n/**\n * Convert WebGPU-style sampler props to WebGL\n * @param props\n * @returns\n */\nexport function convertSamplerParametersToWebGL(props: SamplerProps): GLSamplerParameters {\n  const params: GLSamplerParameters = {};\n  if (props.addressModeU) {\n    params[GL.TEXTURE_WRAP_S] = convertAddressMode(props.addressModeU);\n  }\n  if (props.addressModeV) {\n    params[GL.TEXTURE_WRAP_T] = convertAddressMode(props.addressModeV);\n  }\n  if (props.addressModeW) {\n    params[GL.TEXTURE_WRAP_R] = convertAddressMode(props.addressModeW);\n  }\n  if (props.magFilter) {\n    params[GL.TEXTURE_MAG_FILTER] = convertMaxFilterMode(props.magFilter);\n  }\n  if (props.minFilter || props.mipmapFilter) {\n    // TODO - arbitrary choice of linear?\n    params[GL.TEXTURE_MIN_FILTER] = convertMinFilterMode(\n      props.minFilter || 'linear',\n      props.mipmapFilter\n    );\n  }\n  if (props.lodMinClamp !== undefined) {\n    params[GL.TEXTURE_MIN_LOD] = props.lodMinClamp;\n  }\n  if (props.lodMaxClamp !== undefined) {\n    params[GL.TEXTURE_MAX_LOD] = props.lodMaxClamp;\n  }\n  if (props.type === 'comparison-sampler') {\n    // Setting prop.compare turns this into a comparison sampler\n    params[GL.TEXTURE_COMPARE_MODE] = GL.COMPARE_REF_TO_TEXTURE;\n  }\n  if (props.compare) {\n    params[GL.TEXTURE_COMPARE_FUNC] = convertCompareFunction('compare', props.compare);\n  }\n  // Note depends on WebGL extension\n  if (props.maxAnisotropy) {\n    params[GL.TEXTURE_MAX_ANISOTROPY_EXT] = props.maxAnisotropy;\n  }\n  return params;\n}\n\n/**\n * Override sampler settings that are not supported by Non-Power-of-Two textures in WebGL1.\n */\nexport function updateSamplerParametersForNPOT(\n  parameters: GLSamplerParameters\n): GLSamplerParameters {\n  const newParameters = {...parameters};\n  if (parameters[GL.TEXTURE_MIN_FILTER] !== GL.NEAREST) {\n    // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n    newParameters[GL.TEXTURE_MIN_FILTER] = GL.LINEAR;\n  }\n  // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_S to CLAMP_TO_EDGE`)();\n  newParameters[GL.TEXTURE_WRAP_S] = GL.CLAMP_TO_EDGE;\n  newParameters[GL.TEXTURE_WRAP_T] = GL.CLAMP_TO_EDGE;\n  return newParameters;\n}\n\n// HELPERS\n\n/** Convert address more */\nfunction convertAddressMode(addressMode: 'clamp-to-edge' | 'repeat' | 'mirror-repeat'): GL.CLAMP_TO_EDGE | GL.REPEAT | GL.MIRRORED_REPEAT {\n  switch (addressMode) {\n    case 'clamp-to-edge':\n      return GL.CLAMP_TO_EDGE;\n    case 'repeat':\n      return GL.REPEAT;\n    case 'mirror-repeat':\n      return GL.MIRRORED_REPEAT;\n  }\n}\n\nfunction convertMaxFilterMode(maxFilter: 'nearest' | 'linear'): GL.NEAREST | GL.LINEAR {\n  switch (maxFilter) {\n    case 'nearest':\n      return GL.NEAREST;\n    case 'linear':\n      return GL.LINEAR;\n  }\n}\n\n/**\n * WebGPU has separate min filter and mipmap filter,\n * WebGL is combined and effectively offers 6 options\n */\nfunction convertMinFilterMode(\n  minFilter: 'nearest' | 'linear',\n  mipmapFilter?: 'nearest' | 'linear'\n): GL.NEAREST | GL.LINEAR | GL.NEAREST_MIPMAP_NEAREST | GL.LINEAR_MIPMAP_NEAREST | GL.NEAREST_MIPMAP_LINEAR | GL.LINEAR_MIPMAP_LINEAR {\n  if (!mipmapFilter) {\n    return convertMaxFilterMode(minFilter);\n  }\n  switch (minFilter) {\n    case 'nearest':\n      return mipmapFilter === 'nearest' ? GL.NEAREST_MIPMAP_NEAREST : GL.NEAREST_MIPMAP_LINEAR;\n    case 'linear':\n      return mipmapFilter === 'nearest' ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR_MIPMAP_LINEAR;\n  }\n}\n"],"mappings":"SAMQA,sBAAsB;AAO9B,OAAO,SAASC,+BAA+BA,CAACC,KAAmB,EAAuB;EACxF,MAAMC,MAA2B,GAAG,CAAC,CAAC;EACtC,IAAID,KAAK,CAACE,YAAY,EAAE;IACtBD,MAAM,OAAmB,GAAGE,kBAAkB,CAACH,KAAK,CAACE,YAAY,CAAC;EACpE;EACA,IAAIF,KAAK,CAACI,YAAY,EAAE;IACtBH,MAAM,OAAmB,GAAGE,kBAAkB,CAACH,KAAK,CAACI,YAAY,CAAC;EACpE;EACA,IAAIJ,KAAK,CAACK,YAAY,EAAE;IACtBJ,MAAM,OAAmB,GAAGE,kBAAkB,CAACH,KAAK,CAACK,YAAY,CAAC;EACpE;EACA,IAAIL,KAAK,CAACM,SAAS,EAAE;IACnBL,MAAM,OAAuB,GAAGM,oBAAoB,CAACP,KAAK,CAACM,SAAS,CAAC;EACvE;EACA,IAAIN,KAAK,CAACQ,SAAS,IAAIR,KAAK,CAACS,YAAY,EAAE;IAEzCR,MAAM,OAAuB,GAAGS,oBAAoB,CAClDV,KAAK,CAACQ,SAAS,IAAI,QAAQ,EAC3BR,KAAK,CAACS,YACR,CAAC;EACH;EACA,IAAIT,KAAK,CAACW,WAAW,KAAKC,SAAS,EAAE;IACnCX,MAAM,OAAoB,GAAGD,KAAK,CAACW,WAAW;EAChD;EACA,IAAIX,KAAK,CAACa,WAAW,KAAKD,SAAS,EAAE;IACnCX,MAAM,OAAoB,GAAGD,KAAK,CAACa,WAAW;EAChD;EACA,IAAIb,KAAK,CAACc,IAAI,KAAK,oBAAoB,EAAE;IAEvCb,MAAM,OAAyB,QAA4B;EAC7D;EACA,IAAID,KAAK,CAACe,OAAO,EAAE;IACjBd,MAAM,OAAyB,GAAGH,sBAAsB,CAAC,SAAS,EAAEE,KAAK,CAACe,OAAO,CAAC;EACpF;EAEA,IAAIf,KAAK,CAACgB,aAAa,EAAE;IACvBf,MAAM,OAA+B,GAAGD,KAAK,CAACgB,aAAa;EAC7D;EACA,OAAOf,MAAM;AACf;AAKA,OAAO,SAASgB,8BAA8BA,CAC5CC,UAA+B,EACV;EACrB,MAAMC,aAAa,GAAG;IAAC,GAAGD;EAAU,CAAC;EACrC,IAAIA,UAAU,OAAuB,SAAe,EAAE;IAEpDC,aAAa,OAAuB,OAAY;EAClD;EAEAA,aAAa,OAAmB,QAAmB;EACnDA,aAAa,OAAmB,QAAmB;EACnD,OAAOA,aAAa;AACtB;AAKA,SAAShB,kBAAkBA,CAACiB,WAAyD,EAAqD;EACxI,QAAQA,WAAW;IACjB,KAAK,eAAe;MAClB;IACF,KAAK,QAAQ;MACX;IACF,KAAK,eAAe;MAClB;EACJ;AACF;AAEA,SAASb,oBAAoBA,CAACc,SAA+B,EAA0B;EACrF,QAAQA,SAAS;IACf,KAAK,SAAS;MACZ;IACF,KAAK,QAAQ;MACX;EACJ;AACF;AAMA,SAASX,oBAAoBA,CAC3BF,SAA+B,EAC/BC,YAAmC,EACiG;EACpI,IAAI,CAACA,YAAY,EAAE;IACjB,OAAOF,oBAAoB,CAACC,SAAS,CAAC;EACxC;EACA,QAAQA,SAAS;IACf,KAAK,SAAS;MACZ,OAAOC,YAAY,KAAK,SAAS,cAAuD;IAC1F,KAAK,QAAQ;MACX,OAAOA,YAAY,KAAK,SAAS,cAAqD;EAC1F;AACF"}