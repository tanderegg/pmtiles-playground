import type { TextureFormat, DeviceFeature } from '@luma.gl/core';
import { GL } from '@luma.gl/constants';
export declare function checkTextureFeature(gl: WebGLRenderingContext, feature: DeviceFeature): boolean;
/** Return a list of texture feature strings (for Device.features). Mainly compressed texture support */
export declare function getTextureFeatures(gl: WebGLRenderingContext): DeviceFeature[];
/** Map a format to webgl and constants */
type Format = {
    gl?: GL;
    /** If a different unsized format is needed in WebGL1 */
    gl1?: GL;
    gl1ext?: string;
    /** format requires WebGL2, when using a WebGL 1 context, color renderbuffer formats are limited */
    gl2ext?: string;
    /** (bytes per pixel), for memory usage calculations. */
    b?: number;
    /** channels */
    c?: number;
    bpp?: number;
    /** packed */
    p?: number;
    /** compressed */
    x?: string;
    /** for compressed texture formats */
    f?: DeviceFeature;
    /** renderable if feature is present */
    render?: DeviceFeature;
    /** filterable if feature is present */
    filter?: DeviceFeature;
    /** If not supported on WebGPU */
    wgpu?: false;
    types?: number[];
    dataFormat?: GL;
    /** Depth and stencil format attachment points. If set, needs to be a Renderbuffer unless depthTexture is set  */
    attachment?: GL.DEPTH_ATTACHMENT | GL.STENCIL_ATTACHMENT | GL.DEPTH_STENCIL_ATTACHMENT;
    /** if depthTexture is set this is a depth/stencil format that can be set to a texture  */
    depthTexture?: boolean;
    renderbuffer?: boolean;
};
/**
 * Texture format data -
 * Exported but can change without notice
 */
export declare const TEXTURE_FORMATS: Record<TextureFormat, Format>;
/** Checks if a texture format is supported */
export declare function isTextureFormatSupported(gl: WebGLRenderingContext, formatOrGL: TextureFormat | GL): boolean;
export declare function isRenderbufferFormatSupported(gl: WebGLRenderingContext, format: TextureFormat): boolean;
/**
 * Map WebGL texture formats (GL constants) to WebGPU-style TextureFormat strings
 */
export declare function convertGLToTextureFormat(format: GL | TextureFormat): TextureFormat;
/**
 * Map WebGPU style texture format strings to GL constants
 */
export declare function convertTextureFormatToGL(format: TextureFormat, isWebGL2: boolean): GL | undefined;
/** Checks if a texture format is supported */
export declare function getTextureFormatSupport(gl: WebGLRenderingContext, formatOrGL: TextureFormat | GL): {
    supported: boolean;
    filterable?: boolean;
    renderable?: boolean;
    blendable?: boolean;
    storable?: boolean;
};
/** Checks whether linear filtering (interpolated sampling) is available for floating point textures */
export declare function isTextureFormatFilterable(gl: WebGLRenderingContext, formatOrGL: TextureFormat | GL): boolean;
export declare function isTextureFormatRenderable(gl: WebGLRenderingContext, formatOrGL: TextureFormat | GL): boolean;
export declare function getWebGLTextureParameters(formatOrGL: TextureFormat | GL, isWebGL2: boolean): {
    format: GL;
    dataFormat: GL;
    type: GL.BYTE | GL.UNSIGNED_BYTE | GL.SHORT | GL.UNSIGNED_SHORT | GL.INT | GL.UNSIGNED_INT | GL.FLOAT | GL.HALF_FLOAT;
    compressed: any;
};
export declare function getDepthStencilAttachmentWebGL(format: TextureFormat): GL.DEPTH_ATTACHMENT | GL.STENCIL_ATTACHMENT | GL.DEPTH_STENCIL_ATTACHMENT;
/**
 * function to test if Float 32 bit format texture can be bound as color attachment
 * @todo Generalize to check arbitrary formats?
 */
export declare function _checkFloat32ColorAttachment(gl: WebGLRenderingContext, internalFormat?: 6408, srcFormat?: GL, srcType?: GL): boolean;
/** TODO - VERY roundabout legacy way of calculating bytes per pixel */
export declare function getTextureFormatBytesPerPixel(formatOrGL: TextureFormat | GL, isWebGL2: boolean): number;
export {};
//# sourceMappingURL=texture-formats.d.ts.map