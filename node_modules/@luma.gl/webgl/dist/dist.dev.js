(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['luma'] = factory();
  else root['luma'] = factory();})(globalThis, function () {
var __exports__ = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Accessor: () => Accessor,
    WEBGLBuffer: () => WEBGLBuffer,
    WEBGLCommandEncoder: () => WEBGLCommandEncoder,
    WEBGLFramebuffer: () => WEBGLFramebuffer,
    WEBGLRenderPass: () => WEBGLRenderPass,
    WEBGLRenderPipeline: () => WEBGLRenderPipeline,
    WEBGLRenderbuffer: () => WEBGLRenderbuffer,
    WEBGLResource: () => WebGLResource,
    WEBGLSampler: () => WEBGLSampler,
    WEBGLShader: () => WEBGLShader,
    WEBGLTexture: () => WEBGLTexture,
    WEBGLTransformFeedback: () => WEBGLTransformFeedback,
    WEBGLVertexArray: () => WEBGLVertexArray,
    WebGLCanvasContext: () => WebGLCanvasContext,
    WebGLDevice: () => WebGLDevice,
    WebGLResource: () => WebGLResource,
    _TEXTURE_FORMATS: () => TEXTURE_FORMATS,
    _checkFloat32ColorAttachment: () => _checkFloat32ColorAttachment,
    assertWebGL2Context: () => assertWebGL2Context,
    assertWebGLContext: () => assertWebGLContext,
    convertGLToTextureFormat: () => convertGLToTextureFormat,
    getGLParameters: () => getGLParameters,
    getShaderLayout: () => getShaderLayout,
    getWebGL2Context: () => getWebGL2Context,
    isWebGL: () => isWebGL,
    isWebGL2: () => isWebGL2,
    polyfillContext: () => polyfillContext,
    popContextState: () => popContextState,
    pushContextState: () => pushContextState,
    registerHeadlessGL: () => registerHeadlessGL,
    resetGLParameters: () => resetGLParameters,
    setDeviceParameters: () => setDeviceParameters,
    setGLParameters: () => setGLParameters,
    trackContextState: () => trackContextState,
    withDeviceParameters: () => withDeviceParameters,
    withGLParameters: () => withGLParameters
  });

  // src/context/context/create-headless-context.ts
  var ERR_HEADLESSGL_FAILED = "Failed to create WebGL context in Node.js, headless gl returned null";
  var ERR_HEADLESSGL_LOAD = "  luma.gl: loaded under Node.js without headless gl installed, meaning that WebGL   contexts can not be created. This may not be an error. For example, this is a   typical configuration for isorender applications running on the server.";
  var CONTEXT_DEFAULTS = {
    width: 1,
    height: 1,
    debug: true,
    throwOnError: false
  };
  var headlessGL = null;
  function registerHeadlessGL(headlessgl) {
    headlessGL = headlessgl;
  }
  function isHeadlessGLRegistered() {
    return headlessGL !== null;
  }
  function createHeadlessContext(options) {
    options = {
      ...CONTEXT_DEFAULTS,
      ...options
    };
    const {
      width,
      height,
      webgl1,
      webgl2
    } = options;
    if (webgl2 && !webgl1) {
      throw new Error("headless-gl does not support WebGL2");
    }
    if (!headlessGL) {
      throw new Error(ERR_HEADLESSGL_LOAD);
    }
    const gl = headlessGL(width, height, options);
    if (!gl) {
      throw new Error(ERR_HEADLESSGL_FAILED);
    }
    return gl;
  }

  // ../../node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    if (userAgent && userAgent.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/env/dist/lib/globals.js
  var self_ = globalThis.self || globalThis.window || globalThis.global;
  var window_ = globalThis.window || globalThis.self || globalThis.global;
  var document_ = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // ../../node_modules/@probe.gl/env/dist/utils/globals.js
  var VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser2 = isBrowser();

  // ../../node_modules/@probe.gl/env/dist/lib/get-browser.js
  var window2 = globalThis;
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser()) {
      return "Node";
    }
    if (isElectron(mockUserAgent)) {
      return "Electron";
    }
    const userAgent = mockUserAgent || navigator_.userAgent || "";
    if (userAgent.indexOf("Edge") > -1) {
      return "Edge";
    }
    const isMSIE = userAgent.indexOf("MSIE ") !== -1;
    const isTrident = userAgent.indexOf("Trident/") !== -1;
    if (isMSIE || isTrident) {
      return "IE";
    }
    if (window2.chrome) {
      return "Chrome";
    }
    if (window2.safari) {
      return "Safari";
    }
    if (window2.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // ../../node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id, defaultConfig) {
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      this.storage = void 0;
      this.id = void 0;
      this.config = void 0;
      this.storage = getStorage(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad(string) {
    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage(image, message2, scale) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale = Math.min(scale, maxWidth / image.width);
    }
    const width = image.width * scale;
    const height = image.height * scale;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message2, " %c+"), style];
  }

  // ../../node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR2) {
    COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
    COLOR2[COLOR2["RED"] = 31] = "RED";
    COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
    COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
    COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
    COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
    COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
    COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
    COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string, color, background) {
    if (!isBrowser && typeof string === "string") {
      if (color) {
        const colorCode = getColor(color);
        string = "\x1B[".concat(colorCode, "m").concat(string, "\x1B[39m");
      }
      if (background) {
        const colorCode = getColor(background);
        string = "\x1B[".concat(colorCode + BACKGROUND_INCREMENT, "m").concat(string, "\x1B[49m");
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
      const value = object[key];
      if (typeof value === "function") {
        if (!predefined.find((name2) => key === name2)) {
          object[key] = value.bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/assert.js
  function assert(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (isBrowser() && window_.performance) {
      var _window$performance, _window$performance$n;
      timestamp = window_ === null || window_ === void 0 ? void 0 : (_window$performance = window_.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_) {
      var _process$hrtime;
      const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  var Log = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      this.id = void 0;
      this.VERSION = VERSION;
      this._startTs = getHiResTimestamp();
      this._deltaTs = getHiResTimestamp();
      this._storage = void 0;
      this.userData = {};
      this.LOG_THROTTLE_TIMEOUT = 0;
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_LOG_CONFIGURATION);
      this.timeStamp("".concat(this.id, " started"));
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.setConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.setConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message2) {
      assert(condition, message2);
    }
    warn(message2) {
      return this._getLogFunction(0, message2, originalConsole.warn, arguments, ONCE);
    }
    error(message2) {
      return this._getLogFunction(0, message2, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.debug, arguments);
    }
    info(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.info, arguments);
    }
    once(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message: message2 = "",
        scale = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }
      return isBrowser() ? logImageInBrowser({
        image,
        message: message2,
        scale
      }) : logImageInNode({
        image,
        message: message2,
        scale
      });
    }
    time(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeStamp || noop);
    }
    group(logLevel, message2) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments({
        logLevel,
        message: message2,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message2) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message2, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message2, func) {
      this.group(logLevel, message2)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message2, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({
          logLevel,
          message: message2,
          args,
          opts
        });
        method = method || opts.method;
        assert(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp();
          } else {
            return noop;
          }
        }
        message2 = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message2, ...opts.args);
      }
      return noop;
    }
  };
  Log.VERSION = VERSION;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const {
      logLevel,
      message: message2
    } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message2) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message2 !== void 0) {
          args.unshift(message2);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage(id, message2, opts) {
    if (typeof message2 === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message2 = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message2) : "".concat(id, ": ").concat(message2);
      message2 = addColor(message2, opts.color, opts.background);
    }
    return message2;
  }
  function logImageInNode(_ref2) {
    let {
      image,
      message: message2 = "",
      scale = 1
    } = _ref2;
    console.warn("removed");
    return noop;
  }
  function logImageInBrowser(_ref3) {
    let {
      image,
      message: message2 = "",
      scale = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage(img, message2, scale);
        console.log(...args);
      };
      img.src = image;
      return noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage(image, message2, scale));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage(img, message2, scale));
      img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({
    id: "@probe.gl/log"
  });

  // ../core/src/utils/log.ts
  var log = new Log({
    id: "luma.gl"
  });

  // ../../node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/stats/dist/lib/stat.js
  var Stat = class {
    constructor(name2, type) {
      this.name = void 0;
      this.type = void 0;
      this.sampleSize = 1;
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      this.name = name2;
      this.type = type;
      this.reset();
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp2();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp2() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@probe.gl/stats/dist/lib/stats.js
  var Stats = class {
    constructor(options) {
      this.id = void 0;
      this.stats = {};
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name2) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name2,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const stat of Object.values(this.stats)) {
        stat.reset();
      }
      return this;
    }
    forEach(fn) {
      for (const stat of Object.values(this.stats)) {
        fn(stat);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      const {
        name: name2,
        type
      } = stat;
      let result = this.stats[name2];
      if (!result) {
        if (stat instanceof Stat) {
          result = stat;
        } else {
          result = new Stat(name2, type);
        }
        this.stats[name2] = result;
      }
      return result;
    }
  };

  // ../core/src/utils/stats-manager.ts
  var StatsManager = class {
    stats = /* @__PURE__ */ new Map();
    getStats(name2) {
      return this.get(name2);
    }
    get(name2) {
      if (!this.stats.has(name2)) {
        this.stats.set(name2, new Stats({
          id: name2
        }));
      }
      return this.stats.get(name2);
    }
  };
  var lumaStats = new StatsManager();

  // ../core/src/init.ts
  function initializeLuma() {
    const VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "running from source";
    const STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
    if (globalThis.luma && globalThis.luma.VERSION !== VERSION3) {
      throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${VERSION3}`);
    }
    if (!globalThis.luma) {
      if (isBrowser()) {
        log.log(1, `${VERSION3} - ${STARTUP_MESSAGE}`)();
      }
      globalThis.luma = globalThis.luma || {
        VERSION: VERSION3,
        version: VERSION3,
        log,
        stats: lumaStats
      };
    }
    return VERSION3;
  }
  var VERSION2 = initializeLuma();

  // ../core/src/utils/is-array.ts
  function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView) ? value : null;
  }
  function isNumberArray(value) {
    if (Array.isArray(value)) {
      return value.length === 0 || typeof value[0] === "number" ? value : null;
    }
    return isTypedArray(value);
  }

  // ../core/src/utils/utils.ts
  var uidCounters = {};
  function uid(id = "id") {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
  }
  function isPowerOfTwo(n) {
    return n > 0 && (n & n - 1) === 0;
  }
  function isObjectEmpty(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // ../core/src/adapter/resources/resource.ts
  var Resource = class {
    userData = {};
    destroyed = false;
    allocatedBytes = 0;
    _attachedResources = /* @__PURE__ */ new Set();
    constructor(device, props, defaultProps) {
      if (!device) {
        throw new Error("no device");
      }
      this._device = device;
      this.props = selectivelyMerge(props, defaultProps);
      const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
      this.props.id = id;
      this.id = id;
      this.userData = this.props.userData || {};
      this.addStats();
    }
    destroy() {
      this.destroyResource();
    }
    delete() {
      this.destroy();
      return this;
    }
    toString() {
      return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
    }
    getProps() {
      return this.props;
    }
    attachResource(resource) {
      this._attachedResources.add(resource);
    }
    detachResource(resource) {
      this._attachedResources.delete(resource);
    }
    destroyAttachedResource(resource) {
      if (this._attachedResources.delete(resource)) {
        resource.destroy();
      }
    }
    destroyAttachedResources() {
      for (const resource of Object.values(this._attachedResources)) {
        resource.destroy();
      }
      this._attachedResources = /* @__PURE__ */ new Set();
    }
    destroyResource() {
      this.destroyAttachedResources();
      this.removeStats();
      this.destroyed = true;
    }
    removeStats() {
      const stats = this._device.statsManager.getStats("Resource Counts");
      const name2 = this[Symbol.toStringTag];
      stats.get(`${name2}s Active`).decrementCount();
    }
    trackAllocatedMemory(bytes, name2 = this[Symbol.toStringTag]) {
      const stats = this._device.statsManager.getStats("Resource Counts");
      stats.get("GPU Memory").addCount(bytes);
      stats.get(`${name2} Memory`).addCount(bytes);
      this.allocatedBytes = bytes;
    }
    trackDeallocatedMemory(name2 = this[Symbol.toStringTag]) {
      const stats = this._device.statsManager.getStats("Resource Counts");
      stats.get("GPU Memory").subtractCount(this.allocatedBytes);
      stats.get(`${name2} Memory`).subtractCount(this.allocatedBytes);
      this.allocatedBytes = 0;
    }
    addStats() {
      const stats = this._device.statsManager.getStats("Resource Counts");
      const name2 = this[Symbol.toStringTag];
      stats.get("Resources Created").incrementCount();
      stats.get(`${name2}s Created`).incrementCount();
      stats.get(`${name2}s Active`).incrementCount();
    }
  };
  __publicField(Resource, "defaultProps", {
    id: "undefined",
    handle: void 0,
    userData: void 0
  });
  function selectivelyMerge(props, defaultProps) {
    const mergedProps = {
      ...defaultProps
    };
    for (const key in props) {
      if (props[key] !== void 0) {
        mergedProps[key] = props[key];
      }
    }
    return mergedProps;
  }

  // ../core/src/adapter/resources/buffer.ts
  var _Buffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    constructor(device, props) {
      const deducedProps = {
        ...props
      };
      if ((props.usage || 0) & _Buffer.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          deducedProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          deducedProps.indexType = "uint16";
        }
      }
      super(device, deducedProps, _Buffer.defaultProps);
      this.usage = props.usage || 0;
      this.indexType = deducedProps.indexType;
    }
    readSyncWebGL2(byteOffset, byteLength) {
      throw new Error("not implemented");
    }
    debugData = new ArrayBuffer(0);
    _setDebugData(data, byteOffset, byteLength) {
      const buffer = ArrayBuffer.isView(data) ? data.buffer : data;
      const debugDataLength = Math.min(data ? data.byteLength : byteLength, _Buffer.DEBUG_DATA_MAX_LENGTH);
      if (data === null) {
        this.debugData = new ArrayBuffer(debugDataLength);
      } else if (byteOffset === 0 && byteLength === data.byteLength) {
        this.debugData = buffer.slice(0, debugDataLength);
      } else {
        this.debugData = buffer.slice(byteOffset, byteOffset + debugDataLength);
      }
    }
  };
  var Buffer2 = _Buffer;
  __publicField(Buffer2, "defaultProps", {
    ...Resource.defaultProps,
    usage: 0,
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: false
  });
  __publicField(Buffer2, "MAP_READ", 1);
  __publicField(Buffer2, "MAP_WRITE", 2);
  __publicField(Buffer2, "COPY_SRC", 4);
  __publicField(Buffer2, "COPY_DST", 8);
  __publicField(Buffer2, "INDEX", 16);
  __publicField(Buffer2, "VERTEX", 32);
  __publicField(Buffer2, "UNIFORM", 64);
  __publicField(Buffer2, "STORAGE", 128);
  __publicField(Buffer2, "INDIRECT", 256);
  __publicField(Buffer2, "QUERY_RESOLVE", 512);
  __publicField(Buffer2, "DEBUG_DATA_MAX_LENGTH", 32);

  // ../core/src/adapter/device.ts
  var _Device = class {
    get [Symbol.toStringTag]() {
      return "Device";
    }
    constructor(props) {
      this.props = {
        ..._Device.defaultProps,
        ...props
      };
      this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
    }
    statsManager = lumaStats;
    userData = {};
    _lumaData = {};
    loseDevice() {
      return false;
    }
    getCanvasContext() {
      if (!this.canvasContext) {
        throw new Error("Device has no CanvasContext");
      }
      return this.canvasContext;
    }
    createTexture(props) {
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      return this._createTexture(props);
    }
    createCommandEncoder(props = {}) {
      throw new Error("not implemented");
    }
    readPixelsToArrayWebGL(source, options) {
      throw new Error("not implemented");
    }
    readPixelsToBufferWebGL(source, options) {
      throw new Error("not implemented");
    }
    setParametersWebGL(parameters) {
      throw new Error("not implemented");
    }
    getParametersWebGL(parameters) {
      throw new Error("not implemented");
    }
    withParametersWebGL(parameters, func) {
      throw new Error("not implemented");
    }
    clearWebGL(options) {
      throw new Error("not implemented");
    }
    _getBufferProps(props) {
      if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      const newProps = {
        ...props
      };
      if ((props.usage || 0) & Buffer2.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          newProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          newProps.indexType = "uint16";
        } else {
          log.warn("indices buffer content must be of integer type")();
        }
      }
      return newProps;
    }
  };
  var Device = _Device;
  __publicField(Device, "defaultProps", {
    id: null,
    type: "best-available",
    canvas: null,
    container: null,
    webgl2: true,
    webgl1: true,
    manageState: true,
    width: 800,
    height: 600,
    debug: Boolean(log.get("debug")),
    break: [],
    gl: null
  });
  __publicField(Device, "VERSION", VERSION2);

  // ../core/src/utils/assert.ts
  function assert2(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "luma.gl: assertion failed.");
    }
  }

  // ../core/src/adapter/canvas-context.ts
  var isPage = isBrowser() && typeof document !== "undefined";
  var isPageLoaded = () => isPage && document.readyState === "complete";
  var DEFAULT_CANVAS_CONTEXT_PROPS = {
    canvas: null,
    width: 800,
    height: 600,
    useDevicePixels: true,
    autoResize: true,
    container: null,
    visible: true,
    colorSpace: "srgb",
    alphaMode: "opaque"
  };
  var CanvasContext = class {
    width = 1;
    height = 1;
    _canvasSizeInfo = {
      clientWidth: 0,
      clientHeight: 0,
      devicePixelRatio: 1
    };
    static get isPageLoaded() {
      return isPageLoaded();
    }
    constructor(props) {
      this.props = {
        ...DEFAULT_CANVAS_CONTEXT_PROPS,
        ...props
      };
      props = this.props;
      if (!isBrowser()) {
        this.id = "node-canvas-context";
        this.type = "node";
        this.width = this.props.width;
        this.height = this.props.height;
        this.canvas = null;
        return;
      }
      if (!props.canvas) {
        const canvas = createCanvas(props);
        const container = getContainer(props?.container || null);
        container.insertBefore(canvas, container.firstChild);
        this.canvas = canvas;
        if (!props?.visible) {
          this.canvas.style.visibility = "hidden";
        }
      } else if (typeof props.canvas === "string") {
        this.canvas = getCanvasFromDOM(props.canvas);
      } else {
        this.canvas = props.canvas;
      }
      if (this.canvas instanceof HTMLCanvasElement) {
        this.id = this.canvas.id;
        this.type = "html-canvas";
        this.htmlCanvas = this.canvas;
      } else {
        this.id = "offscreen-canvas";
        this.type = "offscreen-canvas";
        this.offscreenCanvas = this.canvas;
      }
      if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {
        this.resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            if (entry.target === this.canvas) {
              this.update();
            }
          }
        });
        this.resizeObserver.observe(this.canvas);
      }
    }
    getDevicePixelRatio(useDevicePixels) {
      if (typeof OffscreenCanvas !== "undefined" && this.canvas instanceof OffscreenCanvas) {
        return 1;
      }
      useDevicePixels = useDevicePixels === void 0 ? this.props.useDevicePixels : useDevicePixels;
      if (!useDevicePixels || useDevicePixels <= 0) {
        return 1;
      }
      if (useDevicePixels === true) {
        const dpr = typeof window !== "undefined" && window.devicePixelRatio;
        return dpr || 1;
      }
      return useDevicePixels;
    }
    getPixelSize() {
      switch (this.type) {
        case "node":
          return [this.width, this.height];
        case "offscreen-canvas":
          return [this.canvas.width, this.canvas.height];
        case "html-canvas":
          const dpr = this.getDevicePixelRatio();
          const canvas = this.canvas;
          return canvas.parentElement ? [canvas.clientWidth * dpr, canvas.clientHeight * dpr] : [this.canvas.width, this.canvas.height];
        default:
          throw new Error(this.type);
      }
    }
    getAspect() {
      const [width, height] = this.getPixelSize();
      return width / height;
    }
    cssToDeviceRatio() {
      try {
        const [drawingBufferWidth] = this.getDrawingBufferSize();
        const {
          clientWidth
        } = this._canvasSizeInfo;
        return clientWidth ? drawingBufferWidth / clientWidth : 1;
      } catch {
        return 1;
      }
    }
    cssToDevicePixels(cssPixel, yInvert = true) {
      const ratio = this.cssToDeviceRatio();
      const [width, height] = this.getDrawingBufferSize();
      return scalePixels(cssPixel, ratio, width, height, yInvert);
    }
    setDevicePixelRatio(devicePixelRatio, options = {}) {
      if (!this.htmlCanvas) {
        return;
      }
      let clientWidth = "width" in options ? options.width : this.htmlCanvas.clientWidth;
      let clientHeight = "height" in options ? options.height : this.htmlCanvas.clientHeight;
      if (!clientWidth || !clientHeight) {
        log.log(1, "Canvas clientWidth/clientHeight is 0")();
        devicePixelRatio = 1;
        clientWidth = this.htmlCanvas.width || 1;
        clientHeight = this.htmlCanvas.height || 1;
      }
      const cachedSize = this._canvasSizeInfo;
      if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
        let clampedPixelRatio = devicePixelRatio;
        const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
        const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
        this.htmlCanvas.width = canvasWidth;
        this.htmlCanvas.height = canvasHeight;
        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();
        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {
          clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);
          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);
          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);
          log.warn("Device pixel ratio clamped")();
        }
        this._canvasSizeInfo.clientWidth = clientWidth;
        this._canvasSizeInfo.clientHeight = clientHeight;
        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;
      }
    }
    getDrawingBufferSize() {
      const gl = this.device.gl;
      if (!gl) {
        throw new Error("canvas size");
      }
      return [gl.drawingBufferWidth, gl.drawingBufferHeight];
    }
    _setAutoCreatedCanvasId(id) {
      if (this.htmlCanvas?.id === "lumagl-auto-created-canvas") {
        this.htmlCanvas.id = id;
      }
    }
  };
  __publicField(CanvasContext, "pageLoaded", getPageLoadPromise());
  function getPageLoadPromise() {
    if (isPageLoaded() || typeof window === "undefined") {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      window.addEventListener("load", () => resolve());
    });
  }
  function getContainer(container) {
    if (typeof container === "string") {
      const element = document.getElementById(container);
      if (!element && !isPageLoaded()) {
        throw new Error(`Accessing '${container}' before page was loaded`);
      }
      if (!element) {
        throw new Error(`${container} is not an HTML element`);
      }
      return element;
    } else if (container) {
      return container;
    }
    return document.body;
  }
  function getCanvasFromDOM(canvasId) {
    const canvas = document.getElementById(canvasId);
    if (!canvas && !isPageLoaded()) {
      throw new Error(`Accessing '${canvasId}' before page was loaded`);
    }
    if (!(canvas instanceof HTMLCanvasElement)) {
      throw new Error("Object is not a canvas element");
    }
    return canvas;
  }
  function createCanvas(props) {
    const {
      width,
      height
    } = props;
    const targetCanvas = document.createElement("canvas");
    targetCanvas.id = "lumagl-auto-created-canvas";
    targetCanvas.width = width || 1;
    targetCanvas.height = height || 1;
    targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : "100%";
    targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : "100%";
    return targetCanvas;
  }
  function scalePixels(pixel, ratio, width, height, yInvert) {
    const point = pixel;
    const x = scaleX(point[0], ratio, width);
    let y = scaleY(point[1], ratio, height, yInvert);
    let t = scaleX(point[0] + 1, ratio, width);
    const xHigh = t === width - 1 ? t : t - 1;
    t = scaleY(point[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
      t = t === 0 ? t : t + 1;
      yHigh = y;
      y = t;
    } else {
      yHigh = t === height - 1 ? t : t - 1;
    }
    return {
      x,
      y,
      width: Math.max(xHigh - x + 1, 1),
      height: Math.max(yHigh - y + 1, 1)
    };
  }
  function scaleX(x, ratio, width) {
    const r = Math.min(Math.round(x * ratio), width - 1);
    return r;
  }
  function scaleY(y, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
  }

  // ../core/src/adapter/resources/texture.ts
  var _Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    constructor(device, props, defaultProps = _Texture.defaultProps) {
      super(device, props, defaultProps);
      this.dimension = this.props.dimension;
      this.format = this.props.format;
      this.width = this.props.width;
      this.height = this.props.height;
      this.depth = this.props.depth;
    }
  };
  var Texture = _Texture;
  __publicField(Texture, "defaultProps", {
    ...Resource.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: true,
    sampler: {},
    compressed: false,
    usage: 0,
    mipLevels: void 0,
    samples: void 0,
    type: void 0
  });
  __publicField(Texture, "COPY_SRC", 1);
  __publicField(Texture, "COPY_DST", 2);
  __publicField(Texture, "TEXTURE_BINDING", 4);
  __publicField(Texture, "STORAGE_BINDING", 8);
  __publicField(Texture, "RENDER_ATTACHMENT", 16);

  // ../core/src/lib/compiler-log/format-compiler-log.ts
  function formatCompilerLog(shaderLog, source, options) {
    let formattedLog = "";
    const lines = source.split(/\r?\n/);
    const log3 = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);
    switch (options?.showSourceCode || "no") {
      case "all":
        let currentMessage = 0;
        for (let lineNum = 1; lineNum <= lines.length; lineNum++) {
          formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
          while (log3.length > currentMessage && log3[currentMessage].lineNum === lineNum) {
            const message2 = log3[currentMessage++];
            formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
              ...options,
              inlineSource: false
            });
          }
        }
        return formattedLog;
      case "issues":
      case "no":
        for (const message2 of shaderLog) {
          formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
            inlineSource: options?.showSourceCode !== "no"
          });
        }
        return formattedLog;
    }
  }
  function formatCompilerMessage(message2, lines, lineNum, options) {
    if (options?.inlineSource) {
      const numberedLines = getNumberedLines(lines, lineNum);
      const positionIndicator = message2.linePos > 0 ? `${" ".repeat(message2.linePos + 5)}^^^
` : "";
      return `
${numberedLines}${positionIndicator}${message2.type.toUpperCase()}: ${message2.message}

`;
    }
    return options?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${message2.type.toUpperCase()}: ${message2.message}</b></div>` : `${message2.type.toUpperCase()}: ${message2.message}`;
  }
  function getNumberedLines(lines, lineNum, options) {
    let numberedLines = "";
    for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {
      const sourceLine = lines[lineIndex - 1];
      if (sourceLine !== void 0) {
        numberedLines += getNumberedLine(sourceLine, lineNum, options);
      }
    }
    return numberedLines;
  }
  function getNumberedLine(line, lineNum, options) {
    const escapedLine = options?.html ? escapeHTML(line) : line;
    return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? "<br/>" : "\n"}`;
  }
  function padLeft(string, paddedLength) {
    let result = "";
    for (let i = string.length; i < paddedLength; ++i) {
      result += " ";
    }
    return result + string;
  }
  function escapeHTML(unsafe) {
    return unsafe.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
  }

  // ../core/src/lib/compiler-log/get-shader-info.ts
  function getShaderInfo(source, defaultName) {
    return {
      name: getShaderName(source, defaultName),
      language: "glsl",
      version: getShaderVersion(source)
    };
  }
  function getShaderName(shader, defaultName = "unnamed") {
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
  }
  function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words && words.length >= 2 && words[0] === "#version") {
      const v = parseInt(words[1], 10);
      if (Number.isFinite(v)) {
        version = v;
      }
    }
    return version;
  }

  // ../core/src/adapter/resources/shader.ts
  var _Shader = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    compilationStatus = "pending";
    constructor(device, props) {
      super(device, {
        id: getShaderIdFromProps(props),
        ...props
      }, _Shader.defaultProps);
      this.stage = this.props.stage;
      this.source = this.props.source;
    }
    getCompilationInfoSync() {
      return null;
    }
    async debugShader() {
      switch (this.props.debug) {
        case "never":
          return;
        case "errors":
          if (this.compilationStatus === "success") {
            return;
          }
          break;
        case "warnings":
        case "always":
          break;
      }
      const messages = await this.getCompilationInfo();
      if (this.props.debug === "warnings" && messages?.length === 0) {
        return;
      }
      this._displayShaderLog(messages);
    }
    _displayShaderLog(messages) {
      if (typeof document === "undefined" || !document?.createElement) {
        return;
      }
      const shaderName = getShaderInfo(this.source).name;
      const shaderTitle = `${this.stage} ${shaderName}`;
      const htmlLog = formatCompilerLog(messages, this.source, {
        showSourceCode: "all",
        html: true
      });
      const button = document.createElement("Button");
      button.innerHTML = `
<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />
<code style="user-select:text;"><pre>
${htmlLog}
</pre></code>`;
      button.style.top = "10px";
      button.style.left = "10px";
      button.style.position = "absolute";
      button.style.zIndex = "9999";
      button.style.width = "100%";
      button.style.textAlign = "left";
      document.body.appendChild(button);
      const errors = document.getElementsByClassName("luma-compiler-log-error");
      if (errors[0]?.scrollIntoView) {
        errors[0].scrollIntoView();
      }
      button.onclick = () => {
        const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;
        navigator.clipboard.writeText(dataURI);
      };
    }
  };
  var Shader = _Shader;
  __publicField(Shader, "defaultProps", {
    ...Resource.defaultProps,
    language: "auto",
    stage: "vertex",
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debug: "errors"
  });
  function getShaderIdFromProps(props) {
    return getShaderInfo(props.source).name || props.id || uid(`unnamed ${props.stage}-shader`);
  }

  // ../core/src/adapter/resources/sampler.ts
  var _Sampler = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Sampler";
    }
    constructor(device, props) {
      super(device, props, _Sampler.defaultProps);
    }
  };
  var Sampler = _Sampler;
  __publicField(Sampler, "defaultProps", {
    ...Resource.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "nearest",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    compare: "less-equal",
    maxAnisotropy: 1
  });

  // ../core/src/adapter/resources/framebuffer.ts
  var _Framebuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    colorAttachments = [];
    depthStencilAttachment = null;
    constructor(device, props = {}) {
      super(device, props, _Framebuffer.defaultProps);
      this.width = this.props.width;
      this.height = this.props.height;
    }
    resize(size) {
      let updateSize = !size;
      if (size) {
        const [width, height] = Array.isArray(size) ? size : [size.width, size.height];
        updateSize = updateSize || height !== this.height || width !== this.width;
        this.width = width;
        this.height = height;
      }
      if (updateSize) {
        log.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();
        this.resizeAttachments(this.width, this.height);
      }
    }
    autoCreateAttachmentTextures() {
      this.colorAttachments = this.props.colorAttachments.map((attachment) => {
        if (typeof attachment === "string") {
          const texture = this.createColorTexture(attachment);
          this.attachResource(texture);
          return texture;
        }
        return attachment;
      });
      if (this.props.depthStencilAttachment) {
        if (typeof this.props.depthStencilAttachment === "string") {
          const texture = this.createDepthStencilTexture(this.props.depthStencilAttachment);
          this.attachResource(texture);
          this.depthStencilAttachment = texture;
        } else {
          this.depthStencilAttachment = this.props.depthStencilAttachment;
        }
      }
    }
    createColorTexture(format) {
      return this.device.createTexture({
        id: "color-attachment",
        usage: Texture.RENDER_ATTACHMENT,
        format,
        width: this.width,
        height: this.height
      });
    }
    createDepthStencilTexture(format) {
      return this.device.createTexture({
        id: "depth-stencil-attachment",
        usage: Texture.RENDER_ATTACHMENT,
        format,
        width: this.width,
        height: this.height
      });
    }
    resizeAttachments(width, height) {
      for (let i = 0; i < this.colorAttachments.length; ++i) {
        if (this.colorAttachments[i]) {
          const resizedTexture = this.device._createTexture({
            ...this.colorAttachments[i].props,
            width,
            height
          });
          this.destroyAttachedResource(this.colorAttachments[i]);
          this.colorAttachments[i] = resizedTexture;
          this.attachResource(resizedTexture);
        }
      }
      if (this.depthStencilAttachment) {
        const resizedTexture = this.device._createTexture({
          ...this.depthStencilAttachment.props,
          width,
          height
        });
        this.destroyAttachedResource(this.depthStencilAttachment);
        this.depthStencilAttachment = resizedTexture;
        this.attachResource(resizedTexture);
      }
    }
  };
  var Framebuffer = _Framebuffer;
  __publicField(Framebuffer, "defaultProps", {
    ...Resource.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    depthStencilAttachment: null
  });

  // ../core/src/adapter/resources/render-pipeline.ts
  var _RenderPipeline = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPipeline";
    }
    hash = "";
    constructor(device, props) {
      super(device, props, _RenderPipeline.defaultProps);
      this.shaderLayout = this.props.shaderLayout;
      this.bufferLayout = this.props.bufferLayout || [];
    }
  };
  var RenderPipeline = _RenderPipeline;
  __publicField(RenderPipeline, "defaultProps", {
    ...Resource.defaultProps,
    vs: null,
    vsEntryPoint: "",
    vsConstants: {},
    fs: null,
    fsEntryPoint: "",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    vertexCount: 0,
    instanceCount: 0,
    bindings: {},
    uniforms: {}
  });

  // ../core/src/adapter/resources/render-pass.ts
  var _RenderPass = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPass";
    }
    constructor(device, props) {
      super(device, props, _RenderPass.defaultProps);
    }
  };
  var RenderPass = _RenderPass;
  __publicField(RenderPass, "defaultProps", {
    ...Resource.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: [0, 0, 0, 0],
    clearDepth: 1,
    clearStencil: 0,
    depthReadOnly: false,
    stencilReadOnly: false,
    discard: false
  });

  // ../core/src/adapter/resources/command-encoder.ts
  var _CommandEncoder = class extends Resource {
    get [Symbol.toStringTag]() {
      return "CommandEncoder";
    }
    constructor(device, props) {
      super(device, props, _CommandEncoder.defaultProps);
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
  };
  var CommandEncoder = _CommandEncoder;
  __publicField(CommandEncoder, "defaultProps", {
    ...Resource.defaultProps,
    measureExecutionTime: void 0
  });

  // ../core/src/adapter/resources/command-buffer.ts
  var _CommandBuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "CommandBuffer";
    }
    constructor(device, props) {
      super(device, props, _CommandBuffer.defaultProps);
    }
  };
  var CommandBuffer = _CommandBuffer;
  __publicField(CommandBuffer, "defaultProps", {
    ...Resource.defaultProps
  });

  // ../core/src/adapter/type-utils/decode-attribute-type.ts
  function decodeShaderAttributeType(attributeType) {
    const [dataType, components] = TYPE_INFO[attributeType];
    const integer = dataType === "i32" || dataType === "u32";
    const signed = dataType !== "u32";
    const byteLength = TYPE_SIZES[dataType] * components;
    const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
    return {
      dataType,
      components,
      defaultVertexFormat,
      byteLength,
      integer,
      signed
    };
  }
  function getCompatibleVertexFormat(dataType, components) {
    let vertexType;
    switch (dataType) {
      case "f32":
        vertexType = "float32";
        break;
      case "i32":
        vertexType = "sint32";
        break;
      case "u32":
        vertexType = "uint32";
        break;
      case "f16":
        return components <= 2 ? "float16x2" : "float16x4";
    }
    if (components === 1) {
      return vertexType;
    }
    return `${vertexType}x${components}`;
  }
  var TYPE_INFO = {
    f32: ["f32", 1],
    "vec2<f32>": ["f32", 2],
    "vec3<f32>": ["f32", 3],
    "vec4<f32>": ["f32", 4],
    f16: ["f16", 1],
    "vec2<f16>": ["f16", 2],
    "vec3<f16>": ["f16", 3],
    "vec4<f16>": ["f16", 4],
    i32: ["i32", 1],
    "vec2<i32>": ["i32", 2],
    "vec3<i32>": ["i32", 3],
    "vec4<i32>": ["i32", 4],
    u32: ["u32", 1],
    "vec2<u32>": ["u32", 2],
    "vec3<u32>": ["u32", 3],
    "vec4<u32>": ["u32", 4]
  };
  var TYPE_SIZES = {
    f32: 4,
    f16: 2,
    i32: 4,
    u32: 4
  };

  // ../core/src/adapter/type-utils/decode-data-type.ts
  function decodeVertexType(type) {
    const dataType = TYPE_MAP[type];
    const bytes = getDataTypeBytes(dataType);
    const normalized = type.includes("norm");
    const integer = !normalized && !type.startsWith("float");
    const signed = type.startsWith("s");
    return {
      dataType: TYPE_MAP[type],
      byteLength: bytes,
      integer,
      signed,
      normalized
    };
  }
  function getDataTypeBytes(type) {
    const bytes = TYPE_SIZES2[type];
    return bytes;
  }
  var TYPE_MAP = {
    uint8: "uint8",
    sint8: "sint8",
    unorm8: "uint8",
    snorm8: "sint8",
    uint16: "uint16",
    sint16: "sint16",
    unorm16: "uint16",
    snorm16: "sint16",
    float16: "float16",
    float32: "float32",
    uint32: "uint32",
    sint32: "sint32"
  };
  var TYPE_SIZES2 = {
    uint8: 1,
    sint8: 1,
    uint16: 2,
    sint16: 2,
    float16: 2,
    float32: 4,
    uint32: 4,
    sint32: 4
  };

  // ../core/src/adapter/type-utils/decode-vertex-format.ts
  function decodeVertexFormat(format) {
    let webglOnly;
    if (format.endsWith("-webgl")) {
      format.replace("-webgl", "");
      webglOnly = true;
    }
    const [type_, count] = format.split("x");
    const type = type_;
    const components = count ? parseInt(count) : 1;
    const decodedType = decodeVertexType(type);
    const result = {
      type,
      components,
      byteLength: decodedType.byteLength * components,
      integer: decodedType.integer,
      signed: decodedType.signed,
      normalized: decodedType.normalized
    };
    if (webglOnly) {
      result.webglOnly = true;
    }
    return result;
  }

  // ../core/src/adapter/attribute-utils/get-attribute-from-layouts.ts
  function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
    const attributeInfos = {};
    for (const attribute of shaderLayout.attributes) {
      attributeInfos[attribute.name] = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
    }
    return attributeInfos;
  }
  function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {
    const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
    const locationInfos = new Array(maxVertexAttributes).fill(null);
    for (const attributeInfo of Object.values(attributeInfos)) {
      locationInfos[attributeInfo.location] = attributeInfo;
    }
    return locationInfos;
  }
  function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name2) {
    const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name2);
    const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name2);
    if (!shaderDeclaration) {
      return null;
    }
    const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);
    const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;
    const vertexFormatInfo = decodeVertexFormat(vertexFormat);
    return {
      attributeName: bufferMapping?.attributeName || shaderDeclaration.name,
      bufferName: bufferMapping?.bufferName || shaderDeclaration.name,
      location: shaderDeclaration.location,
      shaderType: shaderDeclaration.type,
      shaderDataType: attributeTypeInfo.dataType,
      shaderComponents: attributeTypeInfo.components,
      vertexFormat,
      bufferDataType: vertexFormatInfo.type,
      bufferComponents: vertexFormatInfo.components,
      normalized: vertexFormatInfo.normalized,
      integer: attributeTypeInfo.integer,
      stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode,
      byteOffset: bufferMapping?.byteOffset || 0,
      byteStride: bufferMapping?.byteStride || 0
    };
  }
  function getAttributeFromShaderLayout(shaderLayout, name2) {
    const attribute = shaderLayout.attributes.find((attr) => attr.name === name2);
    if (!attribute) {
      log.warn(`shader layout attribute "${name2}" not present in shader`);
    }
    return attribute || null;
  }
  function getAttributeFromBufferLayout(bufferLayouts, name2) {
    checkBufferLayouts(bufferLayouts);
    let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name2);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name2);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    log.warn(`layout for attribute "${name2}" not present in buffer layout`);
    return null;
  }
  function checkBufferLayouts(bufferLayouts) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
        log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
      }
    }
  }
  function getAttributeFromShortHand(bufferLayouts, name2) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.format && bufferLayout.name === name2) {
        return {
          attributeName: bufferLayout.name,
          bufferName: name2,
          stepMode: bufferLayout.stepMode,
          vertexFormat: bufferLayout.format,
          byteOffset: 0,
          byteStride: bufferLayout.byteStride || 0
        };
      }
    }
    return null;
  }
  function getAttributeFromAttributesList(bufferLayouts, name2) {
    for (const bufferLayout of bufferLayouts) {
      let byteStride = bufferLayout.byteStride;
      if (typeof bufferLayout.byteStride !== "number") {
        for (const attributeMapping2 of bufferLayout.attributes || []) {
          const info = decodeVertexFormat(attributeMapping2.format);
          byteStride += info.byteLength;
        }
      }
      const attributeMapping = bufferLayout.attributes?.find((mapping) => mapping.attribute === name2);
      if (attributeMapping) {
        return {
          attributeName: attributeMapping.attribute,
          bufferName: bufferLayout.name,
          stepMode: bufferLayout.stepMode,
          vertexFormat: attributeMapping.format,
          byteOffset: attributeMapping.byteOffset,
          byteStride
        };
      }
    }
    return null;
  }
  function mergeShaderLayout(baseLayout, overrideLayout) {
    const mergedLayout = {
      ...baseLayout,
      attributes: baseLayout.attributes.map((attribute) => ({
        ...attribute
      }))
    };
    for (const attribute of overrideLayout?.attributes || []) {
      const baseAttribute = mergedLayout.attributes.find((attr) => attr.name === attribute.name);
      if (!baseAttribute) {
        log.warn(`shader layout attribute ${attribute.name} not present in shader`);
      } else {
        baseAttribute.type = attribute.type || baseAttribute.type;
        baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
      }
    }
    return mergedLayout;
  }

  // ../core/src/adapter/resources/vertex-array.ts
  var _VertexArray = class extends Resource {
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    indexBuffer = null;
    constructor(device, props) {
      super(device, props, _VertexArray.defaultProps);
      this.maxVertexAttributes = device.limits.maxVertexAttributes;
      this.attributes = new Array(this.maxVertexAttributes).fill(null);
      this.attributeInfos = getAttributeInfosByLocation(props.renderPipeline.shaderLayout, props.renderPipeline.bufferLayout, this.maxVertexAttributes);
    }
  };
  var VertexArray = _VertexArray;
  __publicField(VertexArray, "defaultProps", {
    ...Resource.defaultProps,
    renderPipeline: null
  });

  // ../core/src/adapter/resources/transform-feedback.ts
  var _TransformFeedback = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    constructor(device, props) {
      super(device, props, _TransformFeedback.defaultProps);
    }
  };
  var TransformFeedback = _TransformFeedback;
  __publicField(TransformFeedback, "defaultProps", {
    ...Resource.defaultProps,
    layout: void 0,
    buffers: {}
  });

  // ../core/src/utils/array-utils-flat.ts
  var arrayBuffer;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type, length) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
    return new Type(scratchArrayBuffer, 0, length);
  }
  function fillArray(options) {
    const {
      target,
      source,
      start = 0,
      count = 1
    } = options;
    const length = source.length;
    const total = count * length;
    let copied = 0;
    for (let i = start; copied < length; copied++) {
      target[i++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return options.target;
  }

  // ../core/src/adapter/type-utils/decode-texture-format.ts
  var REGEX = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
  function decodeTextureFormat(format) {
    const matches = REGEX.exec(format);
    if (matches) {
      const [, format2, length, type, srgb, suffix] = matches;
      if (format2) {
        const dataType = `${type}${length}`;
        const decodedType = decodeVertexType(dataType);
        return {
          format: format2,
          components: format2.length,
          srgb: srgb === "-srgb",
          unsized: suffix === "-unsized",
          webgl: suffix === "-webgl",
          ...decodedType
        };
      }
    }
    return decodeNonStandardFormat(format);
  }
  var EXCEPTIONS = {
    "rgba4unorm-webgl": {
      format: "rgba",
      bpp: 2
    },
    "rgb565unorm-webgl": {
      format: "rgb",
      bpp: 2
    },
    "rgb5a1unorm-webgl": {
      format: "rgba",
      bbp: 2
    },
    "rgb9e5ufloat": {
      format: "rgb",
      bbp: 4
    },
    "rg11b10ufloat": {
      format: "rgb",
      bbp: 4
    },
    "rgb10a2unorm": {
      format: "rgba",
      bbp: 4
    },
    "rgb10a2unorm-webgl": {
      format: "rgba",
      bbp: 4
    },
    "stencil8": {
      components: 1,
      bpp: 1,
      a: "stencil"
    },
    "depth16unorm": {
      components: 1,
      bpp: 2,
      a: "depth"
    },
    "depth24plus": {
      components: 1,
      bpp: 3,
      a: "depth"
    },
    "depth32float": {
      components: 1,
      bpp: 4,
      a: "depth"
    },
    "depth24plus-stencil8": {
      components: 2,
      bpp: 4,
      a: "depth-stencil"
    },
    "depth24unorm-stencil8": {
      components: 2,
      bpp: 4,
      a: "depth-stencil"
    },
    "depth32float-stencil8": {
      components: 2,
      bpp: 4,
      a: "depth-stencil"
    }
  };
  function decodeNonStandardFormat(format) {
    const data = EXCEPTIONS[format];
    if (!data) {
      throw new Error(`Unknown format ${format}`);
    }
    return {
      format: data.format || "",
      components: data.components || data.format?.length || 1,
      byteLength: data.bpp || 1,
      srgb: false,
      unsized: false
    };
  }

  // ../core/src/utils/cast.ts
  function cast(value) {
    return value;
  }

  // ../core/src/lib/uniforms/uniform.ts
  function isUniformValue(value) {
    return isNumberArray(value) !== null || typeof value === "number" || typeof value === "boolean";
  }
  function splitUniformsAndBindings(uniforms) {
    const result = {
      bindings: {},
      uniforms: {}
    };
    Object.keys(uniforms).forEach((name2) => {
      const uniform = uniforms[name2];
      if (isUniformValue(uniform)) {
        result.uniforms[name2] = uniform;
      } else {
        result.bindings[name2] = uniform;
      }
    });
    return result;
  }

  // ../core/src/utils/stub-methods.ts
  function stubRemovedMethods(instance, className, version, methodNames) {
    const upgradeMessage = `See luma.gl ${version} Upgrade Guide at https://luma.gl/docs/upgrade-guide`;
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName) => {
      if (prototype.methodName) {
        return;
      }
      prototype[methodName] = () => {
        log.removed(`Calling removed method ${className}.${methodName}: `, upgradeMessage)();
        throw new Error(methodName);
      };
    });
  }

  // ../core/src/utils/check-props.ts
  function checkProps(className, props, propChecks) {
    const {
      removedProps = {},
      deprecatedProps = {},
      replacedProps = {}
    } = propChecks;
    for (const propName in removedProps) {
      if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? `${className}.${removedProps[propName]}` : "N/A";
        log.removed(`${className}.${propName}`, replacement)();
      }
    }
    for (const propName in deprecatedProps) {
      if (propName in props) {
        const replacementProp = deprecatedProps[propName];
        log.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
      }
    }
    let newProps = null;
    for (const [propName, replacementProp] of Object.entries(replacedProps)) {
      if (propName in props) {
        log.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName];
        delete newProps[propName];
      }
    }
    return newProps || props;
  }

  // ../core/src/utils/load-file.ts
  var pathPrefix = "";
  async function loadImage(url, opts) {
    return new Promise((resolve, reject) => {
      try {
        const image = new Image();
        image.onload = () => resolve(image);
        image.onerror = () => reject(new Error(`Could not load image ${url}.`));
        image.crossOrigin = opts?.crossOrigin || "anonymous";
        image.src = url.startsWith("http") ? url : pathPrefix + url;
      } catch (error2) {
        reject(error2);
      }
    });
  }
  async function loadScript(scriptUrl, scriptId) {
    const head = document.getElementsByTagName("head")[0];
    if (!head) {
      throw new Error("loadScript");
    }
    const script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    return new Promise((resolve, reject) => {
      script.onload = resolve;
      script.onerror = (error2) => reject(new Error(`Unable to load script '${scriptUrl}': ${error2}`));
      head.appendChild(script);
    });
  }

  // src/context/polyfill/polyfill-vertex-array-object.ts
  var glErrorShadow = {};
  function error(msg) {
    if (globalThis.console && globalThis.console.error) {
      globalThis.console.error(msg);
    }
  }
  function log2(msg) {
    if (globalThis.console && globalThis.console.log) {
      globalThis.console.log(msg);
    }
  }
  function synthesizeGLError(err, opt_msg) {
    glErrorShadow[err] = true;
    if (opt_msg !== void 0) {
      error(opt_msg);
    }
  }
  function wrapGLError(gl) {
    const f = gl.getError;
    gl.getError = function getError() {
      let err;
      do {
        err = f.apply(gl);
        if (err !== 0) {
          glErrorShadow[err] = true;
        }
      } while (err !== 0);
      for (err in glErrorShadow) {
        if (glErrorShadow[err]) {
          delete glErrorShadow[err];
          return parseInt(err, 10);
        }
      }
      return 0;
    };
  }
  var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
    const gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for (let n = 0; n < this.attribs.length; n++) {
      const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
      this.attribs[n] = attrib;
    }
    this.maxAttrib = 0;
  };
  WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
  };
  WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
  };
  var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
    const self = this;
    this.gl = gl;
    wrapGLError(gl);
    const original = this.original = {
      getParameter: gl.getParameter,
      enableVertexAttribArray: gl.enableVertexAttribArray,
      disableVertexAttribArray: gl.disableVertexAttribArray,
      bindBuffer: gl.bindBuffer,
      getVertexAttrib: gl.getVertexAttrib,
      vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
      if (pname === self.VERTEX_ARRAY_BINDING_OES) {
        if (self.currentVertexArrayObject === self.defaultVertexArrayObject) {
          return null;
        }
        return self.currentVertexArrayObject;
      }
      return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
      const vao = self.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = true;
      return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
      const vao = self.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = false;
      return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer2(target, buffer) {
      switch (target) {
        case 34962:
          self.currentArrayBuffer = buffer;
          break;
        case 34963:
          self.currentVertexArrayObject.elementArrayBuffer = buffer;
          break;
        default:
      }
      return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib(index, pname) {
      const vao = self.currentVertexArrayObject;
      const attrib = vao.attribs[index];
      switch (pname) {
        case 34975:
          return attrib.buffer;
        case 34338:
          return attrib.enabled;
        case 34339:
          return attrib.size;
        case 34340:
          return attrib.stride;
        case 34341:
          return attrib.type;
        case 34922:
          return attrib.normalized;
        default:
          return original.getVertexAttrib.apply(this, arguments);
      }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
      const vao = self.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, indx);
      const attrib = vao.attribs[indx];
      attrib.buffer = self.currentArrayBuffer;
      attrib.size = size;
      attrib.type = type;
      attrib.normalized = normalized;
      attrib.stride = stride;
      attrib.offset = offset;
      attrib.recache();
      return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) {
      gl.instrumentExtension(this, "OES_vertex_array_object");
    }
    if (gl.canvas) {
      gl.canvas.addEventListener("webglcontextrestored", () => {
        log2("OESVertexArrayObject emulation library context restored");
        self.reset_();
      }, true);
    }
    this.reset_();
  };
  OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
  OESVertexArrayObject.prototype.reset_ = function reset_() {
    const contextWasLost = this.vertexArrayObjects !== void 0;
    if (contextWasLost) {
      for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
        this.vertexArrayObjects.isAlive = false;
      }
    }
    const gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [this.defaultVertexArrayObject];
    this.bindVertexArrayOES(null);
  };
  OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    const arrayObject = new WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
  };
  OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) {
      this.bindVertexArrayOES(null);
    }
  };
  OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
      if (arrayObject.hasBeenBound && arrayObject.ext === this) {
        return true;
      }
    }
    return false;
  };
  OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    const gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
      synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
      return;
    }
    const original = this.original;
    const oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    const newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) {
      return;
    }
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
      original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    }
    let currentBinding = this.currentArrayBuffer;
    const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for (let n = 0; n <= maxAttrib; n++) {
      const attrib = newVAO.attribs[n];
      const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
      if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
        if (attrib.enabled) {
          original.enableVertexAttribArray.call(gl, n);
        } else {
          original.disableVertexAttribArray.call(gl, n);
        }
      }
      if (attrib.enabled) {
        let bufferChanged = false;
        if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
          if (currentBinding !== attrib.buffer) {
            original.bindBuffer.call(gl, 34962, attrib.buffer);
            currentBinding = attrib.buffer;
          }
          bufferChanged = true;
        }
        if (bufferChanged || attrib.cached !== oldAttrib.cached) {
          original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
      }
    }
    if (this.currentArrayBuffer !== currentBinding) {
      original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
    }
  };
  function polyfillVertexArrayObject(gl) {
    if (typeof gl.createVertexArray === "function") {
      return;
    }
    const original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
      const list = original_getSupportedExtensions.call(this) || [];
      if (list.indexOf("OES_vertex_array_object") < 0) {
        list.push("OES_vertex_array_object");
      }
      return list;
    };
    const original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name2) {
      const ext = original_getExtension.call(this, name2);
      if (ext) {
        return ext;
      }
      if (name2 !== "OES_vertex_array_object") {
        return null;
      }
      if (!gl.__OESVertexArrayObject) {
        this.__OESVertexArrayObject = new OESVertexArrayObject(this);
      }
      return this.__OESVertexArrayObject;
    };
  }

  // src/context/context/webgl-checks.ts
  var ERR_CONTEXT = "Invalid WebGLRenderingContext";
  var ERR_WEBGL2 = "Requires WebGL2";
  function isWebGL(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getWebGL2Context(gl) {
    return isWebGL2(gl) ? gl : null;
  }
  function assertWebGLContext(gl) {
    assert2(isWebGL(gl), ERR_CONTEXT);
    return gl;
  }
  function assertWebGL2Context(gl) {
    assert2(isWebGL2(gl), ERR_WEBGL2);
    return gl;
  }

  // src/context/polyfill/get-parameter-polyfill.ts
  var OES_element_index = "OES_element_index";
  var WEBGL_draw_buffers = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
  var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
  var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
  var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
  var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
  var GL_DONT_CARE = 4352;
  var GL_GPU_DISJOINT_EXT = 36795;
  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  var GL_UNMASKED_VENDOR_WEBGL = 37445;
  var GL_UNMASKED_RENDERER_WEBGL = 37446;
  var getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
  var WEBGL_PARAMETERS = {
    [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
    [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
    [35977]: getWebGL2ValueOrZero,
    [32937]: getWebGL2ValueOrZero,
    [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
      const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
      return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
    },
    [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
    },
    [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
    },
    [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
      const ext = gl.luma?.extensions?.[EXT_texture_filter_anisotropic] || gl.getExtension("EXT_texture_filter_anisotropic");
      return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    },
    [32883]: getWebGL2ValueOrZero,
    [35071]: getWebGL2ValueOrZero,
    [37447]: getWebGL2ValueOrZero,
    [36063]: (gl, getParameter) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
      }
      return void 0;
    },
    [35379]: getWebGL2ValueOrZero,
    [35374]: getWebGL2ValueOrZero,
    [35377]: getWebGL2ValueOrZero,
    [34852]: (gl) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
      }
      return void 0;
    },
    [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
    [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
    [33e3]: (gl) => 16777216,
    [37157]: getWebGL2ValueOrZero,
    [35373]: getWebGL2ValueOrZero,
    [35657]: getWebGL2ValueOrZero,
    [36183]: getWebGL2ValueOrZero,
    [37137]: getWebGL2ValueOrZero,
    [34045]: getWebGL2ValueOrZero,
    [35978]: getWebGL2ValueOrZero,
    [35979]: getWebGL2ValueOrZero,
    [35968]: getWebGL2ValueOrZero,
    [35376]: getWebGL2ValueOrZero,
    [35375]: getWebGL2ValueOrZero,
    [35659]: getWebGL2ValueOrZero,
    [37154]: getWebGL2ValueOrZero,
    [35371]: getWebGL2ValueOrZero,
    [35658]: getWebGL2ValueOrZero,
    [35076]: getWebGL2ValueOrZero,
    [35077]: getWebGL2ValueOrZero,
    [35380]: getWebGL2ValueOrZero
  };
  function getParameterPolyfill(gl, originalGetParameter, pname) {
    const limit = WEBGL_PARAMETERS[pname];
    const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    const result = value !== void 0 ? value : originalGetParameter(pname);
    return result;
  }

  // src/context/polyfill/context-data.ts
  function getContextData(gl) {
    const luma = gl.luma;
    if (!luma) {
      const contextState = {
        _polyfilled: false,
        _extensions: {}
      };
      gl.luma = contextState;
    }
    return gl.luma;
  }

  // src/context/polyfill/polyfill-table.ts
  var OES_vertex_array_object = "OES_vertex_array_object";
  var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
  var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
  var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
  var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
  function getExtensionData(gl, extension) {
    return {
      webgl2: isWebGL2(gl),
      ext: gl.getExtension(extension)
    };
  }
  var WEBGL2_CONTEXT_POLYFILLS = {
    [OES_vertex_array_object]: {
      meta: {
        suffix: "OES"
      },
      createVertexArray: () => {
        assert2(false, ERR_VAO_NOT_SUPPORTED);
      },
      deleteVertexArray: () => {
      },
      bindVertexArray: () => {
      },
      isVertexArray: () => false
    },
    [ANGLE_instanced_arrays]: {
      meta: {
        suffix: "ANGLE"
      },
      vertexAttribDivisor(location, divisor) {
        assert2(divisor === 0, "WebGL instanced rendering not supported");
      },
      drawElementsInstanced: () => {
      },
      drawArraysInstanced: () => {
      }
    },
    [WEBGL_draw_buffers2]: {
      meta: {
        suffix: "WEBGL"
      },
      drawBuffers: () => {
        assert2(false);
      }
    },
    [EXT_disjoint_timer_query2]: {
      meta: {
        suffix: "EXT"
      },
      createQuery: () => {
        assert2(false);
      },
      deleteQuery: () => {
        assert2(false);
      },
      beginQuery: () => {
        assert2(false);
      },
      endQuery: () => {
      },
      getQuery(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryParameter(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryObject: (handle, pname) => {
      }
    }
  };
  var WEBGL2_CONTEXT_OVERRIDES = {
    readBuffer: (gl, originalFunc, attachment) => {
      if (isWebGL2(gl)) {
        originalFunc(attachment);
      } else {
      }
    },
    getVertexAttrib: (gl, originalFunc, location, pname) => {
      const {
        webgl2,
        ext
      } = getExtensionData(gl, ANGLE_instanced_arrays);
      let result;
      switch (pname) {
        case 35069:
          result = !webgl2 ? false : void 0;
          break;
        case 35070:
          result = !webgl2 && !ext ? 0 : void 0;
          break;
        default:
      }
      return result !== void 0 ? result : originalFunc(location, pname);
    },
    getProgramParameter: (gl, originalFunc, program, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 35967:
            return 35981;
          case 35971:
            return 0;
          case 35382:
            return 0;
          default:
        }
      }
      return originalFunc(program, pname);
    },
    getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 32937:
            return new Int32Array([0]);
          default:
        }
      }
      const gl2 = gl;
      return gl2.getInternalformatParameter(target, format, pname);
    },
    getTexParameter(gl, originalFunc, target, pname) {
      switch (pname) {
        case 34046:
          const contextData = getContextData(gl);
          const {
            _extensions
          } = contextData;
          const ext = _extensions[EXT_texture_filter_anisotropic2];
          pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
          break;
        default:
      }
      return originalFunc(target, pname);
    },
    getParameter: getParameterPolyfill,
    hint(gl, originalFunc, pname, value) {
      return originalFunc(pname, value);
    }
  };

  // src/context/polyfill/polyfill-context.ts
  function polyfillContext(gl) {
    const contextState = getContextData(gl);
    if (!contextState._polyfilled) {
      polyfillVertexArrayObject(gl);
      initializeExtensions(gl);
      installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
      installOverrides(gl, {
        target: contextState,
        target2: gl
      });
      contextState._polyfilled = true;
    }
    return gl;
  }
  function initializeExtensions(gl) {
    const contextState = getContextData(gl);
    const EXTENSIONS = gl.getSupportedExtensions() || [];
    const IGNORE_EXTENSIONS = ["WEBGL_polygon_mode"];
    for (const extensionName of EXTENSIONS) {
      if (!IGNORE_EXTENSIONS.includes(extensionName)) {
        const extension = gl.getExtension(extensionName);
        contextState._extensions[extensionName] = extension;
      }
    }
  }
  function installPolyfills(gl, polyfills) {
    const contextState = getContextData(gl);
    for (const extension of Object.getOwnPropertyNames(polyfills)) {
      if (extension !== "overrides") {
        polyfillExtension(gl, {
          extension,
          target: contextState,
          target2: gl
        });
      }
    }
  }
  function polyfillExtension(gl, {
    extension,
    target,
    target2
  }) {
    const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
    assert2(defaults);
    const {
      meta = {}
    } = defaults;
    const {
      suffix = ""
    } = meta;
    const ext = gl.getExtension(extension);
    for (const key of Object.keys(defaults)) {
      const extKey = `${key}${suffix}`;
      let polyfill = null;
      if (key === "meta") {
      } else if (typeof gl[key] === "function") {
      } else if (ext && typeof ext[extKey] === "function") {
        polyfill = (...args) => ext[extKey](...args);
      } else if (typeof defaults[key] === "function") {
        polyfill = defaults[key].bind(target);
      }
      if (polyfill) {
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    }
  }
  function installOverrides(gl, {
    target,
    target2
  }) {
    Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
      if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
        const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
        };
        const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    });
  }

  // src/context/parameters/webgl-parameter-tables.ts
  var GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([0, 0, 0, 0]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([0, 0, 0, 0]),
    [3107]: [true, true, true, true],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([0, 1]),
    [2930]: true,
    [3024]: true,
    [35725]: null,
    [36006]: null,
    [36007]: null,
    [34229]: null,
    [34964]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32926]: false,
    [32928]: false,
    [32938]: 1,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([0, 0, 1024, 1024]),
    [2960]: false,
    [2961]: 0,
    [2968]: 4294967295,
    [36005]: 4294967295,
    [2962]: 519,
    [2967]: 0,
    [2963]: 4294967295,
    [34816]: 519,
    [36003]: 0,
    [36004]: 4294967295,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [0, 0, 1024, 1024],
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [36389]: null,
    [36662]: null,
    [36663]: null,
    [35053]: null,
    [35055]: null,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
  };
  var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value, key) => gl.hint(key, value);
  var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
  var bindFramebuffer = (gl, value, key) => {
    let target;
    if (key === 36006) {
      target = isWebGL2(gl) ? 36009 : 36160;
    } else {
      target = 36008;
    }
    return gl.bindFramebuffer(target, value);
  };
  var bindBuffer = (gl, value, key) => {
    const bindingMap = {
      [34964]: 34962,
      [36662]: 36662,
      [36663]: 36663,
      [35053]: 35051,
      [35055]: 35052
    };
    const glTarget = bindingMap[key];
    gl.bindBuffer(glTarget, value);
  };
  function isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
  }
  var GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value) => gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value) => gl.clearColor(...value),
    [3107]: (gl, value) => gl.colorMask(...value),
    [2884]: enable,
    [2885]: (gl, value) => gl.cullFace(value),
    [2929]: enable,
    [2931]: (gl, value) => gl.clearDepth(value),
    [2932]: (gl, value) => gl.depthFunc(value),
    [2928]: (gl, value) => gl.depthRange(...value),
    [2930]: (gl, value) => gl.depthMask(value),
    [3024]: enable,
    [35723]: hint,
    [35725]: (gl, value) => gl.useProgram(value),
    [36007]: (gl, value) => gl.bindRenderbuffer(36161, value),
    [36389]: (gl, value) => gl.bindTransformFeedback?.(36386, value),
    [34229]: (gl, value) => gl.bindVertexArray(value),
    [36006]: bindFramebuffer,
    [36010]: bindFramebuffer,
    [34964]: bindBuffer,
    [36662]: bindBuffer,
    [36663]: bindBuffer,
    [35053]: bindBuffer,
    [35055]: bindBuffer,
    [2886]: (gl, value) => gl.frontFace(value),
    [33170]: hint,
    [2849]: (gl, value) => gl.lineWidth(value),
    [32823]: enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: enable,
    [32926]: enable,
    [32928]: enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: enable,
    [3088]: (gl, value) => gl.scissor(...value),
    [2960]: enable,
    [2961]: (gl, value) => gl.clearStencil(value),
    [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value) => gl.viewport(...value),
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value) => gl.blendColor(...value),
    blendEquation: (gl, args) => {
      const separateModes = typeof args === "number" ? [args, args] : args;
      gl.blendEquationSeparate(...separateModes);
    },
    blendFunc: (gl, args) => {
      const separateFuncs = args?.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...separateFuncs);
    },
    clearColor: (gl, value) => gl.clearColor(...value),
    clearDepth: (gl, value) => gl.clearDepth(value),
    clearStencil: (gl, value) => gl.clearStencil(value),
    colorMask: (gl, value) => gl.colorMask(...value),
    cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value) => gl.cullFace(value),
    depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value) => gl.depthFunc(value),
    depthMask: (gl, value) => gl.depthMask(value),
    depthRange: (gl, value) => gl.depthRange(...value),
    dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value) => {
      gl.hint(35723, value);
    },
    frontFace: (gl, value) => gl.frontFace(value),
    mipmapHint: (gl, value) => gl.hint(33170, value),
    lineWidth: (gl, value) => gl.lineWidth(value),
    polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value) => gl.polygonOffset(...value),
    sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
    scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value) => gl.scissor(...value),
    stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value) => {
      value = isArray(value) ? value : [value, value];
      const [mask, backMask] = value;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [func, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028, func, ref, mask);
      gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value) => gl.viewport(...value)
  };
  function getValue(glEnum, values, cache2) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache2[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache2) => gl.blendEquationSeparate(getValue(32777, values, cache2), getValue(34877, values, cache2)),
    blendFunc: (gl, values, cache2) => gl.blendFuncSeparate(getValue(32969, values, cache2), getValue(32968, values, cache2), getValue(32971, values, cache2), getValue(32970, values, cache2)),
    polygonOffset: (gl, values, cache2) => gl.polygonOffset(getValue(32824, values, cache2), getValue(10752, values, cache2)),
    sampleCoverage: (gl, values, cache2) => gl.sampleCoverage(getValue(32938, values, cache2), getValue(32939, values, cache2)),
    stencilFuncFront: (gl, values, cache2) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache2), getValue(2967, values, cache2), getValue(2963, values, cache2)),
    stencilFuncBack: (gl, values, cache2) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache2), getValue(36003, values, cache2), getValue(36004, values, cache2)),
    stencilOpFront: (gl, values, cache2) => gl.stencilOpSeparate(1028, getValue(2964, values, cache2), getValue(2965, values, cache2), getValue(2966, values, cache2)),
    stencilOpBack: (gl, values, cache2) => gl.stencilOpSeparate(1029, getValue(34817, values, cache2), getValue(34818, values, cache2), getValue(34819, values, cache2))
  };
  var GL_HOOKED_SETTERS = {
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value) => update({
      [pname]: value
    }),
    hint: (update, pname, hint2) => update({
      [pname]: hint2
    }),
    useProgram: (update, value) => update({
      [35725]: value
    }),
    bindRenderbuffer: (update, target, value) => update({
      [36007]: value
    }),
    bindTransformFeedback: (update, target, value) => update({
      [36389]: value
    }),
    bindVertexArray: (update, value) => update({
      [34229]: value
    }),
    bindFramebuffer: (update, target, framebuffer) => {
      switch (target) {
        case 36160:
          return update({
            [36006]: framebuffer,
            [36010]: framebuffer
          });
        case 36009:
          return update({
            [36006]: framebuffer
          });
        case 36008:
          return update({
            [36010]: framebuffer
          });
        default:
          return null;
      }
    },
    bindBuffer: (update, target, buffer) => {
      const pname = {
        [34962]: [34964],
        [36662]: [36662],
        [36663]: [36663],
        [35051]: [35053],
        [35052]: [35055]
      }[target];
      if (pname) {
        return update({
          [pname]: buffer
        });
      }
      return {
        valueChanged: true
      };
    },
    blendColor: (update, r, g, b, a) => update({
      [32773]: new Float32Array([r, g, b, a])
    }),
    blendEquation: (update, mode) => update({
      [32777]: mode,
      [34877]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777]: modeRGB,
      [34877]: modeAlpha
    }),
    blendFunc: (update, src, dst) => update({
      [32969]: src,
      [32968]: dst,
      [32971]: src,
      [32970]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969]: srcRGB,
      [32968]: dstRGB,
      [32971]: srcAlpha,
      [32970]: dstAlpha
    }),
    clearColor: (update, r, g, b, a) => update({
      [3106]: new Float32Array([r, g, b, a])
    }),
    clearDepth: (update, depth) => update({
      [2931]: depth
    }),
    clearStencil: (update, s) => update({
      [2961]: s
    }),
    colorMask: (update, r, g, b, a) => update({
      [3107]: [r, g, b, a]
    }),
    cullFace: (update, mode) => update({
      [2885]: mode
    }),
    depthFunc: (update, func) => update({
      [2932]: func
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930]: mask
    }),
    frontFace: (update, face) => update({
      [2886]: face
    }),
    lineWidth: (update, width) => update({
      [2849]: width
    }),
    polygonOffset: (update, factor, units) => update({
      [32824]: factor,
      [10752]: units
    }),
    sampleCoverage: (update, value, invert) => update({
      [32938]: value,
      [32939]: invert
    }),
    scissor: (update, x, y, width, height) => update({
      [3088]: new Int32Array([x, y, width, height])
    }),
    stencilMask: (update, mask) => update({
      [2968]: mask,
      [36005]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 ? 2968 : 36005]: mask
    }),
    stencilFunc: (update, func, ref, mask) => update({
      [2962]: func,
      [2967]: ref,
      [2963]: mask,
      [34816]: func,
      [36003]: ref,
      [36004]: mask
    }),
    stencilFuncSeparate: (update, face, func, ref, mask) => update({
      [face === 1028 ? 2962 : 34816]: func,
      [face === 1028 ? 2967 : 36003]: ref,
      [face === 1028 ? 2963 : 36004]: mask
    }),
    stencilOp: (update, fail, zfail, zpass) => update({
      [2964]: fail,
      [2965]: zfail,
      [2966]: zpass,
      [34817]: fail,
      [34818]: zfail,
      [34819]: zpass
    }),
    stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
      [face === 1028 ? 2964 : 34817]: fail,
      [face === 1028 ? 2965 : 34818]: zfail,
      [face === 1028 ? 2966 : 34819]: zpass
    }),
    viewport: (update, x, y, width, height) => update({
      [2978]: [x, y, width, height]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
  };
  var NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([34016, 36388, 36387, 35983, 35368, 34965, 35739, 35738, 3074, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34866, 34867, 34868, 35097, 32873, 35869, 32874, 34068]);

  // src/context/parameters/unified-parameter-api.ts
  function setGLParameters(device, parameters) {
    const webglDevice = WebGLDevice.attach(device);
    const gl = webglDevice.gl;
    if (isObjectEmpty2(parameters)) {
      return;
    }
    const compositeSetters = {};
    for (const key in parameters) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, parameters[key], glConstant);
        }
      }
    }
    const cache2 = gl.state && gl.state.cache;
    if (cache2) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, parameters, cache2);
      }
    }
  }
  function getGLParameters(device, parameters = GL_PARAMETER_DEFAULTS) {
    const webglDevice = WebGLDevice.attach(device);
    const gl = webglDevice.gl;
    if (typeof parameters === "number") {
      const key = parameters;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function resetGLParameters(device) {
    setGLParameters(device, GL_PARAMETER_DEFAULTS);
  }
  function isObjectEmpty2(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }

  // src/context/state-tracker/deep-array-equal.ts
  function deepArrayEqual(x, y) {
    if (x === y) {
      return true;
    }
    const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
    const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
    if (isArrayX && isArrayY && x.length === y.length) {
      for (let i = 0; i < x.length; ++i) {
        if (x[i] !== y[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // src/context/state-tracker/track-context-state.ts
  var GLState = class {
    program = null;
    stateStack = [];
    enable = true;
    constructor(gl, {
      copyState = false,
      log: log3 = () => {
      }
    } = {}) {
      this.gl = gl;
      this.cache = copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log3;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push(values = {}) {
      this.stateStack.push({});
    }
    pop() {
      assert2(this.stateStack.length > 0);
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setGLParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    _updateCache(values) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
      for (const key in values) {
        assert2(key !== void 0);
        const value = values[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value;
        }
      }
      return {
        valueChanged,
        oldValue
      };
    }
  };
  function getContextState(gl) {
    return gl.state;
  }
  function trackContextState(gl, options) {
    const {
      enable: enable2 = true,
      copyState
    } = options;
    assert2(copyState !== void 0);
    if (!gl.state) {
      gl.state = new GLState(gl, {
        copyState
      });
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    const glState = getContextState(gl);
    glState.enable = enable2;
    return gl;
  }
  function pushContextState(gl) {
    let glState = getContextState(gl);
    if (!glState) {
      trackContextState(gl, {
        copyState: false
      });
      glState = getContextState(gl);
    }
    glState.push();
  }
  function popContextState(gl) {
    const glState = getContextState(gl);
    assert2(glState);
    glState.pop();
  }
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get(pname) {
      if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
        return originalGetterFunc(pname);
      }
      const glState = getContextState(gl);
      if (!(pname in glState.cache)) {
        glState.cache[pname] = originalGetterFunc(pname);
      }
      return glState.enable ? glState.cache[pname] : originalGetterFunc(pname);
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-from-cache`,
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    if (!gl[functionName]) {
      return;
    }
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set(...params) {
      const glState = getContextState(gl);
      const {
        valueChanged,
        oldValue
      } = setter(glState._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-to-cache`,
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      const glState = getContextState(gl);
      if (glState.program !== handle) {
        originalUseProgram(handle);
        glState.program = handle;
      }
    };
  }

  // src/context/context/create-browser-context.ts
  var DEFAULT_CONTEXT_PROPS = {
    webgl2: true,
    webgl1: true,
    powerPreference: "high-performance",
    onContextLost: () => console.error("WebGL context lost"),
    onContextRestored: () => console.info("WebGL context restored")
  };
  function createBrowserContext(canvas, props) {
    props = {
      ...DEFAULT_CONTEXT_PROPS,
      ...props
    };
    let errorMessage = null;
    const onCreateError = (error2) => errorMessage = error2.statusMessage || errorMessage;
    canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
    let gl = null;
    if (props.type === "webgl2") {
      props = {
        ...props,
        webgl1: false
      };
    }
    if (props.type === "webgl1") {
      props = {
        ...props,
        webgl2: false
      };
    }
    if (!gl && props.webgl2) {
      gl = canvas.getContext("webgl2", props);
    }
    if (!gl && props.webgl1) {
      gl = canvas.getContext("webgl", props);
    }
    canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) {
      throw new Error(`Failed to create ${props.webgl2 && !props.webgl1 ? "WebGL2" : "WebGL"} context: ${errorMessage || "Unknown error"}`);
    }
    if (props.onContextLost) {
      const {
        onContextLost
      } = props;
      canvas.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
    }
    if (props.onContextRestored) {
      const {
        onContextRestored
      } = props;
      canvas.addEventListener("webglcontextrestored", (event) => onContextRestored(event), false);
    }
    return gl;
  }

  // src/adapter/device-helpers/get-device-info.ts
  function getDeviceInfo(gl) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    const ext = gl.getExtension("WEBGL_debug_renderer_info");
    const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);
    const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);
    const vendor = vendorUnmasked || vendorMasked;
    const renderer = rendererUnmasked || rendererMasked;
    const version = gl.getParameter(7938);
    const gpu = identifyGPUVendor(vendor, renderer);
    const gpuBackend = identifyGPUBackend(vendor, renderer);
    const gpuType = identifyGPUType(vendor, renderer);
    const shadingLanguage = "glsl";
    const shadingLanguageVersion = isWebGL2(gl) ? 300 : 100;
    return {
      type: isWebGL2(gl) ? "webgl2" : "webgl",
      gpu,
      gpuType,
      gpuBackend,
      vendor,
      renderer,
      version,
      shadingLanguage,
      shadingLanguageVersion
    };
  }
  function identifyGPUVendor(vendor, renderer) {
    if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
      return "nvidia";
    }
    if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
      return "intel";
    }
    if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
      return "apple";
    }
    if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
      return "amd";
    }
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "software";
    }
    return "unknown";
  }
  function identifyGPUBackend(vendor, renderer) {
    if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
      return "metal";
    }
    if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
      return "opengl";
    }
    return "unknown";
  }
  function identifyGPUType(vendor, renderer) {
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "cpu";
    }
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    switch (gpuVendor) {
      case "intel":
        return "integrated";
      case "software":
        return "cpu";
      case "unknown":
        return "unknown";
      default:
        return "discrete";
    }
  }

  // src/adapter/device-helpers/is-old-ie.ts
  function isOldIE(opts = {}) {
    const navigator2 = typeof window !== "undefined" ? window.navigator || {} : {};
    const userAgent = opts.userAgent || navigator2.userAgent || "";
    const isMSIE = userAgent.indexOf("MSIE ") !== -1;
    const isTrident = userAgent.indexOf("Trident/") !== -1;
    return isMSIE || isTrident;
  }

  // src/adapter/converters/vertex-formats.ts
  function getGLFromVertexType(dataType) {
    switch (dataType) {
      case "uint8":
        return 5121;
      case "sint8":
        return 5120;
      case "unorm8":
        return 5121;
      case "snorm8":
        return 5120;
      case "uint16":
        return 5123;
      case "sint16":
        return 5122;
      case "unorm16":
        return 5123;
      case "snorm16":
        return 5122;
      case "uint32":
        return 5125;
      case "sint32":
        return 5124;
      case "float16":
        return 5131;
      case "float32":
        return 5126;
    }
    throw new Error(String(dataType));
  }

  // src/adapter/converters/texture-formats.ts
  var texture_compression_bc = "texture-compression-bc";
  var texture_compression_astc = "texture-compression-astc";
  var texture_compression_etc2 = "texture-compression-etc2";
  var texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
  var texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
  var texture_compression_atc_webgl = "texture-compression-atc-webgl";
  var X_S3TC = "WEBGL_compressed_texture_s3tc";
  var X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
  var X_RGTC = "EXT_texture_compression_rgtc";
  var X_BPTC = "EXT_texture_compression_bptc";
  var X_ETC2 = "WEBGL_compressed_texture_etc";
  var X_ASTC = "WEBGL_compressed_texture_astc";
  var X_ETC1 = "WEBGL_compressed_texture_etc1";
  var X_PVRTC = "WEBGL_compressed_texture_pvrtc";
  var X_ATC = "WEBGL_compressed_texture_atc";
  var EXT_SRGB = "EXT_sRGB";
  var EXT_TEXTURE_NORM16 = "EXT_texture_norm16";
  var EXT_FLOAT_WEBGL1 = "WEBGL_color_buffer_float";
  var EXT_FLOAT_RENDER_WEBGL2 = "EXT_color_buffer_float";
  var checkExtension = (gl, extension) => gl.getExtension(extension);
  var checkExtensions = (gl, extensions) => extensions.every((extension) => gl.getExtension(extension));
  var TEXTURE_FEATURE_CHECKS = {
    "texture-blend-float-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, "EXT_float_blend"),
    "texture-formats-srgb-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, EXT_SRGB),
    "texture-formats-depth-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, "WEBGL_depth_texture"),
    "texture-formats-float32-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, "OES_texture_float"),
    "texture-formats-float16-webgl1": (gl) => isWebGL2(gl) ? true : checkExtension(gl, "OES_texture_half_float"),
    "texture-formats-norm16-webgl": (gl) => isWebGL2(gl) ? checkExtension(gl, EXT_TEXTURE_NORM16) : false,
    "texture-filter-linear-float32-webgl": (gl) => checkExtension(gl, "OES_texture_float_linear"),
    "texture-filter-linear-float16-webgl": (gl) => checkExtension(gl, "OES_texture_half_float_linear"),
    "texture-filter-anisotropic-webgl": (gl) => checkExtension(gl, "EXT_texture_filter_anisotropic"),
    "texture-renderable-float32-webgl": (gl) => checkExtension(gl, "EXT_color_buffer_float"),
    "texture-renderable-float16-webgl": (gl) => checkExtension(gl, "EXT_color_buffer_half_float"),
    "texture-compression-bc": (gl) => checkExtensions(gl, [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC]),
    "texture-compression-bc5-webgl": (gl) => checkExtensions(gl, [X_RGTC]),
    "texture-compression-etc2": (gl) => checkExtensions(gl, [X_ETC2]),
    "texture-compression-astc": (gl) => checkExtensions(gl, [X_ASTC]),
    "texture-compression-etc1-webgl": (gl) => checkExtensions(gl, [X_ETC1]),
    "texture-compression-pvrtc-webgl": (gl) => checkExtensions(gl, [X_PVRTC]),
    "texture-compression-atc-webgl": (gl) => checkExtensions(gl, [X_ATC])
  };
  function checkTextureFeature(gl, feature) {
    return TEXTURE_FEATURE_CHECKS[feature]?.(gl) || false;
  }
  function getTextureFeatures(gl) {
    const textureFeatures = Object.keys(TEXTURE_FEATURE_CHECKS);
    return textureFeatures.filter((feature) => checkTextureFeature(gl, feature));
  }
  var TEXTURE_FORMATS = {
    "rgb8unorm-unsized": {
      gl: 6407,
      gl1: 6407,
      b: 4,
      c: 2,
      bpp: 4,
      dataFormat: 6407,
      types: [5121, 33635]
    },
    "rgba8unorm-unsized": {
      gl: 6408,
      gl1: 6408,
      b: 4,
      c: 2,
      bpp: 4,
      dataFormat: 6408,
      types: [5121, 32819, 32820]
    },
    "r8unorm": {
      gl: 33321,
      b: 1,
      c: 1,
      renderbuffer: true
    },
    "r8snorm": {
      gl: 36756,
      b: 1,
      c: 1
    },
    "r8uint": {
      gl: 33330,
      b: 1,
      c: 1,
      renderbuffer: true
    },
    "r8sint": {
      gl: 33329,
      b: 1,
      c: 1,
      renderbuffer: true
    },
    "rg8unorm": {
      gl: 33323,
      b: 2,
      c: 2,
      renderbuffer: true
    },
    "rg8snorm": {
      gl: 36757,
      b: 2,
      c: 2
    },
    "rg8uint": {
      gl: 33336,
      b: 2,
      c: 2,
      renderbuffer: true
    },
    "rg8sint": {
      gl: 33335,
      b: 2,
      c: 2,
      renderbuffer: true
    },
    "r16uint": {
      gl: 33332,
      b: 2,
      c: 1,
      renderbuffer: true
    },
    "r16sint": {
      gl: 33331,
      b: 2,
      c: 1,
      renderbuffer: true
    },
    "r16float": {
      gl: 33325,
      b: 2,
      c: 1,
      render: "texture-renderable-float16-webgl",
      filter: "texture-filter-linear-float16-webgl",
      renderbuffer: true
    },
    "r16unorm-webgl": {
      gl: 33322,
      b: 2,
      c: 1,
      f: "texture-formats-norm16-webgl",
      renderbuffer: true,
      x: EXT_TEXTURE_NORM16
    },
    "r16snorm-webgl": {
      gl: 36760,
      b: 2,
      c: 1,
      f: "texture-formats-norm16-webgl",
      x: EXT_TEXTURE_NORM16
    },
    "rgba4unorm-webgl": {
      gl: 32854,
      b: 2,
      c: 4,
      wgpu: false,
      renderbuffer: true
    },
    "rgb565unorm-webgl": {
      gl: 36194,
      b: 2,
      c: 4,
      wgpu: false,
      renderbuffer: true
    },
    "rgb5a1unorm-webgl": {
      gl: 32855,
      b: 2,
      c: 4,
      wgpu: false,
      renderbuffer: true
    },
    "rgb8unorm-webgl": {
      gl: 32849,
      b: 3,
      c: 3,
      wgpu: false
    },
    "rgb8snorm-webgl": {
      gl: 36758,
      b: 3,
      c: 3,
      wgpu: false
    },
    "rgba8unorm": {
      gl: 32856,
      gl1: 6408,
      b: 4,
      c: 2,
      bpp: 4
    },
    "rgba8unorm-srgb": {
      gl: 35907,
      gl1: 35906,
      b: 4,
      c: 4,
      gl1ext: EXT_SRGB,
      bpp: 4
    },
    "rgba8snorm": {
      gl: 36759,
      b: 4,
      c: 4
    },
    "rgba8uint": {
      gl: 36220,
      b: 4,
      c: 4,
      bpp: 4
    },
    "rgba8sint": {
      gl: 36238,
      b: 4,
      c: 4,
      bpp: 4
    },
    "bgra8unorm": {
      b: 4,
      c: 4
    },
    "bgra8unorm-srgb": {
      b: 4,
      c: 4
    },
    "rg16uint": {
      gl: 33338,
      b: 4,
      c: 1,
      bpp: 4
    },
    "rg16sint": {
      gl: 33337,
      b: 4,
      c: 2,
      bpp: 4
    },
    "rg16float": {
      gl: 33327,
      bpp: 4,
      b: 4,
      c: 2,
      render: "texture-renderable-float16-webgl",
      filter: "texture-filter-linear-float16-webgl",
      renderbuffer: true
    },
    "rg16unorm-webgl": {
      gl: 33324,
      b: 2,
      c: 2,
      f: "texture-formats-norm16-webgl",
      x: EXT_TEXTURE_NORM16
    },
    "rg16snorm-webgl": {
      gl: 36761,
      b: 2,
      c: 2,
      f: "texture-formats-norm16-webgl",
      x: EXT_TEXTURE_NORM16
    },
    "r32uint": {
      gl: 33334,
      b: 4,
      c: 1,
      bpp: 4,
      renderbuffer: true
    },
    "r32sint": {
      gl: 33333,
      b: 4,
      c: 1,
      bpp: 4,
      renderbuffer: true
    },
    "r32float": {
      gl: 33326,
      bpp: 4,
      b: 4,
      c: 1,
      render: "texture-renderable-float32-webgl",
      filter: "texture-filter-linear-float32-webgl"
    },
    "rgb9e5ufloat": {
      gl: 35901,
      b: 4,
      c: 3,
      p: 1,
      render: "texture-renderable-float16-webgl",
      filter: "texture-filter-linear-float16-webgl"
    },
    "rg11b10ufloat": {
      gl: 35898,
      b: 4,
      c: 3,
      p: 1,
      render: "texture-renderable-float32-webgl",
      renderbuffer: true
    },
    "rgb10a2unorm": {
      gl: 32857,
      b: 4,
      c: 4,
      p: 1,
      renderbuffer: true
    },
    "rgb10a2unorm-webgl": {
      b: 4,
      c: 4,
      gl: 36975,
      p: 1,
      wgpu: false,
      bpp: 4,
      renderbuffer: true
    },
    "rgb16unorm-webgl": {
      gl: 32852,
      b: 2,
      c: 3,
      f: "texture-formats-norm16-webgl",
      x: EXT_TEXTURE_NORM16
    },
    "rgb16snorm-webgl": {
      gl: 36762,
      b: 2,
      c: 3,
      f: "texture-formats-norm16-webgl",
      x: EXT_TEXTURE_NORM16
    },
    "rg32uint": {
      gl: 33340,
      b: 8,
      c: 2,
      renderbuffer: true
    },
    "rg32sint": {
      gl: 33339,
      b: 8,
      c: 2,
      renderbuffer: true
    },
    "rg32float": {
      gl: 33328,
      b: 8,
      c: 2,
      render: "texture-renderable-float32-webgl",
      filter: "texture-filter-linear-float32-webgl",
      renderbuffer: true
    },
    "rgba16uint": {
      gl: 36214,
      b: 8,
      c: 4,
      renderbuffer: true
    },
    "rgba16sint": {
      gl: 36232,
      b: 8,
      c: 4,
      renderbuffer: true
    },
    "rgba16float": {
      gl: 34842,
      gl1: 6408,
      b: 8,
      c: 4,
      render: "texture-renderable-float16-webgl",
      filter: "texture-filter-linear-float16-webgl"
    },
    "rgba16unorm-webgl": {
      gl: 32859,
      b: 2,
      c: 4,
      f: "texture-formats-norm16-webgl",
      renderbuffer: true,
      x: EXT_TEXTURE_NORM16
    },
    "rgba16snorm-webgl": {
      gl: 36763,
      b: 2,
      c: 4,
      f: "texture-formats-norm16-webgl",
      x: EXT_TEXTURE_NORM16
    },
    "rgb32float-webgl": {
      gl: 34837,
      gl1: 6407,
      render: "texture-renderable-float32-webgl",
      filter: "texture-filter-linear-float32-webgl",
      gl2ext: EXT_FLOAT_RENDER_WEBGL2,
      gl1ext: EXT_FLOAT_WEBGL1,
      dataFormat: 6407,
      types: [5126]
    },
    "rgba32uint": {
      gl: 36208,
      b: 16,
      c: 4,
      renderbuffer: true
    },
    "rgba32sint": {
      gl: 36226,
      b: 16,
      c: 4,
      renderbuffer: true
    },
    "rgba32float": {
      gl: 34836,
      b: 16,
      c: 4,
      render: "texture-renderable-float32-webgl",
      filter: "texture-filter-linear-float32-webgl",
      renderbuffer: true
    },
    "stencil8": {
      gl: 36168,
      gl1: 36168,
      b: 1,
      c: 1,
      attachment: 36128,
      renderbuffer: true
    },
    "depth16unorm": {
      gl: 33189,
      gl1: 33189,
      b: 2,
      c: 1,
      attachment: 36096,
      renderbuffer: true
    },
    "depth24plus": {
      gl: 33190,
      b: 3,
      c: 1,
      attachment: 36096
    },
    "depth32float": {
      gl: 36012,
      b: 4,
      c: 1,
      attachment: 36096,
      renderbuffer: true
    },
    "depth24plus-stencil8": {
      gl: 34041,
      gl1: 34041,
      b: 4,
      c: 2,
      p: 1,
      attachment: 33306,
      renderbuffer: true,
      depthTexture: true
    },
    "depth24unorm-stencil8": {
      gl: 35056,
      b: 4,
      c: 2,
      p: 1,
      attachment: 33306,
      renderbuffer: true
    },
    "depth32float-stencil8": {
      gl: 36013,
      b: 5,
      c: 2,
      p: 1,
      attachment: 33306,
      renderbuffer: true
    },
    "bc1-rgb-unorm-webgl": {
      gl: 33776,
      x: X_S3TC,
      f: texture_compression_bc
    },
    "bc1-rgb-unorm-srgb-webgl": {
      gl: 35916,
      x: X_S3TC_SRGB,
      f: texture_compression_bc
    },
    "bc1-rgba-unorm": {
      gl: 33777,
      x: X_S3TC,
      f: texture_compression_bc
    },
    "bc1-rgba-unorm-srgb": {
      gl: 35916,
      x: X_S3TC_SRGB,
      f: texture_compression_bc
    },
    "bc2-rgba-unorm": {
      gl: 33778,
      x: X_S3TC,
      f: texture_compression_bc
    },
    "bc2-rgba-unorm-srgb": {
      gl: 35918,
      x: X_S3TC_SRGB,
      f: texture_compression_bc
    },
    "bc3-rgba-unorm": {
      gl: 33779,
      x: X_S3TC,
      f: texture_compression_bc
    },
    "bc3-rgba-unorm-srgb": {
      gl: 35919,
      x: X_S3TC_SRGB,
      f: texture_compression_bc
    },
    "bc4-r-unorm": {
      gl: 36283,
      x: X_RGTC,
      f: texture_compression_bc
    },
    "bc4-r-snorm": {
      gl: 36284,
      x: X_RGTC,
      f: texture_compression_bc
    },
    "bc5-rg-unorm": {
      gl: 36285,
      x: X_RGTC,
      f: texture_compression_bc
    },
    "bc5-rg-snorm": {
      gl: 36286,
      x: X_RGTC,
      f: texture_compression_bc
    },
    "bc6h-rgb-ufloat": {
      gl: 36495,
      x: X_BPTC,
      f: texture_compression_bc
    },
    "bc6h-rgb-float": {
      gl: 36494,
      x: X_BPTC,
      f: texture_compression_bc
    },
    "bc7-rgba-unorm": {
      gl: 36492,
      x: X_BPTC,
      f: texture_compression_bc
    },
    "bc7-rgba-unorm-srgb": {
      gl: 36493,
      x: X_BPTC,
      f: texture_compression_bc
    },
    "etc2-rgb8unorm": {
      gl: 37492,
      f: texture_compression_etc2
    },
    "etc2-rgb8unorm-srgb": {
      gl: 37494,
      f: texture_compression_etc2
    },
    "etc2-rgb8a1unorm": {
      gl: 37496,
      f: texture_compression_etc2
    },
    "etc2-rgb8a1unorm-srgb": {
      gl: 37497,
      f: texture_compression_etc2
    },
    "etc2-rgba8unorm": {
      gl: 37493,
      f: texture_compression_etc2
    },
    "etc2-rgba8unorm-srgb": {
      gl: 37495,
      f: texture_compression_etc2
    },
    "eac-r11unorm": {
      gl: 37488,
      f: texture_compression_etc2
    },
    "eac-r11snorm": {
      gl: 37489,
      f: texture_compression_etc2
    },
    "eac-rg11unorm": {
      gl: 37490,
      f: texture_compression_etc2
    },
    "eac-rg11snorm": {
      gl: 37491,
      f: texture_compression_etc2
    },
    "astc-4x4-unorm": {
      gl: 37808,
      f: texture_compression_astc
    },
    "astc-4x4-unorm-srgb": {
      gl: 37840,
      f: texture_compression_astc
    },
    "astc-5x4-unorm": {
      gl: 37809,
      f: texture_compression_astc
    },
    "astc-5x4-unorm-srgb": {
      gl: 37841,
      f: texture_compression_astc
    },
    "astc-5x5-unorm": {
      gl: 37810,
      f: texture_compression_astc
    },
    "astc-5x5-unorm-srgb": {
      gl: 37842,
      f: texture_compression_astc
    },
    "astc-6x5-unorm": {
      gl: 37811,
      f: texture_compression_astc
    },
    "astc-6x5-unorm-srgb": {
      gl: 37843,
      f: texture_compression_astc
    },
    "astc-6x6-unorm": {
      gl: 37812,
      f: texture_compression_astc
    },
    "astc-6x6-unorm-srgb": {
      gl: 37844,
      f: texture_compression_astc
    },
    "astc-8x5-unorm": {
      gl: 37813,
      f: texture_compression_astc
    },
    "astc-8x5-unorm-srgb": {
      gl: 37845,
      f: texture_compression_astc
    },
    "astc-8x6-unorm": {
      gl: 37814,
      f: texture_compression_astc
    },
    "astc-8x6-unorm-srgb": {
      gl: 37846,
      f: texture_compression_astc
    },
    "astc-8x8-unorm": {
      gl: 37815,
      f: texture_compression_astc
    },
    "astc-8x8-unorm-srgb": {
      gl: 37847,
      f: texture_compression_astc
    },
    "astc-10x5-unorm": {
      gl: 37819,
      f: texture_compression_astc
    },
    "astc-10x5-unorm-srgb": {
      gl: 37851,
      f: texture_compression_astc
    },
    "astc-10x6-unorm": {
      gl: 37817,
      f: texture_compression_astc
    },
    "astc-10x6-unorm-srgb": {
      gl: 37849,
      f: texture_compression_astc
    },
    "astc-10x8-unorm": {
      gl: 37818,
      f: texture_compression_astc
    },
    "astc-10x8-unorm-srgb": {
      gl: 37850,
      f: texture_compression_astc
    },
    "astc-10x10-unorm": {
      gl: 37819,
      f: texture_compression_astc
    },
    "astc-10x10-unorm-srgb": {
      gl: 37851,
      f: texture_compression_astc
    },
    "astc-12x10-unorm": {
      gl: 37820,
      f: texture_compression_astc
    },
    "astc-12x10-unorm-srgb": {
      gl: 37852,
      f: texture_compression_astc
    },
    "astc-12x12-unorm": {
      gl: 37821,
      f: texture_compression_astc
    },
    "astc-12x12-unorm-srgb": {
      gl: 37853,
      f: texture_compression_astc
    },
    "pvrtc-rgb4unorm-webgl": {
      gl: 35840,
      f: texture_compression_pvrtc_webgl
    },
    "pvrtc-rgba4unorm-webgl": {
      gl: 35842,
      f: texture_compression_pvrtc_webgl
    },
    "pvrtc-rbg2unorm-webgl": {
      gl: 35841,
      f: texture_compression_pvrtc_webgl
    },
    "pvrtc-rgba2unorm-webgl": {
      gl: 35843,
      f: texture_compression_pvrtc_webgl
    },
    "etc1-rbg-unorm-webgl": {
      gl: 36196,
      f: texture_compression_etc1_webgl
    },
    "atc-rgb-unorm-webgl": {
      gl: 35986,
      f: texture_compression_atc_webgl
    },
    "atc-rgba-unorm-webgl": {
      gl: 35986,
      f: texture_compression_atc_webgl
    },
    "atc-rgbai-unorm-webgl": {
      gl: 34798,
      f: texture_compression_atc_webgl
    }
  };
  var DATA_FORMAT_CHANNELS = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
  };
  var TYPE_SIZES3 = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
  };
  function isTextureFormatSupported(gl, formatOrGL) {
    const format = convertGLToTextureFormat(formatOrGL);
    const info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (isWebGL2(gl) ? info.gl === void 0 : info.gl1 === void 0) {
      return false;
    }
    const extension = info.x || (isWebGL2(gl) ? info.gl2ext || info.gl1ext : info.gl1ext);
    if (extension) {
      return Boolean(gl.getExtension(extension));
    }
    return true;
  }
  function isRenderbufferFormatSupported(gl, format) {
    return isTextureFormatSupported(gl, format) && TEXTURE_FORMATS[format]?.renderbuffer;
  }
  function convertGLToTextureFormat(format) {
    if (typeof format === "string") {
      return format;
    }
    const entry = Object.entries(TEXTURE_FORMATS).find(([, entry2]) => entry2.gl === format || entry2.gl1 === format);
    if (!entry) {
      throw new Error(`Unknown texture format ${format}`);
    }
    return entry[0];
  }
  function convertTextureFormatToGL(format, isWebGL23) {
    const formatInfo = TEXTURE_FORMATS[format];
    const webglFormat = isWebGL23 ? formatInfo?.gl : formatInfo?.gl1;
    if (webglFormat === void 0) {
      throw new Error(`Unsupported texture format ${format}`);
    }
    return webglFormat;
  }
  function isTextureFormatFilterable(gl, formatOrGL) {
    const format = convertGLToTextureFormat(formatOrGL);
    if (!isTextureFormatSupported(gl, format)) {
      return false;
    }
    try {
      const decoded = decodeTextureFormat(format);
      if (decoded.signed) {
        return false;
      }
    } catch {
      return false;
    }
    if (format.endsWith("32float")) {
      return Boolean(gl.getExtension("OES_texture_float_linear"));
    }
    if (format.endsWith("16float")) {
      return Boolean(gl.getExtension("OES_texture_half_float_linear"));
    }
    return true;
  }
  function isTextureFormatRenderable(gl, formatOrGL) {
    const format = convertGLToTextureFormat(formatOrGL);
    if (!isTextureFormatSupported(gl, format)) {
      return false;
    }
    if (typeof format === "number") {
      return false;
    }
    return true;
  }
  function getWebGLTextureParameters(formatOrGL, isWebGL23) {
    const format = convertGLToTextureFormat(formatOrGL);
    const webglFormat = convertTextureFormatToGL(format, isWebGL23);
    const decoded = decodeTextureFormat(format);
    return {
      format: webglFormat,
      dataFormat: getWebGLPixelDataFormat(decoded.format, decoded.integer, decoded.normalized, webglFormat),
      type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : 5121,
      compressed: decoded.compressed
    };
  }
  function getDepthStencilAttachmentWebGL(format) {
    const info = TEXTURE_FORMATS[format];
    if (!info?.attachment) {
      throw new Error(`${format} is not a depth stencil format`);
    }
    return info.attachment;
  }
  function _checkFloat32ColorAttachment(gl, internalFormat = 6408, srcFormat = 6408, srcType = 5121) {
    let texture = null;
    let framebuffer = null;
    try {
      texture = gl.createTexture();
      gl.bindTexture(3553, texture);
      const level = 0;
      const width = 1;
      const height = 1;
      const border = 0;
      const pixel = new Uint8Array([0, 0, 255, 255]);
      gl.texImage2D(3553, level, internalFormat, width, height, border, srcFormat, srcType, pixel);
      framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(36160, framebuffer);
      gl.framebufferTexture2D(36160, 36064, 3553, texture, 0);
      const status = gl.checkFramebufferStatus(36160) === 36053;
      gl.bindTexture(3553, null);
      return status;
    } finally {
      gl.deleteTexture(texture);
      gl.deleteFramebuffer(framebuffer);
    }
  }
  function getTextureFormatBytesPerPixel(formatOrGL, isWebGL23) {
    const format = convertGLToTextureFormat(formatOrGL);
    const params = getWebGLTextureParameters(format, isWebGL23);
    const channels = DATA_FORMAT_CHANNELS[params.dataFormat] || 4;
    const channelSize = TYPE_SIZES3[params.type] || 1;
    return channels * channelSize;
  }
  function getWebGLPixelDataFormat(dataFormat, integer, normalized, format) {
    if (format === 6408 || format === 6407) {
      return format;
    }
    switch (dataFormat) {
      case "r":
        return integer && !normalized ? 36244 : 6403;
      case "rg":
        return integer && !normalized ? 33320 : 33319;
      case "rgb":
        return integer && !normalized ? 36248 : 6407;
      case "rgba":
        return integer && !normalized ? 36249 : 6408;
      default:
        return 6408;
    }
  }

  // src/adapter/device-helpers/device-features.ts
  function getDeviceFeatures(gl) {
    const features = getWebGLFeatures(gl);
    for (const textureFeature of getTextureFeatures(gl)) {
      features.add(textureFeature);
    }
    return features;
  }
  function getWebGLFeatures(gl) {
    gl.getExtension("EXT_color_buffer_float");
    gl.getExtension("WEBGL_color_buffer_float");
    gl.getExtension("EXT_float_blend");
    const features = /* @__PURE__ */ new Set();
    for (const feature of Object.keys(WEBGL_FEATURES)) {
      if (isFeatureSupported(gl, feature)) {
        features.add(feature);
      }
    }
    return features;
  }
  function isFeatureSupported(gl, feature) {
    const featureInfo = WEBGL_FEATURES[feature];
    if (!featureInfo) {
      return false;
    }
    const [webgl1Feature, webgl2Feature] = featureInfo || [];
    const featureDefinition = isWebGL2(gl) ? webgl2Feature : webgl1Feature;
    if (typeof featureDefinition === "boolean") {
      return featureDefinition;
    }
    switch (feature) {
      case "texture-renderable-rgba32float-webgl":
        return isWebGL2(gl) ? Boolean(gl.getExtension(featureDefinition)) : _checkFloat32ColorAttachment(gl);
      case "glsl-derivatives":
        return canCompileGLSLExtension(gl, featureDefinition);
      case "glsl-frag-data":
        return canCompileGLSLExtension(gl, featureDefinition, {
          behavior: "require"
        });
      case "glsl-frag-depth":
        return canCompileGLSLExtension(gl, featureDefinition);
      default:
        return Boolean(gl.getExtension(featureDefinition));
    }
  }
  var compiledGLSLExtensions = {};
  function canCompileGLSLExtension(gl, extensionName, opts = {}) {
    if (!isOldIE(opts)) {
      return true;
    }
    if (extensionName in compiledGLSLExtensions) {
      return compiledGLSLExtensions[extensionName];
    }
    const behavior = opts.behavior || "enable";
    const source = `#extension GL_${extensionName} : ${behavior}
void main(void) {}`;
    const shader = gl.createShader(35633);
    if (!shader) {
      throw new Error("shader");
    }
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const canCompile = gl.getShaderParameter(shader, 35713);
    gl.deleteShader(shader);
    compiledGLSLExtensions[extensionName] = canCompile;
    return canCompile;
  }
  var WEBGL_FEATURES = {
    "webgl": [true, true],
    "webgl2": [false, true],
    "timer-query-webgl": ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
    "transform-feedback-webgl2": [false, true],
    "vertex-array-object-webgl1": ["OES_vertex_array_object", true],
    "instanced-rendering-webgl1": ["ANGLE_instanced_arrays", true],
    "multiple-render-targets-webgl1": ["WEBGL_draw_buffers", true],
    "index-uint32-webgl1": ["OES_element_index_uint", true],
    "blend-minmax-webgl1": ["EXT_blend_minmax", true],
    "texture-blend-float-webgl1": ["EXT_float_blend", "EXT_float_blend"],
    "texture-formats-srgb-webgl1": ["EXT_sRGB", true],
    "texture-formats-depth-webgl1": ["WEBGL_depth_texture", true],
    "texture-formats-float32-webgl1": ["OES_texture_float", true],
    "texture-formats-float16-webgl1": ["OES_texture_half_float", true],
    "texture-filter-linear-float32-webgl": ["OES_texture_float_linear", "OES_texture_float_linear"],
    "texture-filter-linear-float16-webgl": ["OES_texture_half_float_linear", "OES_texture_half_float_linear"],
    "texture-filter-anisotropic-webgl": ["EXT_texture_filter_anisotropic", "EXT_texture_filter_anisotropic"],
    "texture-renderable-rgba32float-webgl": ["WEBGL_color_buffer_float", "EXT_color_buffer_float"],
    "texture-renderable-float32-webgl": [false, "EXT_color_buffer_float"],
    "texture-renderable-float16-webgl": ["EXT_color_buffer_half_float", "EXT_color_buffer_half_float"],
    "glsl-frag-data": ["WEBGL_draw_buffers", true],
    "glsl-frag-depth": ["EXT_frag_depth", true],
    "glsl-derivatives": ["OES_standard_derivatives", true],
    "glsl-texture-lod": ["EXT_shader_texture_lod", true]
  };

  // src/adapter/device-helpers/device-limits.ts
  function getDeviceLimits(gl) {
    const gl2 = getWebGL2Context(gl);
    return {
      maxTextureDimension1D: 0,
      maxTextureDimension2D: gl.getParameter(3379),
      maxTextureDimension3D: gl2 ? gl2.getParameter(32883) : 0,
      maxTextureArrayLayers: gl2 ? gl2.getParameter(35071) : 0,
      maxBindGroups: 1,
      maxDynamicUniformBuffersPerPipelineLayout: 0,
      maxDynamicStorageBuffersPerPipelineLayout: 0,
      maxSampledTexturesPerShaderStage: gl.getParameter(35660),
      maxSamplersPerShaderStage: gl.getParameter(35661),
      maxStorageBuffersPerShaderStage: 0,
      maxStorageTexturesPerShaderStage: 0,
      maxUniformBuffersPerShaderStage: gl2 ? gl2.getParameter(35375) : 0,
      maxUniformBufferBindingSize: gl2 ? gl2.getParameter(35376) : 0,
      maxStorageBufferBindingSize: 0,
      minUniformBufferOffsetAlignment: gl2 ? gl2.getParameter(35380) : 0,
      minStorageBufferOffsetAlignment: 0,
      maxVertexBuffers: 0,
      maxVertexAttributes: gl.getParameter(34921),
      maxVertexBufferArrayStride: 2048,
      maxInterStageShaderComponents: gl2 ? gl2.getParameter(35659) : 0,
      maxComputeWorkgroupStorageSize: 0,
      maxComputeInvocationsPerWorkgroup: 0,
      maxComputeWorkgroupSizeX: 0,
      maxComputeWorkgroupSizeY: 0,
      maxComputeWorkgroupSizeZ: 0,
      maxComputeWorkgroupsPerDimension: 0
    };
  }
  function getWebGLLimits(gl) {
    const gl2 = getWebGL2Context(gl);
    function get(pname) {
      return gl.getParameter(pname);
    }
    function get2(pname, defaultValue) {
      return gl2 ? gl2.getParameter(pname) : defaultValue || 0;
    }
    return {
      [33902]: get(33902),
      [33901]: get(33901),
      [3379]: get(3379),
      [34076]: get(34076),
      [34930]: get(34930),
      [35661]: get(35661),
      [35660]: get(35660),
      [34024]: get(34024),
      [36348]: get(36348),
      [34921]: get(34921),
      [36347]: get(36347),
      [36349]: get(36349),
      [3386]: get(3386),
      [34047]: get(34047),
      [32883]: get2(32883),
      [35071]: get2(35071),
      [37447]: get2(37447),
      [36063]: get2(36063),
      [35379]: get2(35379),
      [35374]: get2(35374),
      [35377]: get2(35377),
      [34852]: get2(34852),
      [36203]: get2(36203),
      [33001]: get2(33001),
      [33e3]: get2(33e3),
      [37157]: get2(37157),
      [35373]: get2(35373),
      [35657]: get2(35657),
      [36183]: get2(36183),
      [37137]: get2(37137),
      [34045]: get2(34045),
      [35978]: get2(35978),
      [35979]: get2(35979),
      [35968]: get2(35968),
      [35376]: get2(35376),
      [35375]: get2(35375),
      [35659]: get2(35659),
      [37154]: get2(37154),
      [35371]: get2(35371),
      [35658]: get2(35658),
      [35076]: get2(35076),
      [35077]: get2(35077),
      [35380]: get2(35380)
    };
  }

  // src/context/state-tracker/with-parameters.ts
  function withGLParameters(device, parameters, func) {
    const webglDevice = WebGLDevice.attach(device);
    const gl = webglDevice.gl;
    if (isObjectEmpty3(parameters)) {
      return func(device);
    }
    const {
      nocatch = true
    } = parameters;
    pushContextState(gl);
    setGLParameters(gl, parameters);
    let value;
    if (nocatch) {
      value = func(gl);
      popContextState(gl);
    } else {
      try {
        value = func(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value;
  }
  function isObjectEmpty3(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }

  // src/adapter/converters/device-parameters.ts
  function withDeviceAndGLParameters(device, parameters, glParameters, func) {
    if (isObjectEmpty(parameters)) {
      return func(device);
    }
    pushContextState(device.gl);
    try {
      setDeviceParameters(device, parameters);
      setGLParameters(device, glParameters);
      return func(device);
    } finally {
      popContextState(device.gl);
    }
  }
  function withDeviceParameters(device, parameters, func) {
    if (isObjectEmpty(parameters)) {
      return func(device);
    }
    pushContextState(device.gl);
    try {
      setDeviceParameters(device, parameters);
      return func(device);
    } finally {
      popContextState(device.gl);
    }
  }
  function setDeviceParameters(device, parameters) {
    const webglDevice = WebGLDevice.attach(device);
    const {
      gl
    } = webglDevice;
    if (parameters.cullMode) {
      switch (parameters.cullMode) {
        case "none":
          gl.disable(2884);
          break;
        case "front":
          gl.enable(2884);
          gl.cullFace(1028);
          break;
        case "back":
          gl.enable(2884);
          gl.cullFace(1029);
          break;
      }
    }
    if (parameters.frontFace) {
      gl.frontFace(map("frontFace", parameters.frontFace, {
        ccw: 2305,
        cw: 2304
      }));
    }
    if (parameters.depthBias !== void 0) {
      gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);
    }
    if (parameters.depthWriteEnabled !== void 0) {
      gl.depthMask(mapBoolean("depthWriteEnabled", parameters.depthWriteEnabled));
    }
    if (parameters.depthCompare) {
      parameters.depthCompare !== "always" ? gl.enable(2929) : gl.disable(2929);
      gl.depthFunc(convertCompareFunction("depthCompare", parameters.depthCompare));
    }
    if (parameters.stencilWriteMask) {
      const mask = parameters.stencilWriteMask;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, mask);
    }
    if (parameters.stencilReadMask) {
      log.warn("stencilReadMask not supported under WebGL");
    }
    if (parameters.stencilCompare) {
      const mask = parameters.stencilReadMask || 4294967295;
      const glValue = convertCompareFunction("depthCompare", parameters.stencilCompare);
      parameters.stencilCompare !== "always" ? gl.enable(2960) : gl.disable(2960);
      gl.stencilFuncSeparate(1028, glValue, 0, mask);
      gl.stencilFuncSeparate(1029, glValue, 0, mask);
    }
    if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {
      const dppass = convertStencilOperation("stencilPassOperation", parameters.stencilPassOperation);
      const sfail = convertStencilOperation("stencilFailOperation", parameters.stencilFailOperation);
      const dpfail = convertStencilOperation("stencilDepthFailOperation", parameters.stencilDepthFailOperation);
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, sfail, dpfail, dppass);
    }
    if (parameters.blendColorOperation || parameters.blendAlphaOperation) {
      gl.enable(3042);
      const colorEquation = convertBlendOperationToEquation("blendColorOperation", parameters.blendColorOperation || "add");
      const alphaEquation = convertBlendOperationToEquation("blendAlphaOperation", parameters.blendAlphaOperation || "add");
      gl.blendEquationSeparate(colorEquation, alphaEquation);
      const colorSrcFactor = convertBlendFactorToFunction("blendColorSrcFactor", parameters.blendColorSrcFactor || "one");
      const colorDstFactor = convertBlendFactorToFunction("blendColorDstFactor", parameters.blendColorDstFactor || "zero");
      const alphaSrcFactor = convertBlendFactorToFunction("blendAlphaSrcFactor", parameters.blendAlphaSrcFactor || "one");
      const alphaDstFactor = convertBlendFactorToFunction("blendAlphaDstFactor", parameters.blendAlphaDstFactor || "zero");
      gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
    }
  }
  function convertCompareFunction(parameter, value) {
    return map(parameter, value, {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    });
  }
  function convertStencilOperation(parameter, value) {
    return map(parameter, value, {
      keep: 7680,
      zero: 0,
      replace: 7681,
      invert: 5386,
      "increment-clamp": 7682,
      "decrement-clamp": 7683,
      "increment-wrap": 34055,
      "decrement-wrap": 34056
    });
  }
  function convertBlendOperationToEquation(parameter, value) {
    return map(parameter, value, {
      "add": 32774,
      "subtract": 32778,
      "reverse-subtract": 32779,
      "min": 32775,
      "max": 32776
    });
  }
  function convertBlendFactorToFunction(parameter, value) {
    return map(parameter, value, {
      "one": 1,
      "zero": 0,
      "src-color": 768,
      "one-minus-src-color": 769,
      "dst-color": 774,
      "one-minus-dst-color": 775,
      "src-alpha": 770,
      "one-minus-src-alpha": 771,
      "dst-alpha": 772,
      "one-minus-dst-alpha": 773
    });
  }
  function message(parameter, value) {
    return `Illegal parameter ${value} for ${parameter}`;
  }
  function map(parameter, value, valueMap) {
    if (!(value in valueMap)) {
      throw new Error(message(parameter, value));
    }
    return valueMap[value];
  }
  function mapBoolean(parameter, value) {
    return value;
  }

  // src/adapter/converters/sampler-parameters.ts
  function convertSamplerParametersToWebGL(props) {
    const params = {};
    if (props.addressModeU) {
      params[10242] = convertAddressMode(props.addressModeU);
    }
    if (props.addressModeV) {
      params[10243] = convertAddressMode(props.addressModeV);
    }
    if (props.addressModeW) {
      params[32882] = convertAddressMode(props.addressModeW);
    }
    if (props.magFilter) {
      params[10240] = convertMaxFilterMode(props.magFilter);
    }
    if (props.minFilter || props.mipmapFilter) {
      params[10241] = convertMinFilterMode(props.minFilter || "linear", props.mipmapFilter);
    }
    if (props.lodMinClamp !== void 0) {
      params[33082] = props.lodMinClamp;
    }
    if (props.lodMaxClamp !== void 0) {
      params[33083] = props.lodMaxClamp;
    }
    if (props.type === "comparison-sampler") {
      params[34892] = 34894;
    }
    if (props.compare) {
      params[34893] = convertCompareFunction("compare", props.compare);
    }
    if (props.maxAnisotropy) {
      params[34046] = props.maxAnisotropy;
    }
    return params;
  }
  function updateSamplerParametersForNPOT(parameters) {
    const newParameters = {
      ...parameters
    };
    if (parameters[10241] !== 9728) {
      newParameters[10241] = 9729;
    }
    newParameters[10242] = 33071;
    newParameters[10243] = 33071;
    return newParameters;
  }
  function convertAddressMode(addressMode) {
    switch (addressMode) {
      case "clamp-to-edge":
        return 33071;
      case "repeat":
        return 10497;
      case "mirror-repeat":
        return 33648;
    }
  }
  function convertMaxFilterMode(maxFilter) {
    switch (maxFilter) {
      case "nearest":
        return 9728;
      case "linear":
        return 9729;
    }
  }
  function convertMinFilterMode(minFilter, mipmapFilter) {
    if (!mipmapFilter) {
      return convertMaxFilterMode(minFilter);
    }
    switch (minFilter) {
      case "nearest":
        return mipmapFilter === "nearest" ? 9984 : 9986;
      case "linear":
        return mipmapFilter === "nearest" ? 9985 : 9987;
    }
  }

  // src/adapter/resources/webgl-buffer.ts
  var WEBGLBuffer = class extends Buffer2 {
    glIndexType = 5123;
    constructor(device, props = {}) {
      super(device, props);
      this.device = device;
      this.gl = this.device.gl;
      this.gl2 = this.device.gl2;
      const handle = typeof props === "object" ? props.handle : void 0;
      this.handle = handle || this.gl.createBuffer();
      device.setSpectorMetadata(this.handle, {
        ...this.props,
        data: typeof this.props.data
      });
      this.glTarget = getWebGLTarget(this.props.usage);
      this.glUsage = getWebGLUsage(this.props.usage);
      this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123;
      if (props.data) {
        this._initWithData(props.data, props.byteOffset, props.byteLength);
      } else {
        this._initWithByteLength(props.byteLength || 0);
      }
    }
    _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
      const glTarget = this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      this.gl.bufferData(glTarget, byteLength, this.glUsage);
      this.gl.bufferSubData(glTarget, byteOffset, data);
      this.gl.bindBuffer(glTarget, null);
      this.bytesUsed = byteLength;
      this.byteLength = byteLength;
      this._setDebugData(data, byteOffset, byteLength);
      this.trackAllocatedMemory(byteLength);
    }
    _initWithByteLength(byteLength) {
      assert2(byteLength >= 0);
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const glTarget = this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      this.gl.bufferData(glTarget, data, this.glUsage);
      this.gl.bindBuffer(glTarget, null);
      this.bytesUsed = byteLength;
      this.byteLength = byteLength;
      this._setDebugData(null, 0, byteLength);
      this.trackAllocatedMemory(byteLength);
      return this;
    }
    destroy() {
      if (!this.destroyed && this.handle) {
        this.removeStats();
        this.trackDeallocatedMemory();
        this.gl.deleteBuffer(this.handle);
        this.destroyed = true;
        this.handle = null;
      }
    }
    write(data, byteOffset = 0) {
      const srcOffset = 0;
      const byteLength = void 0;
      const glTarget = this.device.isWebGL2 ? 36663 : this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        this.device.assertWebGL2();
        this.gl2.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(glTarget, byteOffset, data);
      }
      this.gl.bindBuffer(glTarget, null);
      this._setDebugData(data, byteOffset, data.byteLength);
    }
    async readAsync(byteOffset = 0, byteLength) {
      return this.readSyncWebGL2(byteOffset, byteLength);
    }
    readSyncWebGL2(byteOffset = 0, byteLength) {
      this.device.assertWebGL2();
      byteLength = byteLength ?? this.byteLength - byteOffset;
      const data = new Uint8Array(byteLength);
      const dstOffset = 0;
      this.gl.bindBuffer(36662, this.handle);
      this.gl2.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
      this.gl.bindBuffer(36662, null);
      this._setDebugData(data, byteOffset, byteLength);
      return data;
    }
  };
  function getWebGLTarget(usage) {
    if (usage & Buffer2.INDEX) {
      return 34963;
    }
    if (usage & Buffer2.VERTEX) {
      return 34962;
    }
    if (usage & Buffer2.UNIFORM) {
      return 35345;
    }
    return 34962;
  }
  function getWebGLUsage(usage) {
    if (usage & Buffer2.INDEX) {
      return 35044;
    }
    if (usage & Buffer2.VERTEX) {
      return 35044;
    }
    if (usage & Buffer2.UNIFORM) {
      return 35048;
    }
    return 35044;
  }

  // src/adapter/resources/webgl-sampler.ts
  var WEBGLSampler = class extends Sampler {
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.parameters = convertSamplerParametersToWebGL(props);
      if (this.device.isWebGL2) {
        this.handle = this.handle || this.device.gl2.createSampler();
        this._setSamplerParameters(this.parameters);
      }
    }
    destroy() {
      if (this.handle) {
        this.device.gl2.deleteSampler(this.handle);
        this.handle = void 0;
      }
    }
    toString() {
      return `Sampler(${this.id},${JSON.stringify(this.props)})`;
    }
    _setSamplerParameters(parameters) {
      for (const [pname, value] of Object.entries(parameters)) {
        const param = Number(pname);
        switch (param) {
          case 33082:
          case 33083:
            this.device.gl2.samplerParameterf(this.handle, param, value);
            break;
          default:
            this.device.gl2.samplerParameteri(this.handle, param, value);
            break;
        }
      }
    }
  };

  // src/adapter/resources/webgl-texture.ts
  var DEFAULT_WEBGL_TEXTURE_PROPS = {
    parameters: {},
    pixelStore: {},
    pixels: null,
    border: 0,
    dataFormat: void 0,
    textureUnit: void 0,
    target: void 0
  };
  var _WEBGLTexture = class extends Texture {
    sampler = void 0;
    glFormat = void 0;
    type = void 0;
    dataFormat = void 0;
    mipmaps = void 0;
    textureUnit = void 0;
    loaded = false;
    constructor(device, props) {
      super(device, {
        ...DEFAULT_WEBGL_TEXTURE_PROPS,
        format: "rgba8unorm",
        ...props
      });
      this.device = device;
      this.gl = this.device.gl;
      this.gl2 = this.device.gl2;
      this.handle = this.props.handle || this.gl.createTexture();
      this.device.setSpectorMetadata(this.handle, {
        ...this.props,
        data: typeof this.props.data
      });
      this.glFormat = 6408;
      this.target = getWebGLTextureTarget(this.props);
      this.loaded = false;
      if (typeof this.props?.data === "string") {
        Object.assign(this.props, {
          data: loadImage(this.props.data)
        });
      }
      this.initialize(this.props);
      Object.seal(this);
    }
    destroy() {
      if (this.handle) {
        this.gl.deleteTexture(this.handle);
        this.removeStats();
        this.trackDeallocatedMemory("Texture");
        this.destroyed = true;
      }
    }
    toString() {
      return `Texture(${this.id},${this.width}x${this.height})`;
    }
    initialize(props = {}) {
      if (this.props.dimension === "cube") {
        return this.initializeCube(props);
      }
      let data = props.data;
      if (data instanceof Promise) {
        data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
          pixels: resolvedImageData,
          data: resolvedImageData
        })));
        return this;
      }
      const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
        this._video = null;
        data.addEventListener("loadeddata", () => this.initialize(props));
        return this;
      }
      const {
        parameters = {}
      } = props;
      const {
        pixels = null,
        pixelStore = {},
        textureUnit = void 0
      } = props;
      if (!data) {
        data = pixels;
      }
      let {
        width,
        height,
        dataFormat,
        type,
        compressed = false,
        mipmaps = true
      } = props;
      const {
        depth = 0
      } = props;
      const glFormat = convertTextureFormatToGL(props.format, this.device.isWebGL2);
      ({
        width,
        height,
        compressed,
        dataFormat,
        type
      } = this._deduceParameters({
        format: props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      this.width = width;
      this.height = height;
      this.glFormat = glFormat;
      this.type = type;
      this.dataFormat = dataFormat;
      this.textureUnit = textureUnit;
      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }
      if (mipmaps && this.device.isWebGL1 && isNPOT(this.width, this.height)) {
        log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaps`)();
        mipmaps = false;
      }
      this.mipmaps = mipmaps;
      this.setImageData({
        data,
        width,
        height,
        depth,
        format: glFormat,
        type,
        dataFormat,
        parameters: pixelStore,
        compressed
      });
      this.setSampler(props.sampler);
      this._setSamplerParameters(parameters);
      if (mipmaps) {
        this.generateMipmap();
      }
      if (isVideo) {
        this._video = {
          video: data,
          parameters,
          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
      }
      return this;
    }
    initializeCube(props) {
      const {
        mipmaps = true,
        parameters = {}
      } = props;
      this.setCubeMapImageData(props).then(() => {
        this.loaded = true;
        if (mipmaps) {
          this.generateMipmap(props);
        }
        this.setSampler(props.sampler);
        this._setSamplerParameters(parameters);
      });
      return this;
    }
    setSampler(sampler = {}) {
      let samplerProps;
      if (sampler instanceof WEBGLSampler) {
        this.sampler = sampler;
        samplerProps = sampler.props;
      } else {
        this.sampler = new WEBGLSampler(this.device, sampler);
        samplerProps = sampler;
      }
      const parameters = convertSamplerParametersToWebGL(samplerProps);
      this._setSamplerParameters(parameters);
      return this;
    }
    resize(options) {
      const {
        height,
        width,
        mipmaps = false
      } = options;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          mipmaps
        });
      }
      return this;
    }
    update() {
      if (this._video) {
        const {
          video,
          parameters,
          lastTime
        } = this._video;
        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
          return;
        }
        this.setSubImageData({
          data: video,
          parameters
        });
        if (this.mipmaps) {
          this.generateMipmap();
        }
        this._video.lastTime = video.currentTime;
      }
    }
    generateMipmap(params = {}) {
      if (this.device.isWebGL1 && isNPOT(this.width, this.height)) {
        log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();
        return this;
      }
      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      withGLParameters(this.gl, params, () => {
        this.gl.generateMipmap(this.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
    setImageData(options) {
      if (this.props.dimension === "3d" || this.props.dimension === "2d-array") {
        return this.setImageData3D(options);
      }
      this.trackDeallocatedMemory("Texture");
      const {
        target = this.target,
        pixels = null,
        level = 0,
        glFormat = this.glFormat,
        offset = 0,
        parameters = {}
      } = options;
      let {
        data = null,
        type = this.type,
        width = this.width,
        height = this.height,
        dataFormat = this.dataFormat,
        compressed = false
      } = options;
      if (!data) {
        data = pixels;
      }
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format: this.props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      const {
        gl
      } = this;
      gl.bindTexture(this.target, this.handle);
      let dataType = null;
      ({
        data,
        dataType
      } = this._getDataType({
        data,
        compressed
      }));
      let gl2;
      withGLParameters(this.gl, parameters, () => {
        switch (dataType) {
          case "null":
            gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, data);
            break;
          case "typed-array":
            gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, data, offset);
            break;
          case "buffer":
            gl2 = this.device.assertWebGL2();
            gl2.bindBuffer(35052, data.handle || data);
            gl2.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
            break;
          case "browser-object":
            if (this.device.isWebGL2) {
              gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, data);
            } else {
              gl.texImage2D(target, level, glFormat, dataFormat, type, data);
            }
            break;
          case "compressed":
            for (const [levelIndex, levelData] of data.entries()) {
              gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, 0, levelData.data);
            }
            break;
          default:
            assert2(false, "Unknown image data type");
        }
      });
      if (data && data.byteLength) {
        this.trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format, this.device.isWebGL2);
        this.trackAllocatedMemory(this.width * this.height * bytesPerPixel, "Texture");
      }
      this.loaded = true;
      return this;
    }
    setSubImageData({
      target = this.target,
      pixels = null,
      data = null,
      x = 0,
      y = 0,
      width = this.width,
      height = this.height,
      level = 0,
      glFormat = this.glFormat,
      type = this.type,
      dataFormat = this.dataFormat,
      compressed = false,
      offset = 0,
      parameters = {}
    }) {
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format: this.props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      assert2(this.depth === 1, "texSubImage not supported for 3D textures");
      if (!data) {
        data = pixels;
      }
      if (data && data.data) {
        const ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }
      if (data instanceof WEBGLBuffer) {
        data = data.handle;
      }
      this.gl.bindTexture(this.target, this.handle);
      withGLParameters(this.gl, parameters, () => {
        if (compressed) {
          this.gl.compressedTexSubImage2D(target, level, x, y, width, height, glFormat, data);
        } else if (data === null) {
          this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
        } else if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
          const gl2 = this.device.assertWebGL2();
          gl2.bindBuffer(35052, data);
          gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
        } else if (this.device.isWebGL2) {
          const gl2 = this.device.assertWebGL2();
          gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
        } else {
          this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer(opts = {}) {
      log.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind(textureUnit = this.textureUnit) {
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
    unbind(textureUnit = this.textureUnit) {
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, null);
      return textureUnit;
    }
    _getDataType({
      data,
      compressed = false
    }) {
      if (compressed) {
        return {
          data,
          dataType: "compressed"
        };
      }
      if (data === null) {
        return {
          data,
          dataType: "null"
        };
      }
      if (ArrayBuffer.isView(data)) {
        return {
          data,
          dataType: "typed-array"
        };
      }
      if (data instanceof WEBGLBuffer) {
        return {
          data: data.handle,
          dataType: "buffer"
        };
      }
      if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
        return {
          data,
          dataType: "buffer"
        };
      }
      return {
        data,
        dataType: "browser-object"
      };
    }
    _deduceParameters(opts) {
      const {
        format,
        data
      } = opts;
      let {
        width,
        height,
        dataFormat,
        type,
        compressed
      } = opts;
      const parameters = getWebGLTextureParameters(format, this.device.isWebGL2);
      dataFormat = dataFormat || parameters.dataFormat;
      type = type || parameters.type;
      compressed = compressed || parameters.compressed;
      ({
        width,
        height
      } = this._deduceImageSize(data, width, height));
      return {
        dataFormat,
        type,
        compressed,
        width,
        height,
        format,
        data
      };
    }
    _deduceImageSize(data, width, height) {
      let size;
      if (typeof ImageData !== "undefined" && data instanceof ImageData) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        size = {
          width: data.naturalWidth,
          height: data.naturalHeight
        };
      } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        size = {
          width: data.videoWidth,
          height: data.videoHeight
        };
      } else if (!data) {
        size = {
          width: width >= 0 ? width : 1,
          height: height >= 0 ? height : 1
        };
      } else {
        size = {
          width,
          height
        };
      }
      assert2(size, "Could not deduced texture size");
      assert2(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
      assert2(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
      return size;
    }
    async setCubeMapImageData(options) {
      const {
        gl
      } = this;
      const {
        width,
        height,
        pixels,
        data,
        format = 6408,
        type = 5121
      } = options;
      const imageDataMap = pixels || data;
      const resolvedFaces = await Promise.all(_WEBGLTexture.FACES.map((face) => {
        const facePixels = imageDataMap[face];
        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
      }));
      this.bind();
      _WEBGLTexture.FACES.forEach((face, index) => {
        if (resolvedFaces[index].length > 1 && this.props.mipmaps !== false) {
          log.warn(`${this.id} has mipmap and multiple LODs.`)();
        }
        resolvedFaces[index].forEach((image, lodLevel) => {
          if (width && height) {
            gl.texImage2D(face, lodLevel, format, width, height, 0, format, type, image);
          } else {
            gl.texImage2D(face, lodLevel, format, format, type, image);
          }
        });
      });
      this.unbind();
    }
    setImageDataForFace(options) {
      const {
        face,
        width,
        height,
        pixels,
        data,
        format = 6408,
        type = 5121
      } = options;
      const {
        gl
      } = this;
      const imageData = pixels || data;
      this.bind();
      if (imageData instanceof Promise) {
        imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
          face,
          data: resolvedImageData,
          pixels: resolvedImageData
        })));
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width, height, 0, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }
      return this;
    }
    setImageData3D(options) {
      const {
        level = 0,
        dataFormat,
        format,
        type,
        width,
        height,
        depth = 1,
        offset = 0,
        data,
        parameters = {}
      } = options;
      this.trackDeallocatedMemory("Texture");
      this.gl.bindTexture(this.target, this.handle);
      const webglTextureFormat = getWebGLTextureParameters(format, this.device.isWebGL2);
      withGLParameters(this.gl, parameters, () => {
        if (ArrayBuffer.isView(data)) {
          this.gl.texImage3D(this.target, level, webglTextureFormat.format, width, height, depth, 0, webglTextureFormat.dataFormat, webglTextureFormat.type, data);
        }
        if (data instanceof WEBGLBuffer) {
          this.gl.bindBuffer(35052, data.handle);
          this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, 0, format, type, offset);
        }
      });
      if (data && data.byteLength) {
        this.trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format, this.device.isWebGL2);
        this.trackAllocatedMemory(this.width * this.height * this.depth * bytesPerPixel, "Texture");
      }
      this.loaded = true;
      return this;
    }
    _setSamplerParameters(parameters) {
      if (this.device.isWebGL1 && isNPOT(this.width, this.height)) {
        parameters = updateSamplerParametersForNPOT(parameters);
      }
      if (isObjectEmpty(parameters)) {
        return;
      }
      logParameters(parameters);
      this.gl.bindTexture(this.target, this.handle);
      for (const [pname, pvalue] of Object.entries(parameters)) {
        const param = Number(pname);
        const value = pvalue;
        switch (param) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.target, param, value);
            break;
          default:
            this.gl.texParameteri(this.target, param, value);
            break;
        }
      }
      this.gl.bindTexture(this.target, null);
      return;
    }
    _getWebGL1NPOTParameterOverride(pname, value) {
      const npot = this.device.isWebGL1 && isNPOT(this.width, this.height);
      if (npot) {
        switch (pname) {
          case 10241:
            if (value !== 9729 && value !== 9728) {
              return 9729;
            }
            break;
          case 10242:
          case 10243:
            return 33071;
          default:
            break;
        }
      }
      return value;
    }
  };
  var WEBGLTexture = _WEBGLTexture;
  __publicField(WEBGLTexture, "FACES", [34069, 34070, 34071, 34072, 34073, 34074]);
  function getWebGLTextureTarget(props) {
    switch (props.dimension) {
      case "2d":
        return 3553;
      case "cube":
        return 34067;
      case "2d-array":
        return 35866;
      case "3d":
        return 32879;
      case "1d":
      case "cube-array":
      default:
        throw new Error(props.dimension);
    }
  }
  function isNPOT(width, height) {
    if (!width || !height) {
      return false;
    }
    return !isPowerOfTwo(width) || !isPowerOfTwo(height);
  }
  function logParameters(parameters) {
    log.log(1, "texture sampler parameters", parameters)();
  }

  // src/adapter/objects/constants-to-keys.ts
  function getKeyValue(gl, name2) {
    if (typeof name2 !== "string") {
      return name2;
    }
    const number = Number(name2);
    if (!isNaN(number)) {
      return number;
    }
    name2 = name2.replace(/^.*\./, "");
    const value = gl[name2];
    assert2(value !== void 0, `Accessing undefined constant GL.${name2}`);
    return value;
  }

  // src/adapter/objects/webgl-resource.ts
  var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  var WebGLResource = class extends Resource {
    _bound = false;
    byteLength = 0;
    constructor(device, props, defaultProps) {
      super(device, props, defaultProps);
      this.device = WebGLDevice.attach(device);
      const gl = this.device.gl;
      assertWebGLContext(gl);
      const {
        id
      } = props || {};
      this.gl = gl;
      this.gl2 = gl;
      this.id = id || uid(this.constructor.name);
      this._handle = props?.handle;
      if (this._handle === void 0) {
        this._handle = this._createHandle();
      }
      this.byteLength = 0;
    }
    toString() {
      return `${this.constructor.name}(${this.id})`;
    }
    get handle() {
      return this._handle;
    }
    delete({
      deleteChildren = false
    } = {}) {
      const children = this._handle && this._deleteHandle(this._handle);
      if (this._handle) {
        this.removeStats();
      }
      this._handle = null;
      if (children && deleteChildren) {
        children.filter(Boolean).forEach((child) => child.destroy());
      }
      return this;
    }
    bind(funcOrHandle = this.handle) {
      if (typeof funcOrHandle !== "function") {
        this._bindHandle(funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this._bindHandle(this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this._bindHandle(null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    getParameter(pname, props = {}) {
      pname = getKeyValue(this.gl, pname);
      assert2(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          const webgl1Default = parameter.webgl1;
          const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
          const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue;
        }
      }
      return this._getParameter(pname, props);
    }
    getParameters(options = {}) {
      const {
        parameters,
        keys
      } = options;
      const PARAMETERS = this.constructor.PARAMETERS || {};
      const isWebgl2 = isWebGL2(this.gl);
      const values = {};
      const parameterKeys = parameters || Object.keys(PARAMETERS);
      for (const pname of parameterKeys) {
        const parameter = PARAMETERS[pname];
        const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (parameterAvailable) {
          const key = keys ? this.device.getGLKey(pname) : pname;
          values[key] = this.getParameter(pname, options);
          if (keys && parameter.type === "GLenum") {
            values[key] = this.device.getGLKey(values[key]);
          }
        }
      }
      return values;
    }
    setParameter(pname, value) {
      pname = getKeyValue(this.gl, pname);
      assert2(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          throw new Error("Parameter not available on this platform");
        }
        if (parameter.type === "GLenum") {
          value = getKeyValue(value);
        }
      }
      this._setParameter(pname, value);
      return this;
    }
    setParameters(parameters) {
      for (const pname in parameters) {
        this.setParameter(pname, parameters[pname]);
      }
      return this;
    }
    stubRemovedMethods(className, version, methodNames) {
      return stubRemovedMethods(this, className, version, methodNames);
    }
    initialize(props) {
    }
    _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, props) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  };

  // src/adapter/objects/webgl-renderbuffer.ts
  var _WEBGLRenderbuffer = class extends WebGLResource {
    get [Symbol.toStringTag]() {
      return "Renderbuffer";
    }
    get width() {
      return this.props.width;
    }
    get height() {
      return this.props.height;
    }
    get format() {
      return this.props.format;
    }
    get samples() {
      return this.props.samples;
    }
    get attachment() {
      return;
    }
    static isTextureFormatSupported(device, format) {
      return isRenderbufferFormatSupported(device.gl, format);
    }
    constructor(device, props) {
      if (typeof props.format === "number") {
        throw new Error("Renderbuffer");
      }
      super(device, props, _WEBGLRenderbuffer.defaultProps);
      this.glFormat = convertTextureFormatToGL(this.props.format, device.isWebGL2);
      this._initialize(this.props);
    }
    resize(size) {
      if (size.width !== this.width || size.height !== this.height) {
        Object.assign(this.props, {
          ...size,
          format: this.format,
          samples: this.samples
        });
        this._initialize(this.props);
      }
    }
    _initialize(props) {
      const {
        format,
        width,
        height,
        samples
      } = props;
      assert2(format, "Needs format");
      this.trackDeallocatedMemory();
      this.gl.bindRenderbuffer(36161, this.handle);
      if (samples !== 0 && this.device.isWebGL2) {
        this.gl2.renderbufferStorageMultisample(36161, samples, this.glFormat, width, height);
      } else {
        this.gl.renderbufferStorage(36161, this.glFormat, width, height);
      }
      this.gl.bindRenderbuffer(36161, null);
      this.trackAllocatedMemory(width * height * (samples || 1) * getTextureFormatBytesPerPixel(this.glFormat, this.device.isWebGL2));
    }
    _createHandle() {
      return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);
      this.trackDeallocatedMemory();
    }
    _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161, handle);
    }
  };
  var WEBGLRenderbuffer = _WEBGLRenderbuffer;
  __publicField(WEBGLRenderbuffer, "defaultProps", {
    id: void 0,
    handle: void 0,
    userData: void 0,
    format: void 0,
    width: 1,
    height: 1,
    samples: 0
  });

  // src/adapter/resources/webgl-framebuffer.ts
  var WEBGLFramebuffer = class extends Framebuffer {
    get texture() {
      return this.colorAttachments[0];
    }
    constructor(device, props) {
      super(device, props);
      const isDefaultFramebuffer = props.handle === null;
      this.device = device;
      this.gl = device.gl;
      this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
      if (!isDefaultFramebuffer) {
        device.setSpectorMetadata(this.handle, {
          id: this.props.id,
          props: this.props
        });
        this.autoCreateAttachmentTextures();
        this.gl.bindFramebuffer(36160, this.handle);
        for (let i = 0; i < this.colorAttachments.length; ++i) {
          const attachment = this.colorAttachments[i];
          const attachmentPoint = 36064 + i;
          if (attachment) {
            this._attachOne(attachmentPoint, attachment);
          }
        }
        if (this.depthStencilAttachment) {
          this._attachOne(getDepthStencilAttachmentWebGL(this.depthStencilAttachment.format), this.depthStencilAttachment);
        }
        this.gl.bindFramebuffer(36160, null);
      }
      if (props.check !== false) {
        this._checkStatus();
      }
    }
    destroy() {
      super.destroy();
      if (!this.destroyed && this.handle !== null) {
        this.gl.deleteFramebuffer(this.handle);
      }
    }
    _checkStatus() {
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      const status = gl.checkFramebufferStatus(36160);
      gl.bindFramebuffer(36160, prevHandle || null);
      if (status !== 36053) {
        throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
      }
    }
    createDepthStencilTexture(format) {
      return new WEBGLRenderbuffer(this.device, {
        id: `${this.id}-depth-stencil`,
        format,
        width: this.width,
        height: this.height
      });
    }
    resizeAttachments(width, height) {
      if (this.handle === null) {
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }
      if (width === void 0) {
        width = this.gl.drawingBufferWidth;
      }
      if (height === void 0) {
        height = this.gl.drawingBufferHeight;
      }
      for (const colorAttachment of this.colorAttachments) {
        colorAttachment.resize({
          width,
          height
        });
      }
      if (this.depthStencilAttachment) {
        this.depthStencilAttachment.resize({
          width,
          height
        });
      }
      return this;
    }
    _attachOne(attachmentPoint, attachment) {
      if (attachment instanceof WEBGLRenderbuffer) {
        this._attachWEBGLRenderbuffer(attachmentPoint, attachment);
        return attachment;
      } else if (Array.isArray(attachment)) {
        const [texture, layer = 0, level = 0] = attachment;
        this._attachTexture(attachmentPoint, texture, layer, level);
        return texture;
      } else if (attachment instanceof WEBGLTexture) {
        this._attachTexture(attachmentPoint, attachment, 0, 0);
        return attachment;
      }
      throw new Error("attach");
    }
    _attachWEBGLRenderbuffer(attachment, renderbuffer) {
      this.gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
    }
    _attachTexture(attachment, texture, layer, level) {
      const {
        gl,
        gl2
      } = this.device;
      gl.bindTexture(texture.target, texture.handle);
      switch (texture.target) {
        case 35866:
        case 32879:
          this.device.assertWebGL2();
          gl2?.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;
        case 34067:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;
        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;
        default:
          assert2(false, "Illegal texture type");
      }
      gl.bindTexture(texture.target, null);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    switch (status) {
      case 36053:
        return "success";
      case 36054:
        return "Mismatched attachments";
      case 36055:
        return "No attachments";
      case 36057:
        return "Height/width mismatch";
      case 36061:
        return "Unsupported or split attachments";
      case 36182:
        return "Samples mismatch";
      default:
        return `${status}`;
    }
  }

  // src/adapter/webgl-canvas-context.ts
  var WebGLCanvasContext = class extends CanvasContext {
    _framebuffer = null;
    constructor(device, props) {
      super(props);
      this.device = device;
      this.presentationSize = [-1, -1];
      this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
      this.update();
    }
    getCurrentFramebuffer() {
      this.update();
      this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, {
        handle: null
      });
      return this._framebuffer;
    }
    update() {
      const size = this.getPixelSize();
      const sizeChanged = size[0] !== this.presentationSize[0] || size[1] !== this.presentationSize[1];
      if (sizeChanged) {
        this.presentationSize = size;
        this.resize();
      }
    }
    resize(options) {
      if (!this.device.gl)
        return;
      if (this.canvas) {
        const devicePixelRatio = this.getDevicePixelRatio(options?.useDevicePixels);
        this.setDevicePixelRatio(devicePixelRatio, options);
        return;
      }
      const ext = this.device.gl.getExtension("STACKGL_resize_drawingbuffer");
      if (ext && options && "width" in options && "height" in options) {
        ext.resize(options.width, options.height);
      }
    }
    commit() {
    }
  };

  // src/context/debug/spector.ts
  var DEFAULT_SPECTOR_PROPS = {
    spector: log.get("spector") || log.get("inspect")
  };
  var SPECTOR_CDN_URL = "https://spectorcdn.babylonjs.com/spector.bundle.js";
  var LOG_LEVEL = 1;
  var spector = null;
  var initialized = false;
  async function loadSpectorJS(props) {
    if (!globalThis.SPECTOR) {
      try {
        await loadScript(SPECTOR_CDN_URL);
      } catch (error2) {
        log.warn(String(error2));
      }
    }
  }
  function initializeSpectorJS(props) {
    props = {
      ...DEFAULT_SPECTOR_PROPS,
      ...props
    };
    if (!props?.spector) {
      return null;
    }
    if (!spector && globalThis.SPECTOR) {
      log.probe(LOG_LEVEL, "SPECTOR found and initialized")();
      spector = new globalThis.SPECTOR.Spector();
      if (globalThis.luma) {
        globalThis.luma.spector = spector;
      }
    }
    if (!spector) {
      return null;
    }
    if (!initialized) {
      initialized = true;
      spector.spyCanvases();
      spector?.onCaptureStarted.add((capture) => log.info("Spector capture started:", capture)());
      spector?.onCapture.add((capture) => {
        log.info("Spector capture complete:", capture)();
        spector?.getResultUI();
        spector?.resultView.display();
        spector?.resultView.addCapture(capture);
      });
    }
    if (props?.canvas) {
      if (typeof props.spector === "string" && props.spector !== props.canvas.id) {
        return spector;
      }
      spector?.startCapture(props?.canvas, 500);
      new Promise((resolve) => setTimeout(resolve, 2e3)).then((_) => {
        log.info("Spector capture stopped after 2 seconds")();
        spector?.stopCapture();
      });
    }
    return spector;
  }

  // ../constants/src/constants-enum.ts
  var GLEnum = function(GLEnum2) {
    GLEnum2[GLEnum2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
    GLEnum2[GLEnum2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
    GLEnum2[GLEnum2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
    GLEnum2[GLEnum2["POINTS"] = 0] = "POINTS";
    GLEnum2[GLEnum2["LINES"] = 1] = "LINES";
    GLEnum2[GLEnum2["LINE_LOOP"] = 2] = "LINE_LOOP";
    GLEnum2[GLEnum2["LINE_STRIP"] = 3] = "LINE_STRIP";
    GLEnum2[GLEnum2["TRIANGLES"] = 4] = "TRIANGLES";
    GLEnum2[GLEnum2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    GLEnum2[GLEnum2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    GLEnum2[GLEnum2["ZERO"] = 0] = "ZERO";
    GLEnum2[GLEnum2["ONE"] = 1] = "ONE";
    GLEnum2[GLEnum2["SRC_COLOR"] = 768] = "SRC_COLOR";
    GLEnum2[GLEnum2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    GLEnum2[GLEnum2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    GLEnum2[GLEnum2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    GLEnum2[GLEnum2["DST_ALPHA"] = 772] = "DST_ALPHA";
    GLEnum2[GLEnum2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    GLEnum2[GLEnum2["DST_COLOR"] = 774] = "DST_COLOR";
    GLEnum2[GLEnum2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    GLEnum2[GLEnum2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    GLEnum2[GLEnum2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    GLEnum2[GLEnum2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    GLEnum2[GLEnum2["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GLEnum2[GLEnum2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
    GLEnum2[GLEnum2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
    GLEnum2[GLEnum2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
    GLEnum2[GLEnum2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
    GLEnum2[GLEnum2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
    GLEnum2[GLEnum2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
    GLEnum2[GLEnum2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
    GLEnum2[GLEnum2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
    GLEnum2[GLEnum2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
    GLEnum2[GLEnum2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
    GLEnum2[GLEnum2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
    GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
    GLEnum2[GLEnum2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
    GLEnum2[GLEnum2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
    GLEnum2[GLEnum2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
    GLEnum2[GLEnum2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
    GLEnum2[GLEnum2["FRONT_FACE"] = 2886] = "FRONT_FACE";
    GLEnum2[GLEnum2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
    GLEnum2[GLEnum2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
    GLEnum2[GLEnum2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
    GLEnum2[GLEnum2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
    GLEnum2[GLEnum2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
    GLEnum2[GLEnum2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
    GLEnum2[GLEnum2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
    GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
    GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
    GLEnum2[GLEnum2["STENCIL_REF"] = 2967] = "STENCIL_REF";
    GLEnum2[GLEnum2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
    GLEnum2[GLEnum2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
    GLEnum2[GLEnum2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
    GLEnum2[GLEnum2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
    GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
    GLEnum2[GLEnum2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
    GLEnum2[GLEnum2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
    GLEnum2[GLEnum2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
    GLEnum2[GLEnum2["VIEWPORT"] = 2978] = "VIEWPORT";
    GLEnum2[GLEnum2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
    GLEnum2[GLEnum2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
    GLEnum2[GLEnum2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
    GLEnum2[GLEnum2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
    GLEnum2[GLEnum2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
    GLEnum2[GLEnum2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
    GLEnum2[GLEnum2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
    GLEnum2[GLEnum2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
    GLEnum2[GLEnum2["RED_BITS"] = 3410] = "RED_BITS";
    GLEnum2[GLEnum2["GREEN_BITS"] = 3411] = "GREEN_BITS";
    GLEnum2[GLEnum2["BLUE_BITS"] = 3412] = "BLUE_BITS";
    GLEnum2[GLEnum2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
    GLEnum2[GLEnum2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
    GLEnum2[GLEnum2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
    GLEnum2[GLEnum2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
    GLEnum2[GLEnum2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
    GLEnum2[GLEnum2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
    GLEnum2[GLEnum2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
    GLEnum2[GLEnum2["SAMPLES"] = 32937] = "SAMPLES";
    GLEnum2[GLEnum2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
    GLEnum2[GLEnum2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
    GLEnum2[GLEnum2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
    GLEnum2[GLEnum2["VENDOR"] = 7936] = "VENDOR";
    GLEnum2[GLEnum2["RENDERER"] = 7937] = "RENDERER";
    GLEnum2[GLEnum2["VERSION"] = 7938] = "VERSION";
    GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
    GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    GLEnum2[GLEnum2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
    GLEnum2[GLEnum2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
    GLEnum2[GLEnum2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
    GLEnum2[GLEnum2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
    GLEnum2[GLEnum2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    GLEnum2[GLEnum2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
    GLEnum2[GLEnum2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
    GLEnum2[GLEnum2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    GLEnum2[GLEnum2["CULL_FACE"] = 2884] = "CULL_FACE";
    GLEnum2[GLEnum2["FRONT"] = 1028] = "FRONT";
    GLEnum2[GLEnum2["BACK"] = 1029] = "BACK";
    GLEnum2[GLEnum2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
    GLEnum2[GLEnum2["BLEND"] = 3042] = "BLEND";
    GLEnum2[GLEnum2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
    GLEnum2[GLEnum2["DITHER"] = 3024] = "DITHER";
    GLEnum2[GLEnum2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
    GLEnum2[GLEnum2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
    GLEnum2[GLEnum2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
    GLEnum2[GLEnum2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
    GLEnum2[GLEnum2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
    GLEnum2[GLEnum2["NO_ERROR"] = 0] = "NO_ERROR";
    GLEnum2[GLEnum2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
    GLEnum2[GLEnum2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
    GLEnum2[GLEnum2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
    GLEnum2[GLEnum2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
    GLEnum2[GLEnum2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
    GLEnum2[GLEnum2["CW"] = 2304] = "CW";
    GLEnum2[GLEnum2["CCW"] = 2305] = "CCW";
    GLEnum2[GLEnum2["DONT_CARE"] = 4352] = "DONT_CARE";
    GLEnum2[GLEnum2["FASTEST"] = 4353] = "FASTEST";
    GLEnum2[GLEnum2["NICEST"] = 4354] = "NICEST";
    GLEnum2[GLEnum2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
    GLEnum2[GLEnum2["BYTE"] = 5120] = "BYTE";
    GLEnum2[GLEnum2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GLEnum2[GLEnum2["SHORT"] = 5122] = "SHORT";
    GLEnum2[GLEnum2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GLEnum2[GLEnum2["INT"] = 5124] = "INT";
    GLEnum2[GLEnum2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GLEnum2[GLEnum2["FLOAT"] = 5126] = "FLOAT";
    GLEnum2[GLEnum2["DOUBLE"] = 5130] = "DOUBLE";
    GLEnum2[GLEnum2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GLEnum2[GLEnum2["ALPHA"] = 6406] = "ALPHA";
    GLEnum2[GLEnum2["RGB"] = 6407] = "RGB";
    GLEnum2[GLEnum2["RGBA"] = 6408] = "RGBA";
    GLEnum2[GLEnum2["LUMINANCE"] = 6409] = "LUMINANCE";
    GLEnum2[GLEnum2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    GLEnum2[GLEnum2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GLEnum2[GLEnum2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GLEnum2[GLEnum2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    GLEnum2[GLEnum2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
    GLEnum2[GLEnum2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
    GLEnum2[GLEnum2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
    GLEnum2[GLEnum2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
    GLEnum2[GLEnum2["LINK_STATUS"] = 35714] = "LINK_STATUS";
    GLEnum2[GLEnum2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
    GLEnum2[GLEnum2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
    GLEnum2[GLEnum2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
    GLEnum2[GLEnum2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
    GLEnum2[GLEnum2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
    GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
    GLEnum2[GLEnum2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
    GLEnum2[GLEnum2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    GLEnum2[GLEnum2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    GLEnum2[GLEnum2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
    GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    GLEnum2[GLEnum2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
    GLEnum2[GLEnum2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
    GLEnum2[GLEnum2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
    GLEnum2[GLEnum2["NEVER"] = 512] = "NEVER";
    GLEnum2[GLEnum2["LESS"] = 513] = "LESS";
    GLEnum2[GLEnum2["EQUAL"] = 514] = "EQUAL";
    GLEnum2[GLEnum2["LEQUAL"] = 515] = "LEQUAL";
    GLEnum2[GLEnum2["GREATER"] = 516] = "GREATER";
    GLEnum2[GLEnum2["NOTEQUAL"] = 517] = "NOTEQUAL";
    GLEnum2[GLEnum2["GEQUAL"] = 518] = "GEQUAL";
    GLEnum2[GLEnum2["ALWAYS"] = 519] = "ALWAYS";
    GLEnum2[GLEnum2["KEEP"] = 7680] = "KEEP";
    GLEnum2[GLEnum2["REPLACE"] = 7681] = "REPLACE";
    GLEnum2[GLEnum2["INCR"] = 7682] = "INCR";
    GLEnum2[GLEnum2["DECR"] = 7683] = "DECR";
    GLEnum2[GLEnum2["INVERT"] = 5386] = "INVERT";
    GLEnum2[GLEnum2["INCR_WRAP"] = 34055] = "INCR_WRAP";
    GLEnum2[GLEnum2["DECR_WRAP"] = 34056] = "DECR_WRAP";
    GLEnum2[GLEnum2["NEAREST"] = 9728] = "NEAREST";
    GLEnum2[GLEnum2["LINEAR"] = 9729] = "LINEAR";
    GLEnum2[GLEnum2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GLEnum2[GLEnum2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLEnum2[GLEnum2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GLEnum2[GLEnum2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    GLEnum2[GLEnum2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
    GLEnum2[GLEnum2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    GLEnum2[GLEnum2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
    GLEnum2[GLEnum2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
    GLEnum2[GLEnum2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GLEnum2[GLEnum2["TEXTURE"] = 5890] = "TEXTURE";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GLEnum2[GLEnum2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    GLEnum2[GLEnum2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    GLEnum2[GLEnum2["TEXTURE0"] = 33984] = "TEXTURE0";
    GLEnum2[GLEnum2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
    GLEnum2[GLEnum2["REPEAT"] = 10497] = "REPEAT";
    GLEnum2[GLEnum2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GLEnum2[GLEnum2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    GLEnum2[GLEnum2["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
    GLEnum2[GLEnum2["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
    GLEnum2[GLEnum2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    GLEnum2[GLEnum2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    GLEnum2[GLEnum2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    GLEnum2[GLEnum2["INT_VEC2"] = 35667] = "INT_VEC2";
    GLEnum2[GLEnum2["INT_VEC3"] = 35668] = "INT_VEC3";
    GLEnum2[GLEnum2["INT_VEC4"] = 35669] = "INT_VEC4";
    GLEnum2[GLEnum2["BOOL"] = 35670] = "BOOL";
    GLEnum2[GLEnum2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    GLEnum2[GLEnum2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    GLEnum2[GLEnum2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    GLEnum2[GLEnum2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    GLEnum2[GLEnum2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    GLEnum2[GLEnum2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    GLEnum2[GLEnum2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    GLEnum2[GLEnum2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    GLEnum2[GLEnum2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
    GLEnum2[GLEnum2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
    GLEnum2[GLEnum2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
    GLEnum2[GLEnum2["LOW_INT"] = 36339] = "LOW_INT";
    GLEnum2[GLEnum2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
    GLEnum2[GLEnum2["HIGH_INT"] = 36341] = "HIGH_INT";
    GLEnum2[GLEnum2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
    GLEnum2[GLEnum2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
    GLEnum2[GLEnum2["RGBA4"] = 32854] = "RGBA4";
    GLEnum2[GLEnum2["RGB5_A1"] = 32855] = "RGB5_A1";
    GLEnum2[GLEnum2["RGB565"] = 36194] = "RGB565";
    GLEnum2[GLEnum2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
    GLEnum2[GLEnum2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
    GLEnum2[GLEnum2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
    GLEnum2[GLEnum2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    GLEnum2[GLEnum2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
    GLEnum2[GLEnum2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
    GLEnum2[GLEnum2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
    GLEnum2[GLEnum2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
    GLEnum2[GLEnum2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
    GLEnum2[GLEnum2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
    GLEnum2[GLEnum2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
    GLEnum2[GLEnum2["NONE"] = 0] = "NONE";
    GLEnum2[GLEnum2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
    GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    GLEnum2[GLEnum2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
    GLEnum2[GLEnum2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
    GLEnum2[GLEnum2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
    GLEnum2[GLEnum2["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
    GLEnum2[GLEnum2["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
    GLEnum2[GLEnum2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
    GLEnum2[GLEnum2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
    GLEnum2[GLEnum2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
    GLEnum2[GLEnum2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    GLEnum2[GLEnum2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    GLEnum2[GLEnum2["READ_BUFFER"] = 3074] = "READ_BUFFER";
    GLEnum2[GLEnum2["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
    GLEnum2[GLEnum2["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
    GLEnum2[GLEnum2["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
    GLEnum2[GLEnum2["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
    GLEnum2[GLEnum2["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
    GLEnum2[GLEnum2["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
    GLEnum2[GLEnum2["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
    GLEnum2[GLEnum2["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
    GLEnum2[GLEnum2["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
    GLEnum2[GLEnum2["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
    GLEnum2[GLEnum2["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
    GLEnum2[GLEnum2["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
    GLEnum2[GLEnum2["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
    GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    GLEnum2[GLEnum2["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
    GLEnum2[GLEnum2["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
    GLEnum2[GLEnum2["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
    GLEnum2[GLEnum2["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
    GLEnum2[GLEnum2["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    GLEnum2[GLEnum2["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
    GLEnum2[GLEnum2["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
    GLEnum2[GLEnum2["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    GLEnum2[GLEnum2["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    GLEnum2[GLEnum2["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
    GLEnum2[GLEnum2["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
    GLEnum2[GLEnum2["RED"] = 6403] = "RED";
    GLEnum2[GLEnum2["RGB8"] = 32849] = "RGB8";
    GLEnum2[GLEnum2["RGBA8"] = 32856] = "RGBA8";
    GLEnum2[GLEnum2["RGB10_A2"] = 32857] = "RGB10_A2";
    GLEnum2[GLEnum2["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
    GLEnum2[GLEnum2["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
    GLEnum2[GLEnum2["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
    GLEnum2[GLEnum2["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
    GLEnum2[GLEnum2["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
    GLEnum2[GLEnum2["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
    GLEnum2[GLEnum2["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
    GLEnum2[GLEnum2["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
    GLEnum2[GLEnum2["SRGB"] = 35904] = "SRGB";
    GLEnum2[GLEnum2["SRGB8"] = 35905] = "SRGB8";
    GLEnum2[GLEnum2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GLEnum2[GLEnum2["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
    GLEnum2[GLEnum2["RGBA32F"] = 34836] = "RGBA32F";
    GLEnum2[GLEnum2["RGB32F"] = 34837] = "RGB32F";
    GLEnum2[GLEnum2["RGBA16F"] = 34842] = "RGBA16F";
    GLEnum2[GLEnum2["RGB16F"] = 34843] = "RGB16F";
    GLEnum2[GLEnum2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GLEnum2[GLEnum2["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
    GLEnum2[GLEnum2["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
    GLEnum2[GLEnum2["RGB9_E5"] = 35901] = "RGB9_E5";
    GLEnum2[GLEnum2["RGBA32UI"] = 36208] = "RGBA32UI";
    GLEnum2[GLEnum2["RGB32UI"] = 36209] = "RGB32UI";
    GLEnum2[GLEnum2["RGBA16UI"] = 36214] = "RGBA16UI";
    GLEnum2[GLEnum2["RGB16UI"] = 36215] = "RGB16UI";
    GLEnum2[GLEnum2["RGBA8UI"] = 36220] = "RGBA8UI";
    GLEnum2[GLEnum2["RGB8UI"] = 36221] = "RGB8UI";
    GLEnum2[GLEnum2["RGBA32I"] = 36226] = "RGBA32I";
    GLEnum2[GLEnum2["RGB32I"] = 36227] = "RGB32I";
    GLEnum2[GLEnum2["RGBA16I"] = 36232] = "RGBA16I";
    GLEnum2[GLEnum2["RGB16I"] = 36233] = "RGB16I";
    GLEnum2[GLEnum2["RGBA8I"] = 36238] = "RGBA8I";
    GLEnum2[GLEnum2["RGB8I"] = 36239] = "RGB8I";
    GLEnum2[GLEnum2["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GLEnum2[GLEnum2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GLEnum2[GLEnum2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GLEnum2[GLEnum2["R8"] = 33321] = "R8";
    GLEnum2[GLEnum2["RG8"] = 33323] = "RG8";
    GLEnum2[GLEnum2["R16F"] = 33325] = "R16F";
    GLEnum2[GLEnum2["R32F"] = 33326] = "R32F";
    GLEnum2[GLEnum2["RG16F"] = 33327] = "RG16F";
    GLEnum2[GLEnum2["RG32F"] = 33328] = "RG32F";
    GLEnum2[GLEnum2["R8I"] = 33329] = "R8I";
    GLEnum2[GLEnum2["R8UI"] = 33330] = "R8UI";
    GLEnum2[GLEnum2["R16I"] = 33331] = "R16I";
    GLEnum2[GLEnum2["R16UI"] = 33332] = "R16UI";
    GLEnum2[GLEnum2["R32I"] = 33333] = "R32I";
    GLEnum2[GLEnum2["R32UI"] = 33334] = "R32UI";
    GLEnum2[GLEnum2["RG8I"] = 33335] = "RG8I";
    GLEnum2[GLEnum2["RG8UI"] = 33336] = "RG8UI";
    GLEnum2[GLEnum2["RG16I"] = 33337] = "RG16I";
    GLEnum2[GLEnum2["RG16UI"] = 33338] = "RG16UI";
    GLEnum2[GLEnum2["RG32I"] = 33339] = "RG32I";
    GLEnum2[GLEnum2["RG32UI"] = 33340] = "RG32UI";
    GLEnum2[GLEnum2["R8_SNORM"] = 36756] = "R8_SNORM";
    GLEnum2[GLEnum2["RG8_SNORM"] = 36757] = "RG8_SNORM";
    GLEnum2[GLEnum2["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
    GLEnum2[GLEnum2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GLEnum2[GLEnum2["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
    GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
    GLEnum2[GLEnum2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GLEnum2[GLEnum2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GLEnum2[GLEnum2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GLEnum2[GLEnum2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GLEnum2[GLEnum2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GLEnum2[GLEnum2["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
    GLEnum2[GLEnum2["RG"] = 33319] = "RG";
    GLEnum2[GLEnum2["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GLEnum2[GLEnum2["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
    GLEnum2[GLEnum2["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
    GLEnum2[GLEnum2["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
    GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
    GLEnum2[GLEnum2["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
    GLEnum2[GLEnum2["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    GLEnum2[GLEnum2["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
    GLEnum2[GLEnum2["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
    GLEnum2[GLEnum2["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
    GLEnum2[GLEnum2["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
    GLEnum2[GLEnum2["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
    GLEnum2[GLEnum2["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
    GLEnum2[GLEnum2["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
    GLEnum2[GLEnum2["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
    GLEnum2[GLEnum2["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
    GLEnum2[GLEnum2["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
    GLEnum2[GLEnum2["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
    GLEnum2[GLEnum2["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
    GLEnum2[GLEnum2["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
    GLEnum2[GLEnum2["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
    GLEnum2[GLEnum2["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
    GLEnum2[GLEnum2["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
    GLEnum2[GLEnum2["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
    GLEnum2[GLEnum2["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
    GLEnum2[GLEnum2["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
    GLEnum2[GLEnum2["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
    GLEnum2[GLEnum2["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
    GLEnum2[GLEnum2["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
    GLEnum2[GLEnum2["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
    GLEnum2[GLEnum2["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
    GLEnum2[GLEnum2["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
    GLEnum2[GLEnum2["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
    GLEnum2[GLEnum2["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
    GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
    GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
    GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
    GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    GLEnum2[GLEnum2["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
    GLEnum2[GLEnum2["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
    GLEnum2[GLEnum2["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
    GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
    GLEnum2[GLEnum2["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
    GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
    GLEnum2[GLEnum2["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
    GLEnum2[GLEnum2["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
    GLEnum2[GLEnum2["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
    GLEnum2[GLEnum2["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
    GLEnum2[GLEnum2["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
    GLEnum2[GLEnum2["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
    GLEnum2[GLEnum2["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
    GLEnum2[GLEnum2["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
    GLEnum2[GLEnum2["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
    GLEnum2[GLEnum2["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
    GLEnum2[GLEnum2["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
    GLEnum2[GLEnum2["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
    GLEnum2[GLEnum2["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
    GLEnum2[GLEnum2["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
    GLEnum2[GLEnum2["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    GLEnum2[GLEnum2["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
    GLEnum2[GLEnum2["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
    GLEnum2[GLEnum2["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    GLEnum2[GLEnum2["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
    GLEnum2[GLEnum2["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
    GLEnum2[GLEnum2["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    GLEnum2[GLEnum2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    GLEnum2[GLEnum2["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
    GLEnum2[GLEnum2["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
    GLEnum2[GLEnum2["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
    GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
    GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    GLEnum2[GLEnum2["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
    GLEnum2[GLEnum2["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
    GLEnum2[GLEnum2["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
    GLEnum2[GLEnum2["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    GLEnum2[GLEnum2["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum2[GLEnum2["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    GLEnum2[GLEnum2["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
    GLEnum2[GLEnum2["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
    GLEnum2[GLEnum2["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
    GLEnum2[GLEnum2["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
    GLEnum2[GLEnum2["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
    GLEnum2[GLEnum2["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
    GLEnum2[GLEnum2["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    GLEnum2[GLEnum2["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
    GLEnum2[GLEnum2["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
    GLEnum2[GLEnum2["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
    GLEnum2[GLEnum2["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
    GLEnum2[GLEnum2["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
    GLEnum2[GLEnum2["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
    GLEnum2[GLEnum2["UNSIGNALED"] = 37144] = "UNSIGNALED";
    GLEnum2[GLEnum2["SIGNALED"] = 37145] = "SIGNALED";
    GLEnum2[GLEnum2["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
    GLEnum2[GLEnum2["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
    GLEnum2[GLEnum2["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
    GLEnum2[GLEnum2["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
    GLEnum2[GLEnum2["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
    GLEnum2[GLEnum2["COLOR"] = 6144] = "COLOR";
    GLEnum2[GLEnum2["DEPTH"] = 6145] = "DEPTH";
    GLEnum2[GLEnum2["STENCIL"] = 6146] = "STENCIL";
    GLEnum2[GLEnum2["MIN"] = 32775] = "MIN";
    GLEnum2[GLEnum2["MAX"] = 32776] = "MAX";
    GLEnum2[GLEnum2["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    GLEnum2[GLEnum2["STREAM_READ"] = 35041] = "STREAM_READ";
    GLEnum2[GLEnum2["STREAM_COPY"] = 35042] = "STREAM_COPY";
    GLEnum2[GLEnum2["STATIC_READ"] = 35045] = "STATIC_READ";
    GLEnum2[GLEnum2["STATIC_COPY"] = 35046] = "STATIC_COPY";
    GLEnum2[GLEnum2["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
    GLEnum2[GLEnum2["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
    GLEnum2[GLEnum2["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    GLEnum2[GLEnum2["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
    GLEnum2[GLEnum2["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
    GLEnum2[GLEnum2["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
    GLEnum2[GLEnum2["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE";
    GLEnum2[GLEnum2["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
    GLEnum2[GLEnum2["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
    GLEnum2[GLEnum2["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
    GLEnum2[GLEnum2["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
    GLEnum2[GLEnum2["SRGB_EXT"] = 35904] = "SRGB_EXT";
    GLEnum2[GLEnum2["SRGB_ALPHA_EXT"] = 35906] = "SRGB_ALPHA_EXT";
    GLEnum2[GLEnum2["SRGB8_ALPHA8_EXT"] = 35907] = "SRGB8_ALPHA8_EXT";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT";
    GLEnum2[GLEnum2["R16_EXT"] = 33322] = "R16_EXT";
    GLEnum2[GLEnum2["RG16_EXT"] = 33324] = "RG16_EXT";
    GLEnum2[GLEnum2["RGB16_EXT"] = 32852] = "RGB16_EXT";
    GLEnum2[GLEnum2["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
    GLEnum2[GLEnum2["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
    GLEnum2[GLEnum2["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
    GLEnum2[GLEnum2["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
    GLEnum2[GLEnum2["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
    GLEnum2[GLEnum2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    GLEnum2[GLEnum2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    GLEnum2[GLEnum2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    GLEnum2[GLEnum2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    GLEnum2[GLEnum2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    GLEnum2[GLEnum2["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    GLEnum2[GLEnum2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    GLEnum2[GLEnum2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    GLEnum2[GLEnum2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
    GLEnum2[GLEnum2["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
    GLEnum2[GLEnum2["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
    GLEnum2[GLEnum2["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
    GLEnum2[GLEnum2["RGB32F_EXT"] = 34837] = "RGB32F_EXT";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
    GLEnum2[GLEnum2["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
    GLEnum2[GLEnum2["MIN_EXT"] = 32775] = "MIN_EXT";
    GLEnum2[GLEnum2["MAX_EXT"] = 32776] = "MAX_EXT";
    GLEnum2[GLEnum2["FRAGMENT_SHADER_DERIVATIVE_HINT_OES"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT_OES";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT0_WEBGL"] = 36064] = "COLOR_ATTACHMENT0_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT1_WEBGL"] = 36065] = "COLOR_ATTACHMENT1_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT2_WEBGL"] = 36066] = "COLOR_ATTACHMENT2_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT3_WEBGL"] = 36067] = "COLOR_ATTACHMENT3_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT4_WEBGL"] = 36068] = "COLOR_ATTACHMENT4_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT5_WEBGL"] = 36069] = "COLOR_ATTACHMENT5_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT6_WEBGL"] = 36070] = "COLOR_ATTACHMENT6_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT7_WEBGL"] = 36071] = "COLOR_ATTACHMENT7_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT8_WEBGL"] = 36072] = "COLOR_ATTACHMENT8_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT9_WEBGL"] = 36073] = "COLOR_ATTACHMENT9_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT10_WEBGL"] = 36074] = "COLOR_ATTACHMENT10_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT11_WEBGL"] = 36075] = "COLOR_ATTACHMENT11_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT12_WEBGL"] = 36076] = "COLOR_ATTACHMENT12_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT13_WEBGL"] = 36077] = "COLOR_ATTACHMENT13_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT14_WEBGL"] = 36078] = "COLOR_ATTACHMENT14_WEBGL";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT15_WEBGL"] = 36079] = "COLOR_ATTACHMENT15_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER0_WEBGL"] = 34853] = "DRAW_BUFFER0_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER1_WEBGL"] = 34854] = "DRAW_BUFFER1_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER2_WEBGL"] = 34855] = "DRAW_BUFFER2_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER3_WEBGL"] = 34856] = "DRAW_BUFFER3_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER4_WEBGL"] = 34857] = "DRAW_BUFFER4_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER5_WEBGL"] = 34858] = "DRAW_BUFFER5_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER6_WEBGL"] = 34859] = "DRAW_BUFFER6_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER7_WEBGL"] = 34860] = "DRAW_BUFFER7_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER8_WEBGL"] = 34861] = "DRAW_BUFFER8_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER9_WEBGL"] = 34862] = "DRAW_BUFFER9_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER10_WEBGL"] = 34863] = "DRAW_BUFFER10_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER11_WEBGL"] = 34864] = "DRAW_BUFFER11_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER12_WEBGL"] = 34865] = "DRAW_BUFFER12_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER13_WEBGL"] = 34866] = "DRAW_BUFFER13_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER14_WEBGL"] = 34867] = "DRAW_BUFFER14_WEBGL";
    GLEnum2[GLEnum2["DRAW_BUFFER15_WEBGL"] = 34868] = "DRAW_BUFFER15_WEBGL";
    GLEnum2[GLEnum2["MAX_COLOR_ATTACHMENTS_WEBGL"] = 36063] = "MAX_COLOR_ATTACHMENTS_WEBGL";
    GLEnum2[GLEnum2["MAX_DRAW_BUFFERS_WEBGL"] = 34852] = "MAX_DRAW_BUFFERS_WEBGL";
    GLEnum2[GLEnum2["VERTEX_ARRAY_BINDING_OES"] = 34229] = "VERTEX_ARRAY_BINDING_OES";
    GLEnum2[GLEnum2["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
    GLEnum2[GLEnum2["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
    GLEnum2[GLEnum2["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
    GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
    GLEnum2[GLEnum2["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
    GLEnum2[GLEnum2["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
    GLEnum2[GLEnum2["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
    return GLEnum2;
  }(GLEnum || {});

  // src/context/debug/webgl-developer-tools.ts
  var WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
  function getContextData2(gl) {
    gl.luma = gl.luma || {};
    return gl.luma;
  }
  async function loadWebGLDeveloperTools() {
    if (isBrowser() && !globalThis.WebGLDebugUtils) {
      globalThis.global = globalThis.global || globalThis;
      globalThis.global.module = {};
      await loadScript(WEBGL_DEBUG_CDN_URL);
    }
  }
  function makeDebugContext(gl, props = {}) {
    if (!gl) {
      return null;
    }
    return props.debug ? getDebugContext(gl, props) : getRealContext(gl);
  }
  function getRealContext(gl) {
    const data = getContextData2(gl);
    return data.realContext ? data.realContext : gl;
  }
  function getDebugContext(gl, props) {
    if (!globalThis.WebGLDebugUtils) {
      log.warn("webgl-debug not loaded")();
      return gl;
    }
    const data = getContextData2(gl);
    if (data.debugContext) {
      return data.debugContext;
    }
    globalThis.WebGLDebugUtils.init({
      ...GLEnum,
      ...gl
    });
    const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
    for (const key in GLEnum) {
      if (!(key in glDebug) && typeof GLEnum[key] === "number") {
        glDebug[key] = GLEnum[key];
      }
    }
    class WebGLDebugContext {
    }
    Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
    Object.setPrototypeOf(WebGLDebugContext, glDebug);
    const debugContext = Object.create(WebGLDebugContext);
    data.realContext = gl;
    data.debugContext = debugContext;
    debugContext.debug = true;
    return debugContext;
  }
  function getFunctionString(functionName, functionArgs) {
    functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
    let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
    args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
    return `gl.${functionName}(${args})`;
  }
  function onGLError(props, err, functionName, args) {
    args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
    const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
    const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
    const glName = props.webgl2 ? "gl2" : "gl1";
    const message2 = `${errorMessage} in ${glName}.${functionName}(${functionArgs})`;
    log.error(message2)();
    debugger;
    if (props.throwOnError) {
      throw new Error(message2);
    }
  }
  function onValidateGLFunc(props, functionName, functionArgs) {
    let functionString = "";
    if (log.level >= 1) {
      functionString = getFunctionString(functionName, functionArgs);
      log.log(1, functionString)();
    }
    if (props.break && props.break.length > 0) {
      functionString = functionString || getFunctionString(functionName, functionArgs);
      const isBreakpoint = props.break.every((breakOn) => functionString.indexOf(breakOn) !== -1);
      if (isBreakpoint) {
        debugger;
      }
    }
    for (const arg of functionArgs) {
      if (arg === void 0) {
        functionString = functionString || getFunctionString(functionName, functionArgs);
        if (props.throwOnError) {
          throw new Error(`Undefined argument: ${functionString}`);
        } else {
          log.error(`Undefined argument: ${functionString}`)();
          debugger;
        }
      }
    }
  }

  // src/adapter/helpers/parse-shader-compiler-log.ts
  function parseShaderCompilerLog(errLog) {
    const lines = errLog.split(/\r?\n/);
    const messages = [];
    for (const line of lines) {
      if (line.length <= 1) {
        continue;
      }
      const segments = line.split(":");
      if (segments.length === 2) {
        const [messageType2, message2] = segments;
        messages.push({
          message: message2.trim(),
          type: getMessageType(messageType2),
          lineNum: 0,
          linePos: 0
        });
        continue;
      }
      const [messageType, linePosition, lineNumber, ...rest] = segments;
      let lineNum = parseInt(lineNumber, 10);
      if (isNaN(lineNum)) {
        lineNum = 0;
      }
      let linePos = parseInt(linePosition, 10);
      if (isNaN(linePos)) {
        linePos = 0;
      }
      messages.push({
        message: rest.join(":").trim(),
        type: getMessageType(messageType),
        lineNum,
        linePos
      });
    }
    return messages;
  }
  function getMessageType(messageType) {
    const MESSAGE_TYPES = ["warning", "error", "info"];
    const lowerCaseType = messageType.toLowerCase();
    return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
  }

  // src/adapter/resources/webgl-shader.ts
  var WEBGLShader = class extends Shader {
    constructor(device, props) {
      super(device, props);
      this.device = device;
      switch (this.props.stage) {
        case "vertex":
          this.handle = this.props.handle || this.device.gl.createShader(35633);
          break;
        case "fragment":
          this.handle = this.props.handle || this.device.gl.createShader(35632);
          break;
        default:
          throw new Error(this.props.stage);
      }
      this._compile(this.source);
    }
    destroy() {
      if (this.handle) {
        this.removeStats();
        this.device.gl.deleteShader(this.handle);
        this.destroyed = true;
      }
    }
    async getCompilationInfo() {
      return this.getCompilationInfoSync();
    }
    getCompilationInfoSync() {
      const log3 = this.device.gl.getShaderInfoLog(this.handle);
      return parseShaderCompilerLog(log3);
    }
    _compile(source) {
      const addGLSLVersion = (source2) => source2.startsWith("#version ") ? source2 : `#version 100
${source2}`;
      source = addGLSLVersion(source);
      const {
        gl
      } = this.device;
      gl.shaderSource(this.handle, source);
      gl.compileShader(this.handle);
      this.compilationStatus = gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
      this.debugShader();
      if (this.compilationStatus === "error") {
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      }
    }
  };

  // src/adapter/resources/webgl-render-pass.ts
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var WEBGLRenderPass = class extends RenderPass {
    constructor(device, props) {
      super(device, props);
      this.device = device;
      pushContextState(this.device.gl);
      this.setParameters(this.props.parameters);
      this.clear();
    }
    end() {
      popContextState(this.device.gl);
      if (this.props.framebuffer) {
        setGLParameters(this.device, {
          framebuffer: null
        });
      }
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
    setParameters(parameters = {}) {
      const glParameters = {};
      if (this.props.framebuffer) {
        glParameters.framebuffer = this.props.framebuffer;
      }
      if (this.props.depthReadOnly) {
        glParameters.depthMask = !this.props.depthReadOnly;
      }
      glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
      glParameters[35977] = this.props.discard;
      if (parameters.viewport) {
        if (parameters.viewport.length >= 6) {
          glParameters.viewport = parameters.viewport.slice(0, 4);
          glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];
        } else {
          glParameters.viewport = parameters.viewport;
        }
      }
      glParameters.scissorTest = Boolean(parameters.scissorRect);
      if (parameters.scissorRect) {
        glParameters.scissor = parameters.scissorRect;
      }
      if (parameters.blendConstant) {
        glParameters.blendColor = parameters.blendConstant;
      }
      if (parameters.stencilReference) {
        console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
        parameters[2967] = parameters.stencilReference;
      }
      this.glParameters = glParameters;
      setGLParameters(this.device, glParameters);
    }
    clear() {
      const glParameters = {
        ...this.glParameters
      };
      let clearMask = 0;
      if (this.props.clearColor !== false) {
        clearMask |= GL_COLOR_BUFFER_BIT;
        glParameters.clearColor = this.props.clearColor;
      }
      if (this.props.clearDepth !== false) {
        clearMask |= GL_DEPTH_BUFFER_BIT;
        glParameters.clearDepth = this.props.clearDepth;
      }
      if (this.props.clearStencil !== false) {
        clearMask |= GL_STENCIL_BUFFER_BIT;
        glParameters.clearStencil = this.props.clearStencil;
      }
      if (clearMask !== 0) {
        withGLParameters(this.device, glParameters, () => {
          this.device.gl.clear(clearMask);
        });
      }
    }
    clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
      withGLParameters(this.device.gl2, {
        framebuffer: this.props.framebuffer
      }, () => {
        switch (value.constructor) {
          case Int32Array:
            this.device.gl2.clearBufferiv(GL_COLOR, drawBuffer, value);
            break;
          case Uint32Array:
            this.device.gl2.clearBufferuiv(GL_COLOR, drawBuffer, value);
            break;
          case Float32Array:
          default:
            this.device.gl2.clearBufferfv(GL_COLOR, drawBuffer, value);
            break;
        }
      });
    }
  };

  // src/classic/typed-array-utils.ts
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType, options) {
    const {
      clamped = true
    } = options || {};
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }

  // src/classic/accessor.ts
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = class {
    static getBytesPerElement(accessor) {
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
      assert2(accessor.size);
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve(...accessors) {
      return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
    }
    constructor(...accessors) {
      accessors.forEach((accessor) => this._assign(accessor));
      Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
      return Accessor.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return Accessor.getBytesPerVertex(this);
    }
    _assign(props = {}) {
      props = checkProps("Accessor", props, PROP_CHECKS);
      if (props.type !== void 0) {
        this.type = props.type;
        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }
      if (props.size !== void 0) {
        this.size = props.size;
      }
      if (props.offset !== void 0) {
        this.offset = props.offset;
      }
      if (props.stride !== void 0) {
        this.stride = props.stride;
      }
      if (props.normalize !== void 0) {
        this.normalized = props.normalize;
      }
      if (props.normalized !== void 0) {
        this.normalized = props.normalized;
      }
      if (props.integer !== void 0) {
        this.integer = props.integer;
      }
      if (props.divisor !== void 0) {
        this.divisor = props.divisor;
      }
      if (props.buffer !== void 0) {
        this.buffer = props.buffer;
      }
      if (props.index !== void 0) {
        if (typeof props.index === "boolean") {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }
      if (props.instanced !== void 0) {
        this.divisor = props.instanced ? 1 : 0;
      }
      if (props.isInstanced !== void 0) {
        this.divisor = props.isInstanced ? 1 : 0;
      }
      if (this.offset === void 0)
        delete this.offset;
      if (this.stride === void 0)
        delete this.stride;
      if (this.type === void 0)
        delete this.type;
      if (this.size === void 0)
        delete this.size;
      if (this.divisor === void 0)
        delete this.divisor;
      if (this.normalized === void 0)
        delete this.normalized;
      if (this.integer === void 0)
        delete this.integer;
      if (this.buffer === void 0)
        delete this.buffer;
      if (this.index === void 0)
        delete this.index;
      return this;
    }
  };

  // src/adapter/helpers/decode-webgl-types.ts
  function isSamplerUniform(type) {
    return SAMPLER_TYPES.includes(type);
  }
  var SAMPLER_TYPES = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311];
  var COMPOSITE_GL_TYPES = {
    [5126]: [5126, 1, "float", "f32", "float32"],
    [35664]: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
    [35665]: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
    [35666]: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
    [5124]: [5124, 1, "int", "i32", "sint32"],
    [35667]: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
    [35668]: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
    [35669]: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
    [5125]: [5125, 1, "uint", "u32", "uint32"],
    [36294]: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
    [36295]: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
    [36296]: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
    [35670]: [5126, 1, "bool", "f32", "float32"],
    [35671]: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
    [35672]: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
    [35673]: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
    [35674]: [5126, 8, "mat2", "mat2x2<f32>"],
    [35685]: [5126, 8, "mat2x3", "mat2x3<f32>"],
    [35686]: [5126, 8, "mat2x4", "mat2x4<f32>"],
    [35687]: [5126, 12, "mat3x2", "mat3x2<f32>"],
    [35675]: [5126, 12, "mat3", "mat3x3<f32>"],
    [35688]: [5126, 12, "mat3x4", "mat3x4<f32>"],
    [35689]: [5126, 16, "mat4x2", "mat4x2<f32>"],
    [35690]: [5126, 16, "mat4x3", "mat4x3<f32>"],
    [35676]: [5126, 16, "mat4", "mat4x4<f32>"]
  };
  function decodeGLUniformType(glUniformType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];
    if (!typeAndSize) {
      throw new Error("uniform");
    }
    const [glType, components, , format] = typeAndSize;
    return {
      format,
      components,
      glType
    };
  }
  function decodeGLAttributeType(glAttributeType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];
    if (!typeAndSize) {
      throw new Error("attribute");
    }
    const [, components, , shaderType, vertexFormat] = typeAndSize;
    const attributeType = shaderType;
    return {
      attributeType,
      vertexFormat,
      components
    };
  }

  // src/adapter/helpers/get-shader-layout.ts
  function getShaderLayout(gl, program) {
    const shaderLayout = {
      attributes: [],
      bindings: []
    };
    shaderLayout.attributes = readAttributeDeclarations(gl, program);
    const uniformBlocks = readUniformBlocks(gl, program);
    for (const uniformBlock of uniformBlocks) {
      const uniforms2 = uniformBlock.uniforms.map((uniform) => ({
        name: uniform.name,
        format: uniform.format,
        byteOffset: uniform.byteOffset,
        byteStride: uniform.byteStride,
        arrayLength: uniform.arrayLength
      }));
      shaderLayout.bindings.push({
        type: "uniform",
        name: uniformBlock.name,
        location: uniformBlock.location,
        visibility: (uniformBlock.vertex ? 1 : 0) & (uniformBlock.fragment ? 2 : 0),
        minBindingSize: uniformBlock.byteLength,
        uniforms: uniforms2
      });
    }
    const uniforms = readUniformBindings(gl, program);
    let textureUnit = 0;
    for (const uniform of uniforms) {
      if (isSamplerUniform(uniform.type)) {
        const {
          viewDimension,
          sampleType
        } = getSamplerInfo(uniform.type);
        shaderLayout.bindings.push({
          type: "texture",
          name: uniform.name,
          location: textureUnit,
          viewDimension,
          sampleType
        });
        uniform.textureUnit = textureUnit;
        textureUnit += 1;
      }
    }
    if (uniforms.length) {
      shaderLayout.uniforms = uniforms;
    }
    const varyings = readVaryings(gl, program);
    if (varyings?.length) {
      shaderLayout.varyings = varyings;
    }
    return shaderLayout;
  }
  function readAttributeDeclarations(gl, program) {
    const attributes = [];
    const count = gl.getProgramParameter(program, 35721);
    for (let index = 0; index < count; index++) {
      const activeInfo = gl.getActiveAttrib(program, index);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const {
        name: name2,
        type: compositeType
      } = activeInfo;
      const location = gl.getAttribLocation(program, name2);
      if (location >= 0) {
        const {
          attributeType
        } = decodeGLAttributeType(compositeType);
        const stepMode = /instance/i.test(name2) ? "instance" : "vertex";
        attributes.push({
          name: name2,
          location,
          stepMode,
          type: attributeType
        });
      }
    }
    attributes.sort((a, b) => a.location - b.location);
    return attributes;
  }
  function readVaryings(gl, program) {
    if (!isWebGL2(gl)) {
      return [];
    }
    const gl2 = gl;
    const varyings = [];
    const count = gl.getProgramParameter(program, 35971);
    for (let location = 0; location < count; location++) {
      const activeInfo = gl2.getTransformFeedbackVarying(program, location);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const {
        name: name2,
        type: compositeType,
        size
      } = activeInfo;
      const {
        glType,
        components
      } = decodeGLUniformType(compositeType);
      const accessor = new Accessor({
        type: glType,
        size: size * components
      });
      const varying = {
        location,
        name: name2,
        accessor
      };
      varyings.push(varying);
    }
    varyings.sort((a, b) => a.location - b.location);
    return varyings;
  }
  function readUniformBindings(gl, program) {
    const uniforms = [];
    const uniformCount = gl.getProgramParameter(program, 35718);
    for (let i = 0; i < uniformCount; i++) {
      const activeInfo = gl.getActiveUniform(program, i);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const {
        name: rawName,
        size,
        type
      } = activeInfo;
      const {
        name: name2,
        isArray: isArray2
      } = parseUniformName(rawName);
      let webglLocation = gl.getUniformLocation(program, name2);
      const uniformInfo = {
        location: webglLocation,
        name: name2,
        size,
        type,
        isArray: isArray2
      };
      uniforms.push(uniformInfo);
      if (uniformInfo.size > 1) {
        for (let j = 0; j < uniformInfo.size; j++) {
          const elementName = `${name2}[${j}]`;
          webglLocation = gl.getUniformLocation(program, elementName);
          const arrayElementUniformInfo = {
            ...uniformInfo,
            name: elementName,
            location: webglLocation
          };
          uniforms.push(arrayElementUniformInfo);
        }
      }
    }
    return uniforms;
  }
  function readUniformBlocks(gl, program) {
    if (!isWebGL2(gl)) {
      return [];
    }
    const gl2 = gl;
    const getBlockParameter = (blockIndex, pname) => gl2.getActiveUniformBlockParameter(program, blockIndex, pname);
    const uniformBlocks = [];
    const blockCount = gl2.getProgramParameter(program, 35382);
    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
      const blockInfo = {
        name: gl2.getActiveUniformBlockName(program, blockIndex) || "",
        location: getBlockParameter(blockIndex, 35391),
        byteLength: getBlockParameter(blockIndex, 35392),
        vertex: getBlockParameter(blockIndex, 35396),
        fragment: getBlockParameter(blockIndex, 35398),
        uniformCount: getBlockParameter(blockIndex, 35394),
        uniforms: []
      };
      const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
      const uniformType = gl2.getActiveUniforms(program, uniformIndices, 35383);
      const uniformArrayLength = gl2.getActiveUniforms(program, uniformIndices, 35384);
      const uniformOffset = gl2.getActiveUniforms(program, uniformIndices, 35387);
      const uniformStride = gl2.getActiveUniforms(program, uniformIndices, 35388);
      for (let i = 0; i < blockInfo.uniformCount; ++i) {
        const activeInfo = gl2.getActiveUniform(program, uniformIndices[i]);
        if (!activeInfo) {
          throw new Error("activeInfo");
        }
        blockInfo.uniforms.push({
          name: activeInfo.name,
          format: decodeGLUniformType(uniformType[i]).format,
          type: uniformType[i],
          arrayLength: uniformArrayLength[i],
          byteOffset: uniformOffset[i],
          byteStride: uniformStride[i]
        });
      }
      uniformBlocks.push(blockInfo);
    }
    uniformBlocks.sort((a, b) => a.location - b.location);
    return uniformBlocks;
  }
  var SAMPLER_UNIFORMS_GL_TO_GPU = {
    [35678]: ["2d", "float"],
    [35680]: ["cube", "float"],
    [35679]: ["3d", "float"],
    [35682]: ["3d", "depth"],
    [36289]: ["2d-array", "float"],
    [36292]: ["2d-array", "depth"],
    [36293]: ["cube", "float"],
    [36298]: ["2d", "sint"],
    [36299]: ["3d", "sint"],
    [36300]: ["cube", "sint"],
    [36303]: ["2d-array", "uint"],
    [36306]: ["2d", "uint"],
    [36307]: ["3d", "uint"],
    [36308]: ["cube", "uint"],
    [36311]: ["2d-array", "uint"]
  };
  function getSamplerInfo(type) {
    const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
    if (!sampler) {
      throw new Error("sampler");
    }
    const [viewDimension, sampleType] = sampler;
    return {
      viewDimension,
      sampleType
    };
  }
  function parseUniformName(name2) {
    if (name2[name2.length - 1] !== "]") {
      return {
        name: name2,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches = UNIFORM_NAME_REGEXP.exec(name2);
    if (!matches || matches.length < 2) {
      throw new Error(`Failed to parse GLSL uniform name ${name2}`);
    }
    return {
      name: matches[1],
      length: matches[2] ? 1 : 0,
      isArray: Boolean(matches[2])
    };
  }

  // src/adapter/helpers/set-uniform.ts
  function setUniform(gl, location, type, value) {
    const gl2 = gl;
    let uniformValue = value;
    if (uniformValue === true) {
      uniformValue = 1;
    }
    if (uniformValue === false) {
      uniformValue = 0;
    }
    const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
    switch (type) {
      case 35678:
      case 35680:
      case 35679:
      case 35682:
      case 36289:
      case 36292:
      case 36293:
      case 36298:
      case 36299:
      case 36300:
      case 36303:
      case 36306:
      case 36307:
      case 36308:
      case 36311:
        if (typeof value !== "number") {
          throw new Error("samplers must be set to integers");
        }
        return gl.uniform1i(location, value);
      case 5126:
        return gl.uniform1fv(location, arrayValue);
      case 35664:
        return gl.uniform2fv(location, arrayValue);
      case 35665:
        return gl.uniform3fv(location, arrayValue);
      case 35666:
        return gl.uniform4fv(location, arrayValue);
      case 5124:
        return gl.uniform1iv(location, arrayValue);
      case 35667:
        return gl.uniform2iv(location, arrayValue);
      case 35668:
        return gl.uniform3iv(location, arrayValue);
      case 35669:
        return gl.uniform4iv(location, arrayValue);
      case 35670:
        return gl.uniform1iv(location, arrayValue);
      case 35671:
        return gl.uniform2iv(location, arrayValue);
      case 35672:
        return gl.uniform3iv(location, arrayValue);
      case 35673:
        return gl.uniform4iv(location, arrayValue);
      case 5125:
        return gl2.uniform1uiv(location, arrayValue, 1);
      case 36294:
        return gl2.uniform2uiv(location, arrayValue, 2);
      case 36295:
        return gl2.uniform3uiv(location, arrayValue, 3);
      case 36296:
        return gl2.uniform4uiv(location, arrayValue, 4);
      case 35674:
        return gl.uniformMatrix2fv(location, false, arrayValue);
      case 35675:
        return gl.uniformMatrix3fv(location, false, arrayValue);
      case 35676:
        return gl.uniformMatrix4fv(location, false, arrayValue);
      case 35685:
        return gl2.uniformMatrix2x3fv(location, false, arrayValue);
      case 35686:
        return gl2.uniformMatrix2x4fv(location, false, arrayValue);
      case 35687:
        return gl2.uniformMatrix3x2fv(location, false, arrayValue);
      case 35688:
        return gl2.uniformMatrix3x4fv(location, false, arrayValue);
      case 35689:
        return gl2.uniformMatrix4x2fv(location, false, arrayValue);
      case 35690:
        return gl2.uniformMatrix4x3fv(location, false, arrayValue);
    }
    throw new Error("Illegal uniform");
  }

  // src/adapter/helpers/webgl-topology-utils.ts
  function getGLDrawMode(topology) {
    switch (topology) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 3;
      case "line-loop-webgl":
        return 2;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 5;
      case "triangle-fan-webgl":
        return 6;
      default:
        throw new Error(topology);
    }
  }
  function getGLPrimitive(topology) {
    switch (topology) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 1;
      case "line-loop-webgl":
        return 1;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 4;
      case "triangle-fan-webgl":
        return 4;
      default:
        throw new Error(topology);
    }
  }

  // src/adapter/resources/webgl-render-pipeline.ts
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var WEBGLRenderPipeline = class extends RenderPipeline {
    uniforms = {};
    bindings = {};
    varyings = null;
    _uniformCount = 0;
    _uniformSetters = {};
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.handle = this.props.handle || this.device.gl.createProgram();
      this.device.setSpectorMetadata(this.handle, {
        id: this.props.id
      });
      this.vs = cast(props.vs);
      this.fs = cast(props.fs);
      const {
        varyings,
        bufferMode = 35981
      } = props;
      if (varyings && varyings.length > 0) {
        this.device.assertWebGL2();
        this.varyings = varyings;
        this.device.gl2?.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }
      this._compileAndLink();
      this.introspectedLayout = getShaderLayout(this.device.gl, this.handle);
      this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);
      switch (this.props.topology) {
        case "triangle-fan-webgl":
        case "line-loop-webgl":
          log.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
          break;
        default:
      }
    }
    destroy() {
      if (this.handle) {
        this.device.gl.deleteProgram(this.handle);
        this.destroyed = true;
      }
    }
    setBindings(bindings) {
      for (const [name2, value] of Object.entries(bindings)) {
        const binding = this.shaderLayout.bindings.find((binding2) => binding2.name === name2) || this.shaderLayout.bindings.find((binding2) => binding2.name === `${name2}Uniforms`);
        if (!binding) {
          const validBindings = this.shaderLayout.bindings.map((binding2) => `"${binding2.name}"`).join(", ");
          log.warn(`Unknown binding "${name2}" in render pipeline "${this.id}", expected one of ${validBindings}`)();
          continue;
        }
        if (!value) {
          log.warn(`Unsetting binding "${name2}" in render pipeline "${this.id}"`)();
        }
        switch (binding.type) {
          case "uniform":
            if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
              throw new Error("buffer value");
            }
            break;
          case "texture":
            if (!(value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
              throw new Error("texture value");
            }
            break;
          case "sampler":
            log.warn(`Ignoring sampler ${name2}`)();
            break;
          default:
            throw new Error(binding.type);
        }
        this.bindings[name2] = value;
      }
    }
    setUniforms(uniforms) {
      const {
        bindings
      } = splitUniformsAndBindings(uniforms);
      Object.keys(bindings).forEach((name2) => {
        log.warn(`Unsupported value "${JSON.stringify(bindings[name2])}" used in setUniforms() for key ${name2}. Use setBindings() instead?`)();
      });
      Object.assign(this.uniforms, uniforms);
    }
    draw(options) {
      const {
        renderPass,
        vertexArray,
        vertexCount,
        instanceCount,
        firstVertex = 0,
        transformFeedback
      } = options;
      const glDrawMode = getGLDrawMode(this.props.topology);
      const isIndexed = Boolean(vertexArray.indexBuffer);
      const glIndexType = vertexArray.indexBuffer?.glIndexType;
      const isInstanced = Number(instanceCount) > 0;
      if (!this._areTexturesRenderable() || vertexCount === 0) {
        return false;
      }
      this.device.gl.useProgram(this.handle);
      vertexArray.bindBeforeRender(renderPass);
      if (transformFeedback) {
        transformFeedback.begin(this.props.topology);
      }
      this._applyBindings();
      this._applyUniforms();
      const webglRenderPass = renderPass;
      withDeviceAndGLParameters(this.device, this.props.parameters, webglRenderPass.glParameters, () => {
        if (isIndexed && isInstanced) {
          this.device.gl2?.drawElementsInstanced(glDrawMode, vertexCount || 0, glIndexType, firstVertex, instanceCount || 0);
        } else if (isIndexed) {
          this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
        } else if (isInstanced) {
          this.device.gl2?.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
        } else {
          this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
        }
        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      vertexArray.unbindAfterRender(renderPass);
      return true;
    }
    _compileAndLink() {
      const {
        gl
      } = this.device;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
      gl.linkProgram(this.handle);
      log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
      if (!gl.debug && log.level === 0) {
      }
      const linked = gl.getProgramParameter(this.handle, 35714);
      if (!linked) {
        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);
      }
      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, 35715);
      if (!validated) {
        throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);
      }
    }
    _areTexturesRenderable() {
      let texturesRenderable = true;
      for (const [, texture] of Object.entries(this.bindings)) {
        if (texture instanceof WEBGLTexture) {
          texture.update();
          texturesRenderable = texturesRenderable && texture.loaded;
        }
      }
      return texturesRenderable;
    }
    _applyBindings() {
      this.device.gl.useProgram(this.handle);
      const {
        gl2
      } = this.device;
      if (!gl2) {
        throw new Error("bindings");
      }
      let textureUnit = 0;
      let uniformBufferIndex = 0;
      for (const binding of this.shaderLayout.bindings) {
        const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
        if (!value) {
          throw new Error(`No value for binding ${binding.name} in ${this.id}`);
        }
        switch (binding.type) {
          case "uniform":
            const {
              name: name2
            } = binding;
            const location = gl2.getUniformBlockIndex(this.handle, name2);
            if (location === 4294967295) {
              throw new Error(`Invalid uniform block name ${name2}`);
            }
            gl2.uniformBlockBinding(this.handle, uniformBufferIndex, location);
            if (value instanceof WEBGLBuffer) {
              gl2.bindBufferBase(35345, uniformBufferIndex, value.handle);
            } else {
              gl2.bindBufferRange(35345, uniformBufferIndex, value.buffer.handle, value.offset || 0, value.size || value.buffer.byteLength - value.offset);
            }
            uniformBufferIndex += 1;
            break;
          case "texture":
            if (!(value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
              throw new Error("texture");
            }
            let texture;
            if (value instanceof WEBGLTexture) {
              texture = value;
            } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTexture) {
              log.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")();
              texture = value.colorAttachments[0];
            } else {
              throw new Error("No texture");
            }
            gl2.activeTexture(33984 + textureUnit);
            gl2.bindTexture(texture.target, texture.handle);
            textureUnit += 1;
            break;
          case "sampler":
            break;
          case "storage":
          case "read-only-storage":
            throw new Error(`binding type '${binding.type}' not supported in WebGL`);
        }
      }
    }
    _applyUniforms() {
      for (const uniformLayout of this.shaderLayout.uniforms || []) {
        const {
          name: name2,
          location,
          type,
          textureUnit
        } = uniformLayout;
        const value = this.uniforms[name2] ?? textureUnit;
        if (value !== void 0) {
          setUniform(this.device.gl, location, type, value);
        }
      }
    }
  };

  // src/adapter/resources/webgl-command-buffer.ts
  function cast2(value) {
    return value;
  }
  var WEBGLCommandBuffer = class extends CommandBuffer {
    commands = [];
    constructor(device) {
      super(device, {});
      this.device = device;
    }
    submitCommands(commands = this.commands) {
      for (const command of commands) {
        switch (command.name) {
          case "copy-buffer-to-buffer":
            _copyBufferToBuffer(this.device, command.options);
            break;
          case "copy-buffer-to-texture":
            _copyBufferToTexture(this.device, command.options);
            break;
          case "copy-texture-to-buffer":
            _copyTextureToBuffer(this.device, command.options);
            break;
          case "copy-texture-to-texture":
            _copyTextureToTexture(this.device, command.options);
            break;
        }
      }
    }
  };
  function _copyBufferToBuffer(device, options) {
    const source = cast2(options.source);
    const destination = cast2(options.destination);
    const gl2 = device.assertWebGL2();
    if (gl2) {
      gl2.bindBuffer(36662, source.handle);
      gl2.bindBuffer(36663, destination.handle);
      gl2.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);
      gl2.bindBuffer(36662, null);
      gl2.bindBuffer(36663, null);
    } else {
      throw new Error("copyBufferToBuffer not implemented in WebGL1");
    }
  }
  function _copyBufferToTexture(device, options) {
    throw new Error("Not implemented");
  }
  function _copyTextureToBuffer(device, options) {
    const {
      source,
      mipLevel = 0,
      aspect = "all",
      width = options.source.width,
      height = options.source.height,
      depthOrArrayLayers = 0,
      origin = [0, 0],
      destination,
      byteOffset = 0,
      bytesPerRow,
      rowsPerImage
    } = options;
    if (aspect !== "all") {
      throw new Error("not supported");
    }
    if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
      throw new Error("not implemented");
    }
    const gl2 = device.assertWebGL2();
    const {
      framebuffer,
      destroyFramebuffer
    } = getFramebuffer(source);
    try {
      const webglBuffer = destination;
      const sourceWidth = width || framebuffer.width;
      const sourceHeight = height || framebuffer.height;
      const sourceParams = getWebGLTextureParameters(framebuffer.texture.format, true);
      const sourceFormat = sourceParams.dataFormat;
      const sourceType = sourceParams.type;
      gl2.bindBuffer(35051, webglBuffer.handle);
      gl2.bindFramebuffer(36160, framebuffer.handle);
      gl2.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
    } finally {
      gl2.bindBuffer(35051, null);
      gl2.bindFramebuffer(36160, null);
      if (destroyFramebuffer) {
        framebuffer.destroy();
      }
    }
  }
  function _copyTextureToTexture(device, options) {
    const {
      source,
      origin = [0, 0],
      destination
    } = options;
    let {
      width = options.destination.width,
      height = options.destination.width
    } = options;
    const destinationMipmaplevel = 0;
    const destinationInternalFormat = 6408;
    const {
      framebuffer,
      destroyFramebuffer
    } = getFramebuffer(source);
    const [sourceX, sourceY] = origin;
    const isSubCopy = false;
    device.gl.bindFramebuffer(36160, framebuffer.handle);
    let texture = null;
    let textureTarget;
    if (destination instanceof WEBGLTexture) {
      texture = destination;
      width = Number.isFinite(width) ? width : texture.width;
      height = Number.isFinite(height) ? height : texture.height;
      texture.bind(0);
      textureTarget = texture.destination;
    } else {
      throw new Error("whoops");
    }
    if (!isSubCopy) {
      device.gl.copyTexImage2D(textureTarget, destinationMipmaplevel, destinationInternalFormat, sourceX, sourceY, width, height, 0);
    } else {
    }
    if (texture) {
      texture.unbind();
    }
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
    return texture;
  }
  function getFramebuffer(source) {
    if (source instanceof Texture) {
      const {
        width,
        height,
        id
      } = source;
      const framebuffer = source.device.createFramebuffer({
        id: `framebuffer-for-${id}`,
        width,
        height,
        colorAttachments: [source]
      });
      return {
        framebuffer,
        destroyFramebuffer: true
      };
    }
    return {
      framebuffer: source,
      destroyFramebuffer: false
    };
  }

  // src/adapter/resources/webgl-command-encoder.ts
  var WEBGLCommandEncoder = class extends CommandEncoder {
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.commandBuffer = new WEBGLCommandBuffer(device);
    }
    destroy() {
    }
    finish() {
      this.commandBuffer.submitCommands();
    }
    copyBufferToBuffer(options) {
      this.commandBuffer.commands.push({
        name: "copy-buffer-to-buffer",
        options
      });
    }
    copyBufferToTexture(options) {
      this.commandBuffer.commands.push({
        name: "copy-buffer-to-texture",
        options
      });
    }
    copyTextureToBuffer(options) {
      this.commandBuffer.commands.push({
        name: "copy-texture-to-buffer",
        options
      });
    }
    copyTextureToTexture(options) {
      this.commandBuffer.commands.push({
        name: "copy-texture-to-texture",
        options
      });
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
  };

  // src/adapter/resources/webgl-vertex-array.ts
  var WEBGLVertexArray = class extends VertexArray {
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    buffer = null;
    bufferValue = null;
    static isConstantAttributeZeroSupported(device) {
      return device.info.type === "webgl2" || getBrowser() === "Chrome";
    }
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.handle = this.device.gl2.createVertexArray();
    }
    destroy() {
      super.destroy();
      if (this.buffer) {
        this.buffer?.destroy();
      }
      if (this.handle) {
        this.device.gl2.deleteVertexArray(this.handle);
        this.handle = void 0;
      }
    }
    setIndexBuffer(indexBuffer) {
      const buffer = indexBuffer;
      if (buffer && buffer.glTarget !== 34963) {
        throw new Error("Use .setBuffer()");
      }
      this.device.gl2.bindVertexArray(this.handle);
      this.device.gl2.bindBuffer(34963, buffer ? buffer.handle : null);
      this.indexBuffer = buffer;
    }
    setBuffer(location, attributeBuffer) {
      const buffer = attributeBuffer;
      if (buffer.glTarget === 34963) {
        throw new Error("Use .setIndexBuffer()");
      }
      const {
        size,
        type,
        stride,
        offset,
        normalized,
        integer,
        divisor
      } = this._getAccessor(location);
      this.device.gl2.bindVertexArray(this.handle);
      this.device.gl.bindBuffer(34962, buffer.handle);
      if (integer) {
        this.device.assertWebGL2();
        this.device.gl2.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
      this.device.gl.enableVertexAttribArray(location);
      this.device.gl2.vertexAttribDivisor(location, divisor || 0);
      this.attributes[location] = buffer;
    }
    setConstant(location, value) {
      this._enable(location, false);
      this.attributes[location] = value;
    }
    init = false;
    bindBeforeRender() {
      this.device.gl2.bindVertexArray(this.handle);
      if (!this.init) {
        const webglBuffer = this.indexBuffer;
        this.device.gl2.bindBuffer(34963, webglBuffer?.handle || null);
        this.init = true;
      }
      this._applyConstantAttributes();
    }
    unbindAfterRender() {
      this.device.gl2.bindVertexArray(null);
    }
    _applyConstantAttributes() {
      for (let location = 0; location < this.maxVertexAttributes; ++location) {
        const constant = this.attributes[location];
        if (ArrayBuffer.isView(constant)) {
          this.device.setConstantAttribute(location, constant);
        }
      }
    }
    _getAccessor(location) {
      const attributeInfo = this.attributeInfos[location];
      if (!attributeInfo) {
        throw new Error(`Unknown attribute location ${location}`);
      }
      const glType = getGLFromVertexType(attributeInfo.bufferDataType);
      return {
        size: attributeInfo.bufferComponents,
        type: glType,
        stride: attributeInfo.byteStride,
        offset: attributeInfo.byteOffset,
        normalized: attributeInfo.normalized,
        integer: attributeInfo.integer,
        divisor: attributeInfo.stepMode === "instance" ? 1 : 0
      };
    }
    _enable(location, enable2 = true) {
      const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
      const canDisableAttribute = canDisableAttributeZero || location !== 0;
      if (enable2 || canDisableAttribute) {
        location = Number(location);
        this.device.gl2.bindVertexArray(this.handle);
        if (enable2) {
          this.device.gl.enableVertexAttribArray(location);
        } else {
          this.device.gl.disableVertexAttribArray(location);
        }
        this.device.gl2.bindVertexArray(null);
      }
    }
    getConstantBuffer(elementCount, value) {
      const constantValue = normalizeConstantArrayValue(value);
      const byteLength = constantValue.byteLength * elementCount;
      const length = constantValue.length * elementCount;
      if (this.buffer && byteLength !== this.buffer.byteLength) {
        throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
      }
      let updateNeeded = !this.buffer;
      this.buffer = this.buffer || this.device.createBuffer({
        byteLength
      });
      updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);
      if (updateNeeded) {
        const typedArray = getScratchArray(value.constructor, length);
        fillArray({
          target: typedArray,
          source: constantValue,
          start: 0,
          count: length
        });
        this.buffer.write(typedArray);
        this.bufferValue = value;
      }
      return this.buffer;
    }
  };
  function normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }
  function compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }

  // src/adapter/resources/webgl-transform-feedback.ts
  var WEBGLTransformFeedback = class extends TransformFeedback {
    buffers = {};
    unusedBuffers = {};
    bindOnUse = true;
    _bound = false;
    constructor(device, props) {
      super(device, props);
      device.assertWebGL2();
      this.device = device;
      this.gl2 = device.gl2;
      this.handle = this.props.handle || this.gl2.createTransformFeedback();
      this.layout = this.props.layout;
      if (props.buffers) {
        this.setBuffers(props.buffers);
      }
      Object.seal(this);
    }
    destroy() {
      this.gl2.deleteTransformFeedback(this.handle);
      super.destroy();
    }
    begin(topology = "point-list") {
      this.gl2.bindTransformFeedback(36386, this.handle);
      if (this.bindOnUse) {
        this._bindBuffers();
      }
      this.gl2.beginTransformFeedback(getGLPrimitive(topology));
    }
    end() {
      this.gl2.endTransformFeedback();
      if (!this.bindOnUse) {
        this._unbindBuffers();
      }
      this.gl2.bindTransformFeedback(36386, null);
    }
    setBuffers(buffers) {
      this.buffers = {};
      this.unusedBuffers = {};
      this.bind(() => {
        for (const bufferName in buffers) {
          this.setBuffer(bufferName, buffers[bufferName]);
        }
      });
    }
    setBuffer(locationOrName, bufferOrRange) {
      const location = this._getVaryingIndex(locationOrName);
      const {
        buffer,
        byteLength,
        byteOffset
      } = this._getBufferRange(bufferOrRange);
      if (location < 0) {
        this.unusedBuffers[locationOrName] = buffer;
        log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
        return;
      }
      this.buffers[location] = {
        buffer,
        byteLength,
        byteOffset
      };
      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteLength);
      }
    }
    getBuffer(locationOrName) {
      if (isIndex(locationOrName)) {
        return this.buffers[locationOrName] || null;
      }
      const location = this._getVaryingIndex(locationOrName);
      return location >= 0 ? this.buffers[location] : null;
    }
    bind(funcOrHandle = this.handle) {
      if (typeof funcOrHandle !== "function") {
        this.gl2.bindTransformFeedback(36386, funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this.gl2.bindTransformFeedback(36386, this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this.gl2.bindTransformFeedback(36386, null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    _getBufferRange(bufferOrRange) {
      if (bufferOrRange instanceof WEBGLBuffer) {
        return {
          buffer: bufferOrRange,
          byteOffset: 0,
          byteLength: bufferOrRange.byteLength
        };
      }
      const {
        buffer,
        byteOffset = 0,
        byteLength = bufferOrRange.buffer.byteLength
      } = bufferOrRange;
      return {
        buffer,
        byteOffset,
        byteLength
      };
    }
    _getVaryingIndex(locationOrName) {
      if (isIndex(locationOrName)) {
        return Number(locationOrName);
      }
      for (const varying of this.layout.varyings) {
        if (locationOrName === varying.name) {
          return varying.location;
        }
      }
      return -1;
    }
    _bindBuffers() {
      for (const bufferIndex in this.buffers) {
        const {
          buffer,
          byteLength,
          byteOffset
        } = this._getBufferRange(this.buffers[bufferIndex]);
        this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
      }
    }
    _unbindBuffers() {
      for (const bufferIndex in this.buffers) {
        this.gl2.bindBufferBase(35982, Number(bufferIndex), null);
      }
    }
    _bindBuffer(index, buffer, byteOffset = 0, byteLength) {
      const handle = buffer && buffer.handle;
      if (!handle || byteLength === void 0) {
        this.gl2.bindBufferBase(35982, index, handle);
      } else {
        this.gl2.bindBufferRange(35982, index, handle, byteOffset, byteLength);
      }
    }
  };
  function isIndex(value) {
    if (typeof value === "number") {
      return Number.isInteger(value);
    }
    return /^\d+$/.test(value);
  }

  // src/classic/format-utils.ts
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        assert2(false);
        return 0;
    }
  }
  function glTypeToBytes(type) {
    switch (type) {
      case 5121:
        return 1;
      case 33635:
      case 32819:
      case 32820:
        return 2;
      case 5126:
        return 4;
      default:
        assert2(false);
        return 0;
    }
  }

  // src/classic/copy-and-blit.ts
  function readPixelsToArray(source, options) {
    const {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408,
      sourceAttachment = 36064
    } = options || {};
    let {
      target = null,
      sourceWidth,
      sourceHeight,
      sourceType
    } = options || {};
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer2(source);
    assert2(framebuffer);
    const {
      gl,
      handle
    } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const attachment = sourceAttachment - 36064;
    sourceType = sourceType || framebuffer.colorAttachments[attachment]?.type || 5121;
    target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return target;
  }
  function readPixelsToBuffer(source, options) {
    const {
      target,
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408,
      targetByteOffset = 0
    } = options || {};
    let {
      sourceWidth,
      sourceHeight,
      sourceType
    } = options || {};
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer2(source);
    assert2(framebuffer);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const webglFramebuffer = framebuffer;
    sourceType = sourceType || 5121;
    let webglBufferTarget = target;
    if (!webglBufferTarget) {
      const components = glFormatToComponents(sourceFormat);
      const byteCount = glTypeToBytes(sourceType);
      const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
      webglBufferTarget = webglFramebuffer.device.createBuffer({
        byteLength
      });
    }
    const commandEncoder = source.device.createCommandEncoder();
    commandEncoder.copyTextureToBuffer({
      source,
      width: sourceWidth,
      height: sourceHeight,
      origin: [sourceX, sourceY],
      destination: webglBufferTarget,
      byteOffset: targetByteOffset
    });
    commandEncoder.destroy();
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return webglBufferTarget;
  }
  function getFramebuffer2(source) {
    if (!(source instanceof Framebuffer)) {
      return {
        framebuffer: toFramebuffer(source),
        deleteFramebuffer: true
      };
    }
    return {
      framebuffer: source,
      deleteFramebuffer: false
    };
  }
  function toFramebuffer(texture, props) {
    const {
      device,
      width,
      height,
      id
    } = texture;
    const framebuffer = device.createFramebuffer({
      ...props,
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [texture]
    });
    return framebuffer;
  }
  function getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121;
    const ArrayType = getTypedArrayFromGLType(type, {
      clamped: false
    });
    const components = glFormatToComponents(format);
    return new ArrayType(width * height * components);
  }

  // src/classic/clear.ts
  var GL_DEPTH_BUFFER_BIT2 = 256;
  var GL_STENCIL_BUFFER_BIT2 = 1024;
  var GL_COLOR_BUFFER_BIT2 = 16384;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(gl, options) {
    const device = WebGLDevice.attach(gl);
    const {
      framebuffer = null,
      color = null,
      depth = null,
      stencil = null
    } = options || {};
    const parameters = {};
    if (framebuffer) {
      parameters.framebuffer = framebuffer;
    }
    let clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT2;
      if (color !== true) {
        parameters.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT2;
      if (depth !== true) {
        parameters.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT2;
      if (depth !== true) {
        parameters.clearStencil = depth;
      }
    }
    assert2(clearFlags !== 0, ERR_ARGUMENTS);
    withGLParameters(device.gl, parameters, () => {
      device.gl.clear(clearFlags);
    });
  }

  // src/adapter/webgl-device.ts
  var LOG_LEVEL2 = 1;
  var _WebGLDevice = class extends Device {
    static isSupported() {
      return typeof WebGLRenderingContext !== "undefined" || isHeadlessGLRegistered();
    }
    get features() {
      this._features = this._features || getDeviceFeatures(this.gl);
      return this._features;
    }
    get limits() {
      this._limits = this._limits || getDeviceLimits(this.gl);
      return this._limits;
    }
    static attach(gl) {
      if (gl instanceof _WebGLDevice) {
        return gl;
      }
      if (gl?.device instanceof Device) {
        return gl.device;
      }
      if (!isWebGL3(gl)) {
        throw new Error("Invalid WebGLRenderingContext");
      }
      return new _WebGLDevice({
        gl
      });
    }
    static async create(props = {}) {
      log.groupCollapsed(LOG_LEVEL2, "WebGLDevice created")();
      if (typeof props.canvas === "string") {
        await CanvasContext.pageLoaded;
      }
      if (log.get("debug") || props.debug) {
        await loadWebGLDeveloperTools();
      }
      const {
        spector: spector2
      } = props;
      if (log.get("spector") || spector2) {
        await loadSpectorJS();
      }
      log.probe(LOG_LEVEL2 + 1, "DOM is loaded")();
      if (props.gl && props.gl.device) {
        return _WebGLDevice.attach(props.gl);
      }
      const device = new _WebGLDevice(props);
      const message2 = `Created ${device.info.type}${device.debug ? " debug" : ""} context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
      log.probe(LOG_LEVEL2, message2)();
      log.table(LOG_LEVEL2, device.info)();
      log.groupEnd(LOG_LEVEL2)();
      return device;
    }
    constructor(props) {
      super({
        ...props,
        id: props.id || uid("webgl-device")
      });
      const device = props.gl?.device;
      if (device) {
        throw new Error(`WebGL context already attached to device ${device.id}`);
      }
      const canvas = props.canvas || props.gl?.canvas;
      this.canvasContext = new WebGLCanvasContext(this, {
        ...props,
        canvas
      });
      this.lost = new Promise((resolve) => {
        this._resolveContextLost = resolve;
      });
      const onContextLost = (event) => this._resolveContextLost?.({
        reason: "destroyed",
        message: "Computer entered sleep mode, or too many apps or browser tabs are using the GPU."
      });
      let gl = props.gl || null;
      gl = gl || (isBrowser() ? createBrowserContext(this.canvasContext.canvas, {
        ...props,
        onContextLost
      }) : null);
      gl = gl || (!isBrowser() ? createHeadlessContext({
        ...props,
        onContextLost
      }) : null);
      if (!gl) {
        throw new Error("WebGL context creation failed");
      }
      this.handle = gl;
      this.gl = this.handle;
      this.gl2 = this.gl;
      this.isWebGL2 = isWebGL22(this.gl);
      this.isWebGL1 = !this.isWebGL2;
      this.canvasContext.resize();
      this.info = getDeviceInfo(this.gl);
      this.gl.device = this;
      this.gl._version = this.isWebGL2 ? 2 : 1;
      polyfillContext(this.gl);
      const {
        enable: enable2 = true,
        copyState = false
      } = props;
      trackContextState(this.gl, {
        enable: enable2,
        copyState,
        log: (...args) => log.log(1, ...args)()
      });
      if (isBrowser() && props.debug) {
        this.gl = makeDebugContext(this.gl, {
          ...props,
          webgl2: this.isWebGL2,
          throwOnError: true
        });
        this.gl2 = this.gl;
        this.debug = true;
        log.level = Math.max(log.level, 1);
        log.warn("WebGL debug mode activated. Performance reduced.")();
      }
      if (isBrowser() && props.spector) {
        const canvas2 = this.handle.canvas || props.canvas;
        this.spector = initializeSpectorJS({
          ...this.props,
          canvas: canvas2
        });
      }
    }
    destroy() {
      const ext = this.gl.getExtension("STACKGL_destroy_context");
      if (ext) {
        ext.destroy();
      }
    }
    get isLost() {
      return this.gl.isContextLost();
    }
    getSize() {
      return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
    }
    isTextureFormatSupported(format) {
      return isTextureFormatSupported(this.gl, format);
    }
    isTextureFormatFilterable(format) {
      return isTextureFormatFilterable(this.gl, format);
    }
    isTextureFormatRenderable(format) {
      return isTextureFormatRenderable(this.gl, format);
    }
    assertWebGL2() {
      if (!this.gl2) {
        throw new Error("Requires WebGL2");
      }
      return this.gl2;
    }
    createCanvasContext(props) {
      throw new Error("WebGL only supports a single canvas");
    }
    createBuffer(props) {
      const newProps = this._getBufferProps(props);
      return new WEBGLBuffer(this, newProps);
    }
    _createTexture(props) {
      return new WEBGLTexture(this, props);
    }
    createExternalTexture(props) {
      throw new Error("createExternalTexture() not implemented");
    }
    createSampler(props) {
      return new WEBGLSampler(this, props);
    }
    createShader(props) {
      return new WEBGLShader(this, props);
    }
    createFramebuffer(props) {
      return new WEBGLFramebuffer(this, props);
    }
    createRenderPipeline(props) {
      return new WEBGLRenderPipeline(this, props);
    }
    createVertexArray(props) {
      return new WEBGLVertexArray(this, props);
    }
    beginRenderPass(props) {
      return new WEBGLRenderPass(this, props);
    }
    createComputePipeline(props) {
      throw new Error("ComputePipeline not supported in WebGL");
    }
    beginComputePass(props) {
      throw new Error("ComputePass not supported in WebGL");
    }
    createTransformFeedback(props) {
      return new WEBGLTransformFeedback(this, props);
    }
    renderPass = null;
    getDefaultRenderPass() {
      this.renderPass = this.renderPass || this.beginRenderPass({
        framebuffer: this.canvasContext.getCurrentFramebuffer()
      });
      return this.renderPass;
    }
    createCommandEncoder(props) {
      return new WEBGLCommandEncoder(this, props);
    }
    submit() {
      this.renderPass?.end();
      this.renderPass = null;
    }
    readPixelsToArrayWebGL(source, options) {
      return readPixelsToArray(source, options);
    }
    readPixelsToBufferWebGL(source, options) {
      return readPixelsToBuffer(source, options);
    }
    setParametersWebGL(parameters) {
      setGLParameters(this, parameters);
    }
    getParametersWebGL(parameters) {
      return getGLParameters(this, parameters);
    }
    withParametersWebGL(parameters, func) {
      withGLParameters(this, parameters, func);
    }
    clearWebGL(options) {
      clear(this, options);
    }
    gl2 = null;
    debug = false;
    _canvasSizeInfo = {
      clientWidth: 0,
      clientHeight: 0,
      devicePixelRatio: 1
    };
    _extensions = {};
    _polyfilled = false;
    get webglLimits() {
      this._webglLimits = this._webglLimits || getWebGLLimits(this.gl);
      return this._webglLimits;
    }
    loseDevice() {
      let deviceLossTriggered = false;
      const ext = this.gl.getExtension("WEBGL_lose_context");
      if (ext) {
        deviceLossTriggered = true;
        ext.loseContext();
      }
      this._resolveContextLost?.({
        reason: "destroyed",
        message: "Application triggered context loss"
      });
      return deviceLossTriggered;
    }
    pushState() {
      pushContextState(this.gl);
    }
    popState() {
      popContextState(this.gl);
    }
    setSpectorMetadata(handle, props) {
      handle.__SPECTOR_Metadata = props;
    }
    getGLKey(value, gl) {
      gl = gl || this.gl2 || this.gl;
      const number = Number(value);
      for (const key in gl) {
        if (gl[key] === number) {
          return `GL.${key}`;
        }
      }
      return String(value);
    }
    setConstantAttribute(location, constant) {
      this._constants = this._constants || new Array(this.limits.maxVertexAttributes).fill(null);
      const currentConstant = this._constants[location];
      if (currentConstant && compareConstantArrayValues2(currentConstant, constant)) {
        log.info(1, `setConstantAttribute(${location}) could have been skipped, value unchanged`)();
      }
      this._constants[location] = constant;
      switch (constant.constructor) {
        case Float32Array:
          setConstantFloatArray(this, location, constant);
          break;
        case Int32Array:
          setConstantIntArray(this, location, constant);
          break;
        case Uint32Array:
          setConstantUintArray(this, location, constant);
          break;
        default:
          assert2(false);
      }
    }
  };
  var WebGLDevice = _WebGLDevice;
  __publicField(WebGLDevice, "type", "webgl");
  function isWebGL3(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL22(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function setConstantFloatArray(device, location, array) {
    switch (array.length) {
      case 1:
        device.gl.vertexAttrib1fv(location, array);
        break;
      case 2:
        device.gl.vertexAttrib2fv(location, array);
        break;
      case 3:
        device.gl.vertexAttrib3fv(location, array);
        break;
      case 4:
        device.gl.vertexAttrib4fv(location, array);
        break;
      default:
        assert2(false);
    }
  }
  function setConstantIntArray(device, location, array) {
    device.assertWebGL2();
    device.gl2?.vertexAttribI4iv(location, array);
  }
  function setConstantUintArray(device, location, array) {
    device.assertWebGL2();
    device.gl2?.vertexAttribI4uiv(location, array);
  }
  function compareConstantArrayValues2(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }
  return __toCommonJS(src_exports);
})();
      return __exports__;
      });
