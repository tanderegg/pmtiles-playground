import { assert, checkProps } from '@luma.gl/core';
import { getTypedArrayFromGLType } from "./typed-array-utils.js";
const DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
const PROP_CHECKS = {
  deprecatedProps: {
    instanced: 'divisor',
    isInstanced: 'divisor'
  }
};
export class Accessor {
  static getBytesPerElement(accessor) {
    const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(accessor) {
    assert(accessor.size);
    const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT * accessor.size;
  }
  static resolve() {
    for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
      accessors[_key] = arguments[_key];
    }
    return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
  }
  constructor() {
    this.offset = void 0;
    this.stride = void 0;
    this.type = void 0;
    this.size = void 0;
    this.divisor = void 0;
    this.normalized = void 0;
    this.integer = void 0;
    this.buffer = void 0;
    this.index = void 0;
    for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      accessors[_key2] = arguments[_key2];
    }
    accessors.forEach(accessor => this._assign(accessor));
    Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  get BYTES_PER_ELEMENT() {
    return Accessor.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return Accessor.getBytesPerVertex(this);
  }
  _assign() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    props = checkProps('Accessor', props, PROP_CHECKS);
    if (props.type !== undefined) {
      this.type = props.type;
      if (props.type === 5124 || props.type === 5125) {
        this.integer = true;
      }
    }
    if (props.size !== undefined) {
      this.size = props.size;
    }
    if (props.offset !== undefined) {
      this.offset = props.offset;
    }
    if (props.stride !== undefined) {
      this.stride = props.stride;
    }
    if (props.normalize !== undefined) {
      this.normalized = props.normalize;
    }
    if (props.normalized !== undefined) {
      this.normalized = props.normalized;
    }
    if (props.integer !== undefined) {
      this.integer = props.integer;
    }
    if (props.divisor !== undefined) {
      this.divisor = props.divisor;
    }
    if (props.buffer !== undefined) {
      this.buffer = props.buffer;
    }
    if (props.index !== undefined) {
      if (typeof props.index === 'boolean') {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }
    if (props.instanced !== undefined) {
      this.divisor = props.instanced ? 1 : 0;
    }
    if (props.isInstanced !== undefined) {
      this.divisor = props.isInstanced ? 1 : 0;
    }
    if (this.offset === undefined) delete this.offset;
    if (this.stride === undefined) delete this.stride;
    if (this.type === undefined) delete this.type;
    if (this.size === undefined) delete this.size;
    if (this.divisor === undefined) delete this.divisor;
    if (this.normalized === undefined) delete this.normalized;
    if (this.integer === undefined) delete this.integer;
    if (this.buffer === undefined) delete this.buffer;
    if (this.index === undefined) delete this.index;
    return this;
  }
}
export { DEFAULT_ACCESSOR_VALUES };
//# sourceMappingURL=accessor.js.map