{"version":3,"file":"copy-and-blit.js","names":["assert","Texture","Framebuffer","getGLTypeFromTypedArray","getTypedArrayFromGLType","glFormatToComponents","glTypeToBytes","readPixelsToArray","source","options","_framebuffer$colorAtt","sourceX","sourceY","sourceFormat","sourceAttachment","target","sourceWidth","sourceHeight","sourceType","framebuffer","deleteFramebuffer","getFramebuffer","gl","handle","width","height","attachment","colorAttachments","type","getPixelArray","prevHandle","bindFramebuffer","readPixels","destroy","readPixelsToBuffer","targetByteOffset","webglFramebuffer","webglBufferTarget","components","byteCount","byteLength","device","createBuffer","commandEncoder","createCommandEncoder","copyTextureToBuffer","origin","destination","byteOffset","copyToTexture","targetMipmaplevel","targetInternalFormat","targetX","targetY","targetZ","isSubCopy","texture","textureTarget","Number","isFinite","bind","copyTexImage2D","copyTexSubImage2D","assertWebGL2","gl2","copyTexSubImage3D","unbind","toFramebuffer","props","id","createFramebuffer","pixelArray","format","ArrayType","clamped"],"sources":["../../src/classic/copy-and-blit.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport {assert, Buffer, Texture, Framebuffer, FramebufferProps} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\n\nimport {WEBGLTexture} from '../adapter/resources/webgl-texture';\nimport {WEBGLFramebuffer} from '../adapter/resources/webgl-framebuffer';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from './typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from './format-utils';\nimport {WEBGLBuffer} from '../adapter/resources/webgl-buffer';\n\n/**\n * Copies data from a type  or a Texture object into ArrayBuffer object.\n * App can provide targetPixelArray or have it auto allocated by this method\n *  newly allocated by this method unless provided by app.\n * @deprecated Use CommandEncoder.copyTextureToBuffer and Buffer.read\n * @note Slow requires roundtrip to GPU\n *\n * @param source\n * @param options\n * @returns pixel array,\n */\nexport function readPixelsToArray(\n  source: Framebuffer | Texture,\n  options?: {\n    sourceX?: number;\n    sourceY?: number;\n    sourceFormat?: number;\n    sourceAttachment?: number;\n    target?: Uint8Array | Uint16Array | Float32Array;\n    // following parameters are auto deduced if not provided\n    sourceWidth?: number;\n    sourceHeight?: number;\n    sourceType?: number;\n  }\n): Uint8Array | Uint16Array | Float32Array {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    sourceAttachment = GL.COLOR_ATTACHMENT0 // TODO - support gl.readBuffer\n  } = options || {};\n  let {\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options || {};\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle} = framebuffer as WEBGLFramebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // TODO - Set and unset gl.readBuffer\n  // if (sourceAttachment === GL.COLOR_ATTACHMENT0 && handle === null) {\n  //   sourceAttachment = GL.FRONT;\n  // }\n\n  const attachment = sourceAttachment - GL.COLOR_ATTACHMENT0;\n  // assert(attachments[sourceAttachment]);\n\n  // Deduce the type from color attachment if not provided.\n  sourceType =\n    sourceType ||\n    (framebuffer.colorAttachments[attachment] as WEBGLTexture)?.type ||\n    GL.UNSIGNED_BYTE;\n\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  // @ts-expect-error\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return target;\n}\n\n/**\n * Copies data from a Framebuffer or a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n * @deprecated Use CommandEncoder\n * @param source\n * @param options\n */\nexport function readPixelsToBuffer(\n  source: Framebuffer | Texture,\n  options?: {\n    sourceX?: number;\n    sourceY?: number;\n    sourceFormat?: number;\n    target?: Buffer; // A new Buffer object is created when not provided.\n    targetByteOffset?: number; // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth?: number;\n    sourceHeight?: number;\n    sourceType?: number;\n  }\n): WEBGLBuffer {\n  const {target, sourceX = 0, sourceY = 0, sourceFormat = GL.RGBA, targetByteOffset = 0} = options || {};\n  // following parameters are auto deduced if not provided\n  let {sourceWidth, sourceHeight, sourceType} = options || {};\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const webglFramebuffer = framebuffer as WEBGLFramebuffer;\n\n  // deduce type if not available.\n  sourceType = sourceType || GL.UNSIGNED_BYTE;\n\n  let webglBufferTarget = target as unknown as WEBGLBuffer | undefined;\n  if (!webglBufferTarget) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    webglBufferTarget = webglFramebuffer.device.createBuffer({byteLength});\n  }\n\n  // TODO(donmccurdy): Do we have tests to confirm this is working?\n  const commandEncoder = source.device.createCommandEncoder();\n  commandEncoder.copyTextureToBuffer({\n    source: source as Texture,\n    width: sourceWidth,\n    height: sourceHeight,\n    origin: [sourceX, sourceY],\n    destination: webglBufferTarget,\n    byteOffset: targetByteOffset\n  });\n  commandEncoder.destroy();\n\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n\n  return webglBufferTarget;\n}\n\n/**\n * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n * @deprecated Use CommandEncoder\n */\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(\n  source: Framebuffer | Texture,\n  target: Texture | GL,\n  options?: {\n    sourceX?: number;\n    sourceY?: number;\n\n    targetX?: number;\n    targetY?: number;\n    targetZ?: number;\n    targetMipmaplevel?: number;\n    targetInternalFormat?: number;\n\n    width?: number; // defaults to target width\n    height?: number; // defaults to target height\n  }\n): Texture {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = GL.RGBA\n  } = options || {};\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width, // defaults to target width\n    height // defaults to target height\n  } = options || {};\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const webglFramebuffer = framebuffer as WEBGLFramebuffer;\n  const {device, handle} = webglFramebuffer;\n  const isSubCopy =\n    typeof targetX !== 'undefined' ||\n    typeof targetY !== 'undefined' ||\n    typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = device.gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  assert(target);\n  let texture = null;\n  let textureTarget: GL;\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    textureTarget = texture.target;\n  } else {\n    textureTarget = target;\n  }\n\n  if (!isSubCopy) {\n    device.gl.copyTexImage2D(\n      textureTarget,\n      targetMipmaplevel,\n      targetInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    switch (textureTarget) {\n      case GL.TEXTURE_2D:\n      case GL.TEXTURE_CUBE_MAP:\n        device.gl.copyTexSubImage2D(\n          textureTarget,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        device.assertWebGL2();\n        device.gl2.copyTexSubImage3D(\n          textureTarget,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          targetZ,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-expect-error\n  device.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return texture;\n}\n\nfunction getFramebuffer(source: Texture | Framebuffer): {\n  framebuffer: Framebuffer;\n  deleteFramebuffer: boolean;\n} {\n  if (!(source instanceof Framebuffer)) {\n    return {framebuffer: toFramebuffer(source), deleteFramebuffer: true};\n  }\n  return {framebuffer: source, deleteFramebuffer: false};\n}\n\n/**\n * Wraps a given texture into a framebuffer object, that can be further used\n * to read data from the texture object.\n */\nexport function toFramebuffer(texture: Texture, props?: FramebufferProps): Framebuffer {\n  const {device, width, height, id} = texture;\n  const framebuffer = device.createFramebuffer({\n    ...props,\n    id: `framebuffer-for-${id}`,\n    width,\n    height,\n    colorAttachments: [texture]\n  });\n  return framebuffer;\n}\n\nfunction getPixelArray(\n  pixelArray,\n  type,\n  format,\n  width: number,\n  height: number\n): Uint8Array | Uint16Array | Float32Array {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // Allocate pixel array if not already available, using supplied type\n  type = type || GL.UNSIGNED_BYTE;\n  const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n  const components = glFormatToComponents(format);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components) as Uint8Array | Uint16Array | Float32Array;\n}\n"],"mappings":"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"}