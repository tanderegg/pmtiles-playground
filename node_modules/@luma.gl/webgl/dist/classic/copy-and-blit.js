import { assert, Texture, Framebuffer } from '@luma.gl/core';
import { getGLTypeFromTypedArray, getTypedArrayFromGLType } from "./typed-array-utils.js";
import { glFormatToComponents, glTypeToBytes } from "./format-utils.js";
export function readPixelsToArray(source, options) {
  var _framebuffer$colorAtt;
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408,
    sourceAttachment = 36064
  } = options || {};
  let {
    target = null,
    sourceWidth,
    sourceHeight,
    sourceType
  } = options || {};
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert(framebuffer);
  const {
    gl,
    handle
  } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const attachment = sourceAttachment - 36064;
  sourceType = sourceType || ((_framebuffer$colorAtt = framebuffer.colorAttachments[attachment]) === null || _framebuffer$colorAtt === void 0 ? void 0 : _framebuffer$colorAtt.type) || 5121;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || getGLTypeFromTypedArray(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return target;
}
export function readPixelsToBuffer(source, options) {
  const {
    target,
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408,
    targetByteOffset = 0
  } = options || {};
  let {
    sourceWidth,
    sourceHeight,
    sourceType
  } = options || {};
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const webglFramebuffer = framebuffer;
  sourceType = sourceType || 5121;
  let webglBufferTarget = target;
  if (!webglBufferTarget) {
    const components = glFormatToComponents(sourceFormat);
    const byteCount = glTypeToBytes(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    webglBufferTarget = webglFramebuffer.device.createBuffer({
      byteLength
    });
  }
  const commandEncoder = source.device.createCommandEncoder();
  commandEncoder.copyTextureToBuffer({
    source: source,
    width: sourceWidth,
    height: sourceHeight,
    origin: [sourceX, sourceY],
    destination: webglBufferTarget,
    byteOffset: targetByteOffset
  });
  commandEncoder.destroy();
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return webglBufferTarget;
}
export function copyToTexture(source, target, options) {
  const {
    sourceX = 0,
    sourceY = 0,
    targetMipmaplevel = 0,
    targetInternalFormat = 6408
  } = options || {};
  let {
    targetX,
    targetY,
    targetZ,
    width,
    height
  } = options || {};
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert(framebuffer);
  const webglFramebuffer = framebuffer;
  const {
    device,
    handle
  } = webglFramebuffer;
  const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = device.gl.bindFramebuffer(36160, handle);
  assert(target);
  let texture = null;
  let textureTarget;
  if (target instanceof Texture) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    textureTarget = texture.target;
  } else {
    textureTarget = target;
  }
  if (!isSubCopy) {
    device.gl.copyTexImage2D(textureTarget, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (textureTarget) {
      case 3553:
      case 34067:
        device.gl.copyTexSubImage2D(textureTarget, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        device.assertWebGL2();
        device.gl2.copyTexSubImage3D(textureTarget, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;
      default:
    }
  }
  if (texture) {
    texture.unbind();
  }
  device.gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.destroy();
  }
  return texture;
}
function getFramebuffer(source) {
  if (!(source instanceof Framebuffer)) {
    return {
      framebuffer: toFramebuffer(source),
      deleteFramebuffer: true
    };
  }
  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}
export function toFramebuffer(texture, props) {
  const {
    device,
    width,
    height,
    id
  } = texture;
  const framebuffer = device.createFramebuffer({
    ...props,
    id: `framebuffer-for-${id}`,
    width,
    height,
    colorAttachments: [texture]
  });
  return framebuffer;
}
function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  type = type || 5121;
  const ArrayType = getTypedArrayFromGLType(type, {
    clamped: false
  });
  const components = glFormatToComponents(format);
  return new ArrayType(width * height * components);
}
//# sourceMappingURL=copy-and-blit.js.map