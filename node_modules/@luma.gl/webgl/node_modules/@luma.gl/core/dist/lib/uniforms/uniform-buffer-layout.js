import { decodeShaderUniformType, alignTo } from "../../adapter/type-utils/decode-shader-types.js";
import { getScratchArrayBuffer } from "../../utils/array-utils-flat.js";
import { isNumberArray } from "../../utils/is-array.js";
import { log } from "../../utils/log.js";
const minBufferSize = 1024;
export class UniformBufferLayout {
  constructor(uniformTypes) {
    this.layout = {};
    this.byteLength = void 0;
    let size = 0;
    for (const [key, uniformType] of Object.entries(uniformTypes)) {
      const typeAndComponents = decodeShaderUniformType(uniformType);
      const {
        type,
        components: count
      } = typeAndComponents;
      size = alignTo(size, count);
      const offset = size;
      size += count;
      this.layout[key] = {
        type,
        size: count,
        offset
      };
    }
    size += (4 - size % 4) % 4;
    const actualByteLength = size * 4;
    this.byteLength = Math.max(actualByteLength, minBufferSize);
  }
  getData(uniformValues) {
    const bufferSize = Math.max(this.byteLength, minBufferSize);
    const arrayBuffer = getScratchArrayBuffer(bufferSize);
    const typedArrays = {
      i32: new Int32Array(arrayBuffer),
      u32: new Uint32Array(arrayBuffer),
      f32: new Float32Array(arrayBuffer),
      f16: new Uint16Array(arrayBuffer)
    };
    for (const [name, value] of Object.entries(uniformValues)) {
      const uniformLayout = this.layout[name];
      if (!uniformLayout) {
        log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();
        continue;
      }
      const {
        type,
        size,
        offset
      } = uniformLayout;
      const typedArray = typedArrays[type];
      if (size === 1) {
        if (typeof value !== 'number' && typeof value !== 'boolean') {
          log.warn(`Supplied value for single component uniform ${name} is not a number: ${value}`)();
          continue;
        }
        typedArray[offset] = Number(value);
      } else {
        const numericArray = isNumberArray(value);
        if (!numericArray) {
          log.warn(`Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`)();
          continue;
        }
        typedArray.set(numericArray, offset);
      }
    }
    return new Uint8Array(arrayBuffer);
  }
  has(name) {
    return Boolean(this.layout[name]);
  }
  get(name) {
    const layout = this.layout[name];
    return layout;
  }
}
//# sourceMappingURL=uniform-buffer-layout.js.map