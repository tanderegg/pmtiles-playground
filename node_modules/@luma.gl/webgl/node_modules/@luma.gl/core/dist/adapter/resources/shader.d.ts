import type { Device } from '../device';
import { Resource, ResourceProps } from './resource';
import { CompilerMessage } from '../../lib/compiler-log/compiler-message';
/**
 * Properties for a Shader
 */
export type ShaderProps = ResourceProps & {
    /** Shader language (defaults to auto) */
    language?: 'glsl' | 'wgsl' | 'auto';
    /** Which stage are we compiling? Required by WebGL and GLSL transpiler */
    stage: 'vertex' | 'fragment' | 'compute';
    /** Shader source code */
    source: string;
    /** Optional shader source map (WebGPU only) */
    sourceMap?: string | null;
    /** Optional shader entry point (WebGPU only) */
    entryPoint?: string;
    /** Show shader source in browser? */
    debug?: 'never' | 'errors' | 'warnings' | 'always';
};
/**
 * Immutable Shader object
 * In WebGPU the handle can be copied between threads
 */
export declare abstract class Shader extends Resource<ShaderProps> {
    static defaultProps: Required<ShaderProps>;
    get [Symbol.toStringTag](): string;
    /** The stage of this shader */
    readonly stage: 'vertex' | 'fragment' | 'compute';
    /** The source code of this shader */
    readonly source: string;
    /** The compilation status of this shader. May be 'pending' if compilation is done asynchronously */
    compilationStatus: 'success' | 'error' | 'pending';
    /** Create a new Shader instance */
    constructor(device: Device, props: ShaderProps);
    /** Get compiler log asynchronously */
    abstract getCompilationInfo(): Promise<readonly CompilerMessage[]>;
    /** Get compiler log synchronously (WebGL only) */
    getCompilationInfoSync(): readonly CompilerMessage[] | null;
    /** In browser logging of errors */
    debugShader(): Promise<void>;
    /** In-browser UI logging of errors */
    protected _displayShaderLog(messages: readonly CompilerMessage[]): void;
}
//# sourceMappingURL=shader.d.ts.map