{"version":3,"file":"render-pass.js","names":["Resource","_Symbol$toStringTag","Symbol","toStringTag","RenderPass","constructor","device","props","defaultProps","framebuffer","parameters","undefined","clearColor","clearDepth","clearStencil","depthReadOnly","stencilReadOnly","discard"],"sources":["../../../src/adapter/resources/render-pass.ts"],"sourcesContent":["// luma.gl, MIT license\nimport type {Device} from '../device'\nimport type { RenderPassParameters } from '../types/parameters';\n// import {Binding} from '../types/shader-layout';\nimport {Resource, ResourceProps} from './resource';\n// import {Buffer} from './buffer';\n// import {RenderPipeline} from './render-pipeline';\n// import {CommandEncoder} from './command-encoder';\nimport {Framebuffer} from './framebuffer';\nimport {NumberArray} from '../..';\n\n/**\n * Properties for a RenderPass instance is a required parameter to all draw calls.\n */\nexport type RenderPassProps = ResourceProps & {\n  /** Framebuffer specifies which textures to render into. Default gets framebuffer from canvas context. */\n  framebuffer?: Framebuffer | null;\n  /** Control viewport, scissor rect, blend constant and stencil ref */\n  parameters?: RenderPassParameters;\n  /** Clear value for color attachment, or `load` to preserve the previous value */\n  clearColor?: NumberArray | false;\n  /** Clear value for depth attachment, or `load` to preserve the previous value */\n  clearDepth?: number | false;\n  /** Clear value for stencil attachment, or `load` to preserve the previous value */\n  clearStencil?: number | false;\n  /** Indicates that the depth component is read only. */\n  depthReadOnly?: boolean;\n  /** Indicates that the stencil component is read only. */\n  stencilReadOnly?: boolean;\n  /** Whether to disable / discard the output of the rasterizer */\n  discard?: boolean; \n};\n\n/**\n * A RenderPass instance is a required parameter to all draw calls.\n * \n * It holds a combination of \n * - render targets (specified via a framebuffer)\n * - clear colors, read/write, discard information for the framebuffer attachments\n * - a couple of mutable parameters ()\n */\nexport abstract class RenderPass extends Resource<RenderPassProps> {\n\n  /** Default properties for RenderPass */\n  static override defaultProps: Required<RenderPassProps> = {\n    ...Resource.defaultProps,\n    framebuffer: null,\n    parameters: undefined,\n    clearColor: [0, 0, 0, 0],\n    clearDepth: 1,\n    clearStencil: 0,\n    depthReadOnly: false,\n    stencilReadOnly: false,\n    discard: false\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'RenderPass';\n  }\n\n  constructor(device: Device, props: RenderPassProps) {\n    super(device, props, RenderPass.defaultProps);\n  }\n\n  /** Call when rendering is done in this pass. */\n  abstract end(): void;\n\n  /** \n   * A small set of parameters can be changed between every draw call \n   * (viewport, scissorRect, blendColor, stencilReference) \n   */\n  abstract setParameters(parameters: RenderPassParameters): void;\n\n  abstract pushDebugGroup(groupLabel: string): void;\n  abstract popDebugGroup(): void;\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  // writeTimestamp(querySet: GPUQuerySet, queryIndex: number): void;\n\n  // beginOcclusionQuery(queryIndex: number): void;\n  // endOcclusionQuery(): void;\n\n  // executeBundles(bundles: Iterable<GPURenderBundle>): void;\n\n  // In WebGPU the following methods are on the renderpass.\n  // luma.gl keeps them on the pipeline for now\n\n  /*\n  setPipeline(pipeline: RenderPipeline): void {}\n\n  setIndexBuffer(\n    buffer: Buffer,\n    indexFormat: 'uint16' | 'uint32',\n    offset?: number,\n    size?: number\n  ): void {}\n\n  abstract setVertexBuffer(slot: number, buffer: Buffer, offset: number): void;\n\n  abstract setBindings(bindings: Record<string, Binding>): void;\n\n  abstract setParameters(parameters: RenderPassParameters);\n\n  draw(options: {\n    vertexCount?: number; // Either vertexCount or indexCount must be provided\n    indexCount?: number;  // Activates indexed drawing (call setIndexBuffer())\n    instanceCount?: number; //\n    firstVertex?: number;\n    firstIndex?: number; // requires device.features.has('indirect-first-instance')?\n    firstInstance?: number;\n    baseVertex?: number;\n  }): void {}\n\n  drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;\n  drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;\n  */\n}\n"],"mappings":";SAIQA,QAAQ;AAAAC,mBAAA,GAoDAC,MAAM,CAACC,WAAW;AAflC,OAAO,MAAeC,UAAU,SAASJ,QAAQ,CAAkB;EAejE,KAAAC,mBAAA,IAA4C;IAC1C,OAAO,YAAY;EACrB;EAEAI,WAAWA,CAACC,MAAc,EAAEC,KAAsB,EAAE;IAClD,KAAK,CAACD,MAAM,EAAEC,KAAK,EAAEH,UAAU,CAACI,YAAY,CAAC;EAC/C;AAsDF;AA3EsBJ,UAAU,CAGdI,YAAY,GAA8B;EACxD,GAAGR,QAAQ,CAACQ,YAAY;EACxBC,WAAW,EAAE,IAAI;EACjBC,UAAU,EAAEC,SAAS;EACrBC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACxBC,UAAU,EAAE,CAAC;EACbC,YAAY,EAAE,CAAC;EACfC,aAAa,EAAE,KAAK;EACpBC,eAAe,EAAE,KAAK;EACtBC,OAAO,EAAE;AACX,CAAC"}