import { log } from "../../utils/log.js";
import { decodeShaderAttributeType } from "../type-utils/decode-attribute-type.js";
import { decodeVertexFormat } from "../type-utils/decode-vertex-format.js";
export function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
  const attributeInfos = {};
  for (const attribute of shaderLayout.attributes) {
    attributeInfos[attribute.name] = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
  }
  return attributeInfos;
}
export function getAttributeInfosByLocation(shaderLayout, bufferLayout) {
  let maxVertexAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;
  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
  const locationInfos = new Array(maxVertexAttributes).fill(null);
  for (const attributeInfo of Object.values(attributeInfos)) {
    locationInfos[attributeInfo.location] = attributeInfo;
  }
  return locationInfos;
}
function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name) {
  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name);
  const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name);
  if (!shaderDeclaration) {
    return null;
  }
  const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);
  const vertexFormat = (bufferMapping === null || bufferMapping === void 0 ? void 0 : bufferMapping.vertexFormat) || attributeTypeInfo.defaultVertexFormat;
  const vertexFormatInfo = decodeVertexFormat(vertexFormat);
  return {
    attributeName: (bufferMapping === null || bufferMapping === void 0 ? void 0 : bufferMapping.attributeName) || shaderDeclaration.name,
    bufferName: (bufferMapping === null || bufferMapping === void 0 ? void 0 : bufferMapping.bufferName) || shaderDeclaration.name,
    location: shaderDeclaration.location,
    shaderType: shaderDeclaration.type,
    shaderDataType: attributeTypeInfo.dataType,
    shaderComponents: attributeTypeInfo.components,
    vertexFormat,
    bufferDataType: vertexFormatInfo.type,
    bufferComponents: vertexFormatInfo.components,
    normalized: vertexFormatInfo.normalized,
    integer: attributeTypeInfo.integer,
    stepMode: (bufferMapping === null || bufferMapping === void 0 ? void 0 : bufferMapping.stepMode) || shaderDeclaration.stepMode,
    byteOffset: (bufferMapping === null || bufferMapping === void 0 ? void 0 : bufferMapping.byteOffset) || 0,
    byteStride: (bufferMapping === null || bufferMapping === void 0 ? void 0 : bufferMapping.byteStride) || 0
  };
}
function getAttributeFromShaderLayout(shaderLayout, name) {
  const attribute = shaderLayout.attributes.find(attr => attr.name === name);
  if (!attribute) {
    log.warn(`shader layout attribute "${name}" not present in shader`);
  }
  return attribute || null;
}
function getAttributeFromBufferLayout(bufferLayouts, name) {
  checkBufferLayouts(bufferLayouts);
  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name);
  if (bufferLayoutInfo) {
    return bufferLayoutInfo;
  }
  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name);
  if (bufferLayoutInfo) {
    return bufferLayoutInfo;
  }
  log.warn(`layout for attribute "${name}" not present in buffer layout`);
  return null;
}
function checkBufferLayouts(bufferLayouts) {
  for (const bufferLayout of bufferLayouts) {
    if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
    }
  }
}
function getAttributeFromShortHand(bufferLayouts, name) {
  for (const bufferLayout of bufferLayouts) {
    if (bufferLayout.format && bufferLayout.name === name) {
      return {
        attributeName: bufferLayout.name,
        bufferName: name,
        stepMode: bufferLayout.stepMode,
        vertexFormat: bufferLayout.format,
        byteOffset: 0,
        byteStride: bufferLayout.byteStride || 0
      };
    }
  }
  return null;
}
function getAttributeFromAttributesList(bufferLayouts, name) {
  for (const bufferLayout of bufferLayouts) {
    var _bufferLayout$attribu;
    let byteStride = bufferLayout.byteStride;
    if (typeof bufferLayout.byteStride !== 'number') {
      for (const attributeMapping of bufferLayout.attributes || []) {
        const info = decodeVertexFormat(attributeMapping.format);
        byteStride += info.byteLength;
      }
    }
    const attributeMapping = (_bufferLayout$attribu = bufferLayout.attributes) === null || _bufferLayout$attribu === void 0 ? void 0 : _bufferLayout$attribu.find(mapping => mapping.attribute === name);
    if (attributeMapping) {
      return {
        attributeName: attributeMapping.attribute,
        bufferName: bufferLayout.name,
        stepMode: bufferLayout.stepMode,
        vertexFormat: attributeMapping.format,
        byteOffset: attributeMapping.byteOffset,
        byteStride
      };
    }
  }
  return null;
}
export function mergeShaderLayout(baseLayout, overrideLayout) {
  const mergedLayout = {
    ...baseLayout,
    attributes: baseLayout.attributes.map(attribute => ({
      ...attribute
    }))
  };
  for (const attribute of (overrideLayout === null || overrideLayout === void 0 ? void 0 : overrideLayout.attributes) || []) {
    const baseAttribute = mergedLayout.attributes.find(attr => attr.name === attribute.name);
    if (!baseAttribute) {
      log.warn(`shader layout attribute ${attribute.name} not present in shader`);
    } else {
      baseAttribute.type = attribute.type || baseAttribute.type;
      baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
    }
  }
  return mergedLayout;
}
//# sourceMappingURL=get-attribute-from-layouts.js.map