{"version":3,"file":"vertex-array.js","names":["getAttributeInfosByLocation","Resource","_Symbol$toStringTag","Symbol","toStringTag","VertexArray","constructor","device","props","defaultProps","maxVertexAttributes","attributeInfos","indexBuffer","attributes","limits","Array","fill","renderPipeline","shaderLayout","bufferLayout"],"sources":["../../../src/adapter/resources/vertex-array.ts"],"sourcesContent":["// luma.gl, MIT license\nimport type {TypedArray} from '../../types';\nimport {\n  AttributeInfo,\n  getAttributeInfosByLocation\n} from '../attribute-utils/get-attribute-from-layouts';\nimport type {Device} from '../device';\nimport type {Buffer} from './buffer';\nimport type {RenderPass} from './render-pass';\nimport type {RenderPipeline} from './render-pipeline';\nimport {Resource, ResourceProps} from './resource';\n\n/** Properties for initializing a VertexArray */\nexport type VertexArrayProps = ResourceProps & {\n  renderPipeline: RenderPipeline | null;\n};\n\n/**\n * Stores attribute bindings.\n * Makes it easy to share a render pipeline and use separate vertex arrays.\n * @note On WebGL, VertexArray allows non-constant bindings to be performed in advance\n * reducing the number of WebGL calls per draw call.\n * @note On WebGPU this is just a convenience class that collects the bindings.\n */\nexport abstract class VertexArray extends Resource<VertexArrayProps> {\n  static override defaultProps: Required<VertexArrayProps> = {\n    ...Resource.defaultProps,\n    renderPipeline: null\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'VertexArray';\n  }\n\n  /** Max number of vertex attributes */\n  readonly maxVertexAttributes: number;\n  /** Attribute infos indexed by location - TODO only needed by webgl module? */\n  protected readonly attributeInfos: AttributeInfo[];\n\n  /** Index buffer */\n  indexBuffer: Buffer | null = null;\n  /** Attributes indexed by buffer slot */\n  attributes: (Buffer | TypedArray | null)[];\n\n  constructor(device: Device, props: VertexArrayProps) {\n    super(device, props, VertexArray.defaultProps);\n    this.maxVertexAttributes = device.limits.maxVertexAttributes;\n    this.attributes = new Array(this.maxVertexAttributes).fill(null);\n    this.attributeInfos = getAttributeInfosByLocation(\n      props.renderPipeline.shaderLayout,\n      props.renderPipeline.bufferLayout,\n      this.maxVertexAttributes\n    );\n  }\n\n  /** Set attributes (stored on pipeline and set before each call) */\n  abstract setIndexBuffer(indices: Buffer | null): void;\n  /** Set attributes (stored on pipeline and set before each call) */\n  abstract setBuffer(bufferSlot: number, buffer: Buffer | null): void;\n  /** Set constant attributes (WebGL only) */\n  abstract setConstant(location: number, value: TypedArray | null): void;\n\n  abstract bindBeforeRender(renderPass: RenderPass): void;\n  abstract unbindAfterRender(renderPass: RenderPass): void;\n}\n"],"mappings":";SAIEA,2BAA2B;AAAA,SAMrBC,QAAQ;AAAAC,mBAAA,GAoBAC,MAAM,CAACC,WAAW;AANlC,OAAO,MAAeC,WAAW,SAASJ,QAAQ,CAAmB;EAMnE,KAAAC,mBAAA,IAA4C;IAC1C,OAAO,aAAa;EACtB;EAYAI,WAAWA,CAACC,MAAc,EAAEC,KAAuB,EAAE;IACnD,KAAK,CAACD,MAAM,EAAEC,KAAK,EAAEH,WAAW,CAACI,YAAY,CAAC;IAAC,KAVxCC,mBAAmB;IAAA,KAETC,cAAc;IAAA,KAGjCC,WAAW,GAAkB,IAAI;IAAA,KAEjCC,UAAU;IAIR,IAAI,CAACH,mBAAmB,GAAGH,MAAM,CAACO,MAAM,CAACJ,mBAAmB;IAC5D,IAAI,CAACG,UAAU,GAAG,IAAIE,KAAK,CAAC,IAAI,CAACL,mBAAmB,CAAC,CAACM,IAAI,CAAC,IAAI,CAAC;IAChE,IAAI,CAACL,cAAc,GAAGX,2BAA2B,CAC/CQ,KAAK,CAACS,cAAc,CAACC,YAAY,EACjCV,KAAK,CAACS,cAAc,CAACE,YAAY,EACjC,IAAI,CAACT,mBACP,CAAC;EACH;AAWF;AAxCsBL,WAAW,CACfI,YAAY,GAA+B;EACzD,GAAGR,QAAQ,CAACQ,YAAY;EACxBQ,cAAc,EAAE;AAClB,CAAC"}