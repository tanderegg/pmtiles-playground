let _Symbol$toStringTag;
import { Resource } from "./resource.js";
_Symbol$toStringTag = Symbol.toStringTag;
export class Buffer extends Resource {
  get [_Symbol$toStringTag]() {
    return 'Buffer';
  }
  constructor(device, props) {
    const deducedProps = {
      ...props
    };
    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {
      if (props.data instanceof Uint32Array) {
        deducedProps.indexType = 'uint32';
      } else if (props.data instanceof Uint16Array) {
        deducedProps.indexType = 'uint16';
      }
    }
    super(device, deducedProps, Buffer.defaultProps);
    this.usage = void 0;
    this.indexType = void 0;
    this.byteLength = void 0;
    this.debugData = new ArrayBuffer(0);
    this.usage = props.usage || 0;
    this.indexType = deducedProps.indexType;
  }
  readSyncWebGL2(byteOffset, byteLength) {
    throw new Error('not implemented');
  }
  _setDebugData(data, byteOffset, byteLength) {
    const buffer = ArrayBuffer.isView(data) ? data.buffer : data;
    const debugDataLength = Math.min(data ? data.byteLength : byteLength, Buffer.DEBUG_DATA_MAX_LENGTH);
    if (data === null) {
      this.debugData = new ArrayBuffer(debugDataLength);
    } else if (byteOffset === 0 && byteLength === data.byteLength) {
      this.debugData = buffer.slice(0, debugDataLength);
    } else {
      this.debugData = buffer.slice(byteOffset, byteOffset + debugDataLength);
    }
  }
}
Buffer.defaultProps = {
  ...Resource.defaultProps,
  usage: 0,
  byteLength: 0,
  byteOffset: 0,
  data: null,
  indexType: 'uint16',
  mappedAtCreation: false
};
Buffer.MAP_READ = 0x01;
Buffer.MAP_WRITE = 0x02;
Buffer.COPY_SRC = 0x0004;
Buffer.COPY_DST = 0x0008;
Buffer.INDEX = 0x0010;
Buffer.VERTEX = 0x0020;
Buffer.UNIFORM = 0x0040;
Buffer.STORAGE = 0x0080;
Buffer.INDIRECT = 0x0100;
Buffer.QUERY_RESOLVE = 0x0200;
Buffer.DEBUG_DATA_MAX_LENGTH = 32;
//# sourceMappingURL=buffer.js.map