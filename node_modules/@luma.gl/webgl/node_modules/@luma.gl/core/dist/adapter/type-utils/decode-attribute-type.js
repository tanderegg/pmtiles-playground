export function decodeShaderAttributeType(attributeType) {
  const [dataType, components] = TYPE_INFO[attributeType];
  const integer = dataType === 'i32' || dataType === 'u32';
  const signed = dataType !== 'u32';
  const byteLength = TYPE_SIZES[dataType] * components;
  const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
  return {
    dataType,
    components,
    defaultVertexFormat,
    byteLength,
    integer,
    signed
  };
}
function getCompatibleVertexFormat(dataType, components) {
  let vertexType;
  switch (dataType) {
    case 'f32':
      vertexType = 'float32';
      break;
    case 'i32':
      vertexType = 'sint32';
      break;
    case 'u32':
      vertexType = 'uint32';
      break;
    case 'f16':
      return components <= 2 ? 'float16x2' : 'float16x4';
  }
  if (components === 1) {
    return vertexType;
  }
  return `${vertexType}x${components}`;
}
const TYPE_INFO = {
  f32: ['f32', 1],
  'vec2<f32>': ['f32', 2],
  'vec3<f32>': ['f32', 3],
  'vec4<f32>': ['f32', 4],
  f16: ['f16', 1],
  'vec2<f16>': ['f16', 2],
  'vec3<f16>': ['f16', 3],
  'vec4<f16>': ['f16', 4],
  i32: ['i32', 1],
  'vec2<i32>': ['i32', 2],
  'vec3<i32>': ['i32', 3],
  'vec4<i32>': ['i32', 4],
  u32: ['u32', 1],
  'vec2<u32>': ['u32', 2],
  'vec3<u32>': ['u32', 3],
  'vec4<u32>': ['u32', 4]
};
const TYPE_SIZES = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
};
//# sourceMappingURL=decode-attribute-type.js.map