import { isBrowser } from '@probe.gl/env';
import { log } from "../utils/log.js";
const isPage = isBrowser() && typeof document !== 'undefined';
const isPageLoaded = () => isPage && document.readyState === 'complete';
const DEFAULT_CANVAS_CONTEXT_PROPS = {
  canvas: null,
  width: 800,
  height: 600,
  useDevicePixels: true,
  autoResize: true,
  container: null,
  visible: true,
  colorSpace: 'srgb',
  alphaMode: 'opaque'
};
export class CanvasContext {
  static get isPageLoaded() {
    return isPageLoaded();
  }
  constructor(props) {
    this.device = void 0;
    this.id = void 0;
    this.props = void 0;
    this.canvas = void 0;
    this.htmlCanvas = void 0;
    this.offscreenCanvas = void 0;
    this.type = void 0;
    this.width = 1;
    this.height = 1;
    this.resizeObserver = void 0;
    this._canvasSizeInfo = {
      clientWidth: 0,
      clientHeight: 0,
      devicePixelRatio: 1
    };
    this.props = {
      ...DEFAULT_CANVAS_CONTEXT_PROPS,
      ...props
    };
    props = this.props;
    if (!isBrowser()) {
      this.id = 'node-canvas-context';
      this.type = 'node';
      this.width = this.props.width;
      this.height = this.props.height;
      this.canvas = null;
      return;
    }
    if (!props.canvas) {
      var _props, _props2;
      const canvas = createCanvas(props);
      const container = getContainer(((_props = props) === null || _props === void 0 ? void 0 : _props.container) || null);
      container.insertBefore(canvas, container.firstChild);
      this.canvas = canvas;
      if (!((_props2 = props) !== null && _props2 !== void 0 && _props2.visible)) {
        this.canvas.style.visibility = 'hidden';
      }
    } else if (typeof props.canvas === 'string') {
      this.canvas = getCanvasFromDOM(props.canvas);
    } else {
      this.canvas = props.canvas;
    }
    if (this.canvas instanceof HTMLCanvasElement) {
      this.id = this.canvas.id;
      this.type = 'html-canvas';
      this.htmlCanvas = this.canvas;
    } else {
      this.id = 'offscreen-canvas';
      this.type = 'offscreen-canvas';
      this.offscreenCanvas = this.canvas;
    }
    if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {
      this.resizeObserver = new ResizeObserver(entries => {
        for (const entry of entries) {
          if (entry.target === this.canvas) {
            this.update();
          }
        }
      });
      this.resizeObserver.observe(this.canvas);
    }
  }
  getDevicePixelRatio(useDevicePixels) {
    if (typeof OffscreenCanvas !== 'undefined' && this.canvas instanceof OffscreenCanvas) {
      return 1;
    }
    useDevicePixels = useDevicePixels === undefined ? this.props.useDevicePixels : useDevicePixels;
    if (!useDevicePixels || useDevicePixels <= 0) {
      return 1;
    }
    if (useDevicePixels === true) {
      const dpr = typeof window !== 'undefined' && window.devicePixelRatio;
      return dpr || 1;
    }
    return useDevicePixels;
  }
  getPixelSize() {
    switch (this.type) {
      case 'node':
        return [this.width, this.height];
      case 'offscreen-canvas':
        return [this.canvas.width, this.canvas.height];
      case 'html-canvas':
        const dpr = this.getDevicePixelRatio();
        const canvas = this.canvas;
        return canvas.parentElement ? [canvas.clientWidth * dpr, canvas.clientHeight * dpr] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [width, height] = this.getPixelSize();
    return width / height;
  }
  cssToDeviceRatio() {
    try {
      const [drawingBufferWidth] = this.getDrawingBufferSize();
      const {
        clientWidth
      } = this._canvasSizeInfo;
      return clientWidth ? drawingBufferWidth / clientWidth : 1;
    } catch {
      return 1;
    }
  }
  cssToDevicePixels(cssPixel) {
    let yInvert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const ratio = this.cssToDeviceRatio();
    const [width, height] = this.getDrawingBufferSize();
    return scalePixels(cssPixel, ratio, width, height, yInvert);
  }
  setDevicePixelRatio(devicePixelRatio) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!this.htmlCanvas) {
      return;
    }
    let clientWidth = 'width' in options ? options.width : this.htmlCanvas.clientWidth;
    let clientHeight = 'height' in options ? options.height : this.htmlCanvas.clientHeight;
    if (!clientWidth || !clientHeight) {
      log.log(1, 'Canvas clientWidth/clientHeight is 0')();
      devicePixelRatio = 1;
      clientWidth = this.htmlCanvas.width || 1;
      clientHeight = this.htmlCanvas.height || 1;
    }
    const cachedSize = this._canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
      let clampedPixelRatio = devicePixelRatio;
      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
      this.htmlCanvas.width = canvasWidth;
      this.htmlCanvas.height = canvasHeight;
      const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();
      if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {
        clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);
        this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);
        this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);
        log.warn('Device pixel ratio clamped')();
      }
      this._canvasSizeInfo.clientWidth = clientWidth;
      this._canvasSizeInfo.clientHeight = clientHeight;
      this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;
    }
  }
  getDrawingBufferSize() {
    const gl = this.device.gl;
    if (!gl) {
      throw new Error('canvas size');
    }
    return [gl.drawingBufferWidth, gl.drawingBufferHeight];
  }
  _setAutoCreatedCanvasId(id) {
    var _this$htmlCanvas;
    if (((_this$htmlCanvas = this.htmlCanvas) === null || _this$htmlCanvas === void 0 ? void 0 : _this$htmlCanvas.id) === 'lumagl-auto-created-canvas') {
      this.htmlCanvas.id = id;
    }
  }
}
CanvasContext.pageLoaded = getPageLoadPromise();
function getPageLoadPromise() {
  if (isPageLoaded() || typeof window === 'undefined') {
    return Promise.resolve();
  }
  return new Promise(resolve => {
    window.addEventListener('load', () => resolve());
  });
}
function getContainer(container) {
  if (typeof container === 'string') {
    const element = document.getElementById(container);
    if (!element && !isPageLoaded()) {
      throw new Error(`Accessing '${container}' before page was loaded`);
    }
    if (!element) {
      throw new Error(`${container} is not an HTML element`);
    }
    return element;
  } else if (container) {
    return container;
  }
  return document.body;
}
function getCanvasFromDOM(canvasId) {
  const canvas = document.getElementById(canvasId);
  if (!canvas && !isPageLoaded()) {
    throw new Error(`Accessing '${canvasId}' before page was loaded`);
  }
  if (!(canvas instanceof HTMLCanvasElement)) {
    throw new Error('Object is not a canvas element');
  }
  return canvas;
}
function createCanvas(props) {
  const {
    width,
    height
  } = props;
  const targetCanvas = document.createElement('canvas');
  targetCanvas.id = 'lumagl-auto-created-canvas';
  targetCanvas.width = width || 1;
  targetCanvas.height = height || 1;
  targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';
  targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';
  return targetCanvas;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const point = pixel;
  const x = scaleX(point[0], ratio, width);
  let y = scaleY(point[1], ratio, height, yInvert);
  let t = scaleX(point[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(point[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }
  return {
    x,
    y,
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}
function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}
function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}
//# sourceMappingURL=canvas-context.js.map