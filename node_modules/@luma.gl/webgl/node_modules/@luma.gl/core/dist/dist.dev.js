(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['luma'] = factory();
  else root['luma'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Buffer: () => Buffer2,
    CanvasContext: () => CanvasContext,
    CommandBuffer: () => CommandBuffer,
    CommandEncoder: () => CommandEncoder,
    ComputePass: () => ComputePass,
    ComputePipeline: () => ComputePipeline,
    Device: () => Device,
    ExternalTexture: () => ExternalTexture,
    Framebuffer: () => Framebuffer,
    RenderPass: () => RenderPass,
    RenderPipeline: () => RenderPipeline,
    Resource: () => Resource,
    Sampler: () => Sampler,
    Shader: () => Shader,
    StatsManager: () => StatsManager,
    Texture: () => Texture,
    TransformFeedback: () => TransformFeedback,
    UniformBlock: () => UniformBlock,
    UniformBufferLayout: () => UniformBufferLayout,
    UniformStore: () => UniformStore,
    VERSION: () => VERSION2,
    VertexArray: () => VertexArray,
    assert: () => assert2,
    cancelAnimationFrame: () => cancelAnimationFrame,
    cast: () => cast,
    checkProps: () => checkProps,
    decodeShaderAttributeType: () => decodeShaderAttributeType,
    decodeShaderUniformType: () => decodeShaderUniformType,
    decodeTextureFormat: () => decodeTextureFormat,
    decodeVertexFormat: () => decodeVertexFormat,
    deepEqual: () => deepEqual,
    fillArray: () => fillArray,
    formatCompilerLog: () => formatCompilerLog,
    formatValue: () => formatValue,
    getAttributeInfosFromLayouts: () => getAttributeInfosFromLayouts,
    getDataTypeFromTypedArray: () => getDataTypeFromTypedArray,
    getScratchArray: () => getScratchArray,
    getScratchArrayBuffer: () => getScratchArrayBuffer,
    getTypedArrayFromDataType: () => getTypedArrayFromDataType,
    getVertexFormatFromAttribute: () => getVertexFormatFromAttribute,
    glsl: () => glsl,
    isNumberArray: () => isNumberArray,
    isObjectEmpty: () => isObjectEmpty,
    isPowerOfTwo: () => isPowerOfTwo,
    isTypedArray: () => isTypedArray,
    isUniformValue: () => isUniformValue,
    loadFile: () => loadFile,
    loadImage: () => loadImage,
    loadImageBitmap: () => loadImageBitmap,
    loadScript: () => loadScript,
    log: () => log,
    luma: () => luma,
    makeRandomNumberGenerator: () => makeRandomNumberGenerator,
    mergeShaderLayout: () => mergeShaderLayout,
    random: () => random,
    requestAnimationFrame: () => requestAnimationFrame,
    setPathPrefix: () => setPathPrefix,
    splitUniformsAndBindings: () => splitUniformsAndBindings,
    stubRemovedMethods: () => stubRemovedMethods,
    uid: () => uid
  });

  // ../../node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    if (userAgent && userAgent.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/env/dist/lib/globals.js
  var self_ = globalThis.self || globalThis.window || globalThis.global;
  var window_ = globalThis.window || globalThis.self || globalThis.global;
  var document_ = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // ../../node_modules/@probe.gl/env/dist/utils/globals.js
  var VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser2 = isBrowser();

  // ../../node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id, defaultConfig) {
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      this.storage = void 0;
      this.id = void 0;
      this.config = void 0;
      this.storage = getStorage(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad(string) {
    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage(image, message, scale) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale = Math.min(scale, maxWidth / image.width);
    }
    const width = image.width * scale;
    const height = image.height * scale;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message, " %c+"), style];
  }

  // ../../node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR2) {
    COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
    COLOR2[COLOR2["RED"] = 31] = "RED";
    COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
    COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
    COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
    COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
    COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
    COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
    COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string, color, background) {
    if (!isBrowser && typeof string === "string") {
      if (color) {
        const colorCode = getColor(color);
        string = "\x1B[".concat(colorCode, "m").concat(string, "\x1B[39m");
      }
      if (background) {
        const colorCode = getColor(background);
        string = "\x1B[".concat(colorCode + BACKGROUND_INCREMENT, "m").concat(string, "\x1B[49m");
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
      const value = object[key];
      if (typeof value === "function") {
        if (!predefined.find((name2) => key === name2)) {
          object[key] = value.bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/assert.js
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (isBrowser() && window_.performance) {
      var _window$performance, _window$performance$n;
      timestamp = window_ === null || window_ === void 0 ? void 0 : (_window$performance = window_.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_) {
      var _process$hrtime;
      const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  var Log = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      this.id = void 0;
      this.VERSION = VERSION;
      this._startTs = getHiResTimestamp();
      this._deltaTs = getHiResTimestamp();
      this._storage = void 0;
      this.userData = {};
      this.LOG_THROTTLE_TIMEOUT = 0;
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_LOG_CONFIGURATION);
      this.timeStamp("".concat(this.id, " started"));
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.setConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.setConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message) {
      assert(condition, message);
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message = "",
        scale = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }
      return isBrowser() ? logImageInBrowser({
        image,
        message,
        scale
      }) : logImageInNode({
        image,
        message,
        scale
      });
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments({
        logLevel,
        message,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({
          logLevel,
          message,
          args,
          opts
        });
        method = method || opts.method;
        assert(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp();
          } else {
            return noop;
          }
        }
        message = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop;
    }
  };
  Log.VERSION = VERSION;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const {
      logLevel,
      message
    } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
      message = addColor(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode(_ref2) {
    let {
      image,
      message = "",
      scale = 1
    } = _ref2;
    console.warn("removed");
    return noop;
  }
  function logImageInBrowser(_ref3) {
    let {
      image,
      message = "",
      scale = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage(img, message, scale);
        console.log(...args);
      };
      img.src = image;
      return noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage(image, message, scale));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage(img, message, scale));
      img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({
    id: "@probe.gl/log"
  });

  // src/utils/log.ts
  var log = new Log({
    id: "luma.gl"
  });

  // ../../node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/stats/dist/lib/stat.js
  var Stat = class {
    constructor(name2, type) {
      this.name = void 0;
      this.type = void 0;
      this.sampleSize = 1;
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      this.name = name2;
      this.type = type;
      this.reset();
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp2();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp2() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@probe.gl/stats/dist/lib/stats.js
  var Stats = class {
    constructor(options) {
      this.id = void 0;
      this.stats = {};
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name2) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name2,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const stat of Object.values(this.stats)) {
        stat.reset();
      }
      return this;
    }
    forEach(fn) {
      for (const stat of Object.values(this.stats)) {
        fn(stat);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      const {
        name: name2,
        type
      } = stat;
      let result = this.stats[name2];
      if (!result) {
        if (stat instanceof Stat) {
          result = stat;
        } else {
          result = new Stat(name2, type);
        }
        this.stats[name2] = result;
      }
      return result;
    }
  };

  // src/utils/stats-manager.ts
  var StatsManager = class {
    stats = /* @__PURE__ */ new Map();
    getStats(name2) {
      return this.get(name2);
    }
    get(name2) {
      if (!this.stats.has(name2)) {
        this.stats.set(name2, new Stats({
          id: name2
        }));
      }
      return this.stats.get(name2);
    }
  };
  var lumaStats = new StatsManager();

  // src/init.ts
  function initializeLuma() {
    const VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "running from source";
    const STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
    if (globalThis.luma && globalThis.luma.VERSION !== VERSION3) {
      throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${VERSION3}`);
    }
    if (!globalThis.luma) {
      if (isBrowser()) {
        log.log(1, `${VERSION3} - ${STARTUP_MESSAGE}`)();
      }
      globalThis.luma = globalThis.luma || {
        VERSION: VERSION3,
        version: VERSION3,
        log,
        stats: lumaStats
      };
    }
    return VERSION3;
  }
  var VERSION2 = initializeLuma();

  // src/utils/is-array.ts
  function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView) ? value : null;
  }
  function isNumberArray(value) {
    if (Array.isArray(value)) {
      return value.length === 0 || typeof value[0] === "number" ? value : null;
    }
    return isTypedArray(value);
  }

  // src/utils/utils.ts
  var uidCounters = {};
  function uid(id = "id") {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
  }
  function isPowerOfTwo(n) {
    return n > 0 && (n & n - 1) === 0;
  }
  function isObjectEmpty(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // src/adapter/resources/resource.ts
  var Resource = class {
    userData = {};
    destroyed = false;
    allocatedBytes = 0;
    _attachedResources = /* @__PURE__ */ new Set();
    constructor(device, props, defaultProps) {
      if (!device) {
        throw new Error("no device");
      }
      this._device = device;
      this.props = selectivelyMerge(props, defaultProps);
      const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
      this.props.id = id;
      this.id = id;
      this.userData = this.props.userData || {};
      this.addStats();
    }
    destroy() {
      this.destroyResource();
    }
    delete() {
      this.destroy();
      return this;
    }
    toString() {
      return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
    }
    getProps() {
      return this.props;
    }
    attachResource(resource) {
      this._attachedResources.add(resource);
    }
    detachResource(resource) {
      this._attachedResources.delete(resource);
    }
    destroyAttachedResource(resource) {
      if (this._attachedResources.delete(resource)) {
        resource.destroy();
      }
    }
    destroyAttachedResources() {
      for (const resource of Object.values(this._attachedResources)) {
        resource.destroy();
      }
      this._attachedResources = /* @__PURE__ */ new Set();
    }
    destroyResource() {
      this.destroyAttachedResources();
      this.removeStats();
      this.destroyed = true;
    }
    removeStats() {
      const stats = this._device.statsManager.getStats("Resource Counts");
      const name2 = this[Symbol.toStringTag];
      stats.get(`${name2}s Active`).decrementCount();
    }
    trackAllocatedMemory(bytes, name2 = this[Symbol.toStringTag]) {
      const stats = this._device.statsManager.getStats("Resource Counts");
      stats.get("GPU Memory").addCount(bytes);
      stats.get(`${name2} Memory`).addCount(bytes);
      this.allocatedBytes = bytes;
    }
    trackDeallocatedMemory(name2 = this[Symbol.toStringTag]) {
      const stats = this._device.statsManager.getStats("Resource Counts");
      stats.get("GPU Memory").subtractCount(this.allocatedBytes);
      stats.get(`${name2} Memory`).subtractCount(this.allocatedBytes);
      this.allocatedBytes = 0;
    }
    addStats() {
      const stats = this._device.statsManager.getStats("Resource Counts");
      const name2 = this[Symbol.toStringTag];
      stats.get("Resources Created").incrementCount();
      stats.get(`${name2}s Created`).incrementCount();
      stats.get(`${name2}s Active`).incrementCount();
    }
  };
  __publicField(Resource, "defaultProps", {
    id: "undefined",
    handle: void 0,
    userData: void 0
  });
  function selectivelyMerge(props, defaultProps) {
    const mergedProps = {
      ...defaultProps
    };
    for (const key in props) {
      if (props[key] !== void 0) {
        mergedProps[key] = props[key];
      }
    }
    return mergedProps;
  }

  // src/adapter/resources/buffer.ts
  var _Buffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    constructor(device, props) {
      const deducedProps = {
        ...props
      };
      if ((props.usage || 0) & _Buffer.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          deducedProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          deducedProps.indexType = "uint16";
        }
      }
      super(device, deducedProps, _Buffer.defaultProps);
      this.usage = props.usage || 0;
      this.indexType = deducedProps.indexType;
    }
    readSyncWebGL2(byteOffset, byteLength) {
      throw new Error("not implemented");
    }
    debugData = new ArrayBuffer(0);
    _setDebugData(data, byteOffset, byteLength) {
      const buffer = ArrayBuffer.isView(data) ? data.buffer : data;
      const debugDataLength = Math.min(data ? data.byteLength : byteLength, _Buffer.DEBUG_DATA_MAX_LENGTH);
      if (data === null) {
        this.debugData = new ArrayBuffer(debugDataLength);
      } else if (byteOffset === 0 && byteLength === data.byteLength) {
        this.debugData = buffer.slice(0, debugDataLength);
      } else {
        this.debugData = buffer.slice(byteOffset, byteOffset + debugDataLength);
      }
    }
  };
  var Buffer2 = _Buffer;
  __publicField(Buffer2, "defaultProps", {
    ...Resource.defaultProps,
    usage: 0,
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: false
  });
  __publicField(Buffer2, "MAP_READ", 1);
  __publicField(Buffer2, "MAP_WRITE", 2);
  __publicField(Buffer2, "COPY_SRC", 4);
  __publicField(Buffer2, "COPY_DST", 8);
  __publicField(Buffer2, "INDEX", 16);
  __publicField(Buffer2, "VERTEX", 32);
  __publicField(Buffer2, "UNIFORM", 64);
  __publicField(Buffer2, "STORAGE", 128);
  __publicField(Buffer2, "INDIRECT", 256);
  __publicField(Buffer2, "QUERY_RESOLVE", 512);
  __publicField(Buffer2, "DEBUG_DATA_MAX_LENGTH", 32);

  // src/adapter/device.ts
  var _Device = class {
    get [Symbol.toStringTag]() {
      return "Device";
    }
    constructor(props) {
      this.props = {
        ..._Device.defaultProps,
        ...props
      };
      this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
    }
    statsManager = lumaStats;
    userData = {};
    _lumaData = {};
    loseDevice() {
      return false;
    }
    getCanvasContext() {
      if (!this.canvasContext) {
        throw new Error("Device has no CanvasContext");
      }
      return this.canvasContext;
    }
    createTexture(props) {
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      return this._createTexture(props);
    }
    createCommandEncoder(props = {}) {
      throw new Error("not implemented");
    }
    readPixelsToArrayWebGL(source, options) {
      throw new Error("not implemented");
    }
    readPixelsToBufferWebGL(source, options) {
      throw new Error("not implemented");
    }
    setParametersWebGL(parameters) {
      throw new Error("not implemented");
    }
    getParametersWebGL(parameters) {
      throw new Error("not implemented");
    }
    withParametersWebGL(parameters, func) {
      throw new Error("not implemented");
    }
    clearWebGL(options) {
      throw new Error("not implemented");
    }
    _getBufferProps(props) {
      if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      const newProps = {
        ...props
      };
      if ((props.usage || 0) & Buffer2.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          newProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          newProps.indexType = "uint16";
        } else {
          log.warn("indices buffer content must be of integer type")();
        }
      }
      return newProps;
    }
  };
  var Device = _Device;
  __publicField(Device, "defaultProps", {
    id: null,
    type: "best-available",
    canvas: null,
    container: null,
    webgl2: true,
    webgl1: true,
    manageState: true,
    width: 800,
    height: 600,
    debug: Boolean(log.get("debug")),
    break: [],
    gl: null
  });
  __publicField(Device, "VERSION", VERSION2);

  // src/utils/assert.ts
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // src/lib/luma.ts
  var deviceList = /* @__PURE__ */ new Map();
  var luma = class {
    static registerDevices(deviceClasses) {
      for (const deviceClass of deviceClasses) {
        assert2(deviceClass.type && deviceClass.isSupported && deviceClass.create);
        deviceList.set(deviceClass.type, deviceClass);
      }
    }
    static getAvailableDevices() {
      return Array.from(deviceList).map((Device2) => Device2.type);
    }
    static getSupportedDevices() {
      return Array.from(deviceList).filter((Device2) => Device2.isSupported()).map((Device2) => Device2.type);
    }
    static setDefaultDeviceProps(props) {
      Object.assign(Device.defaultProps, props);
    }
    static async createDevice(props = {}) {
      props = {
        ...Device.defaultProps,
        ...props
      };
      if (props.gl) {
        props.type = "webgl";
      }
      let DeviceClass;
      switch (props.type) {
        case "webgpu":
          DeviceClass = deviceList.get("webgpu");
          if (DeviceClass) {
            return await DeviceClass.create(props);
          }
          break;
        case "webgl":
        case "webgl1":
        case "webgl2":
          DeviceClass = deviceList.get("webgl");
          if (DeviceClass) {
            return await DeviceClass.create(props);
          }
          break;
        case "best-available":
          DeviceClass = deviceList.get("webgpu");
          if (DeviceClass && DeviceClass.isSupported()) {
            return await DeviceClass.create(props);
          }
          DeviceClass = deviceList.get("webgl");
          if (DeviceClass && DeviceClass.isSupported()) {
            return await DeviceClass.create(props);
          }
          break;
      }
      throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
    }
  };
  __publicField(luma, "stats", lumaStats);
  __publicField(luma, "log", log);

  // src/adapter/canvas-context.ts
  var isPage = isBrowser() && typeof document !== "undefined";
  var isPageLoaded = () => isPage && document.readyState === "complete";
  var DEFAULT_CANVAS_CONTEXT_PROPS = {
    canvas: null,
    width: 800,
    height: 600,
    useDevicePixels: true,
    autoResize: true,
    container: null,
    visible: true,
    colorSpace: "srgb",
    alphaMode: "opaque"
  };
  var CanvasContext = class {
    width = 1;
    height = 1;
    _canvasSizeInfo = {
      clientWidth: 0,
      clientHeight: 0,
      devicePixelRatio: 1
    };
    static get isPageLoaded() {
      return isPageLoaded();
    }
    constructor(props) {
      this.props = {
        ...DEFAULT_CANVAS_CONTEXT_PROPS,
        ...props
      };
      props = this.props;
      if (!isBrowser()) {
        this.id = "node-canvas-context";
        this.type = "node";
        this.width = this.props.width;
        this.height = this.props.height;
        this.canvas = null;
        return;
      }
      if (!props.canvas) {
        const canvas = createCanvas(props);
        const container = getContainer(props?.container || null);
        container.insertBefore(canvas, container.firstChild);
        this.canvas = canvas;
        if (!props?.visible) {
          this.canvas.style.visibility = "hidden";
        }
      } else if (typeof props.canvas === "string") {
        this.canvas = getCanvasFromDOM(props.canvas);
      } else {
        this.canvas = props.canvas;
      }
      if (this.canvas instanceof HTMLCanvasElement) {
        this.id = this.canvas.id;
        this.type = "html-canvas";
        this.htmlCanvas = this.canvas;
      } else {
        this.id = "offscreen-canvas";
        this.type = "offscreen-canvas";
        this.offscreenCanvas = this.canvas;
      }
      if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {
        this.resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            if (entry.target === this.canvas) {
              this.update();
            }
          }
        });
        this.resizeObserver.observe(this.canvas);
      }
    }
    getDevicePixelRatio(useDevicePixels) {
      if (typeof OffscreenCanvas !== "undefined" && this.canvas instanceof OffscreenCanvas) {
        return 1;
      }
      useDevicePixels = useDevicePixels === void 0 ? this.props.useDevicePixels : useDevicePixels;
      if (!useDevicePixels || useDevicePixels <= 0) {
        return 1;
      }
      if (useDevicePixels === true) {
        const dpr = typeof window !== "undefined" && window.devicePixelRatio;
        return dpr || 1;
      }
      return useDevicePixels;
    }
    getPixelSize() {
      switch (this.type) {
        case "node":
          return [this.width, this.height];
        case "offscreen-canvas":
          return [this.canvas.width, this.canvas.height];
        case "html-canvas":
          const dpr = this.getDevicePixelRatio();
          const canvas = this.canvas;
          return canvas.parentElement ? [canvas.clientWidth * dpr, canvas.clientHeight * dpr] : [this.canvas.width, this.canvas.height];
        default:
          throw new Error(this.type);
      }
    }
    getAspect() {
      const [width, height] = this.getPixelSize();
      return width / height;
    }
    cssToDeviceRatio() {
      try {
        const [drawingBufferWidth] = this.getDrawingBufferSize();
        const {
          clientWidth
        } = this._canvasSizeInfo;
        return clientWidth ? drawingBufferWidth / clientWidth : 1;
      } catch {
        return 1;
      }
    }
    cssToDevicePixels(cssPixel, yInvert = true) {
      const ratio = this.cssToDeviceRatio();
      const [width, height] = this.getDrawingBufferSize();
      return scalePixels(cssPixel, ratio, width, height, yInvert);
    }
    setDevicePixelRatio(devicePixelRatio, options = {}) {
      if (!this.htmlCanvas) {
        return;
      }
      let clientWidth = "width" in options ? options.width : this.htmlCanvas.clientWidth;
      let clientHeight = "height" in options ? options.height : this.htmlCanvas.clientHeight;
      if (!clientWidth || !clientHeight) {
        log.log(1, "Canvas clientWidth/clientHeight is 0")();
        devicePixelRatio = 1;
        clientWidth = this.htmlCanvas.width || 1;
        clientHeight = this.htmlCanvas.height || 1;
      }
      const cachedSize = this._canvasSizeInfo;
      if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
        let clampedPixelRatio = devicePixelRatio;
        const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
        const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
        this.htmlCanvas.width = canvasWidth;
        this.htmlCanvas.height = canvasHeight;
        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();
        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {
          clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);
          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);
          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);
          log.warn("Device pixel ratio clamped")();
        }
        this._canvasSizeInfo.clientWidth = clientWidth;
        this._canvasSizeInfo.clientHeight = clientHeight;
        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;
      }
    }
    getDrawingBufferSize() {
      const gl = this.device.gl;
      if (!gl) {
        throw new Error("canvas size");
      }
      return [gl.drawingBufferWidth, gl.drawingBufferHeight];
    }
    _setAutoCreatedCanvasId(id) {
      if (this.htmlCanvas?.id === "lumagl-auto-created-canvas") {
        this.htmlCanvas.id = id;
      }
    }
  };
  __publicField(CanvasContext, "pageLoaded", getPageLoadPromise());
  function getPageLoadPromise() {
    if (isPageLoaded() || typeof window === "undefined") {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      window.addEventListener("load", () => resolve());
    });
  }
  function getContainer(container) {
    if (typeof container === "string") {
      const element = document.getElementById(container);
      if (!element && !isPageLoaded()) {
        throw new Error(`Accessing '${container}' before page was loaded`);
      }
      if (!element) {
        throw new Error(`${container} is not an HTML element`);
      }
      return element;
    } else if (container) {
      return container;
    }
    return document.body;
  }
  function getCanvasFromDOM(canvasId) {
    const canvas = document.getElementById(canvasId);
    if (!canvas && !isPageLoaded()) {
      throw new Error(`Accessing '${canvasId}' before page was loaded`);
    }
    if (!(canvas instanceof HTMLCanvasElement)) {
      throw new Error("Object is not a canvas element");
    }
    return canvas;
  }
  function createCanvas(props) {
    const {
      width,
      height
    } = props;
    const targetCanvas = document.createElement("canvas");
    targetCanvas.id = "lumagl-auto-created-canvas";
    targetCanvas.width = width || 1;
    targetCanvas.height = height || 1;
    targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : "100%";
    targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : "100%";
    return targetCanvas;
  }
  function scalePixels(pixel, ratio, width, height, yInvert) {
    const point = pixel;
    const x = scaleX(point[0], ratio, width);
    let y = scaleY(point[1], ratio, height, yInvert);
    let t = scaleX(point[0] + 1, ratio, width);
    const xHigh = t === width - 1 ? t : t - 1;
    t = scaleY(point[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
      t = t === 0 ? t : t + 1;
      yHigh = y;
      y = t;
    } else {
      yHigh = t === height - 1 ? t : t - 1;
    }
    return {
      x,
      y,
      width: Math.max(xHigh - x + 1, 1),
      height: Math.max(yHigh - y + 1, 1)
    };
  }
  function scaleX(x, ratio, width) {
    const r = Math.min(Math.round(x * ratio), width - 1);
    return r;
  }
  function scaleY(y, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
  }

  // src/adapter/resources/texture.ts
  var _Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    constructor(device, props, defaultProps = _Texture.defaultProps) {
      super(device, props, defaultProps);
      this.dimension = this.props.dimension;
      this.format = this.props.format;
      this.width = this.props.width;
      this.height = this.props.height;
      this.depth = this.props.depth;
    }
  };
  var Texture = _Texture;
  __publicField(Texture, "defaultProps", {
    ...Resource.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: true,
    sampler: {},
    compressed: false,
    usage: 0,
    mipLevels: void 0,
    samples: void 0,
    type: void 0
  });
  __publicField(Texture, "COPY_SRC", 1);
  __publicField(Texture, "COPY_DST", 2);
  __publicField(Texture, "TEXTURE_BINDING", 4);
  __publicField(Texture, "STORAGE_BINDING", 8);
  __publicField(Texture, "RENDER_ATTACHMENT", 16);

  // src/adapter/resources/external-texture.ts
  var _ExternalTexture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "ExternalTexture";
    }
    constructor(device, props) {
      super(device, props, _ExternalTexture.defaultProps);
    }
  };
  var ExternalTexture = _ExternalTexture;
  __publicField(ExternalTexture, "defaultProps", {
    ...Resource.defaultProps,
    source: null,
    colorSpace: "srgb"
  });

  // src/lib/compiler-log/format-compiler-log.ts
  function formatCompilerLog(shaderLog, source, options) {
    let formattedLog = "";
    const lines = source.split(/\r?\n/);
    const log2 = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);
    switch (options?.showSourceCode || "no") {
      case "all":
        let currentMessage = 0;
        for (let lineNum = 1; lineNum <= lines.length; lineNum++) {
          formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
          while (log2.length > currentMessage && log2[currentMessage].lineNum === lineNum) {
            const message = log2[currentMessage++];
            formattedLog += formatCompilerMessage(message, lines, message.lineNum, {
              ...options,
              inlineSource: false
            });
          }
        }
        return formattedLog;
      case "issues":
      case "no":
        for (const message of shaderLog) {
          formattedLog += formatCompilerMessage(message, lines, message.lineNum, {
            inlineSource: options?.showSourceCode !== "no"
          });
        }
        return formattedLog;
    }
  }
  function formatCompilerMessage(message, lines, lineNum, options) {
    if (options?.inlineSource) {
      const numberedLines = getNumberedLines(lines, lineNum);
      const positionIndicator = message.linePos > 0 ? `${" ".repeat(message.linePos + 5)}^^^
` : "";
      return `
${numberedLines}${positionIndicator}${message.type.toUpperCase()}: ${message.message}

`;
    }
    return options?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${message.type.toUpperCase()}: ${message.message}</b></div>` : `${message.type.toUpperCase()}: ${message.message}`;
  }
  function getNumberedLines(lines, lineNum, options) {
    let numberedLines = "";
    for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {
      const sourceLine = lines[lineIndex - 1];
      if (sourceLine !== void 0) {
        numberedLines += getNumberedLine(sourceLine, lineNum, options);
      }
    }
    return numberedLines;
  }
  function getNumberedLine(line, lineNum, options) {
    const escapedLine = options?.html ? escapeHTML(line) : line;
    return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? "<br/>" : "\n"}`;
  }
  function padLeft(string, paddedLength) {
    let result = "";
    for (let i = string.length; i < paddedLength; ++i) {
      result += " ";
    }
    return result + string;
  }
  function escapeHTML(unsafe) {
    return unsafe.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
  }

  // src/lib/compiler-log/get-shader-info.ts
  function getShaderInfo(source, defaultName) {
    return {
      name: getShaderName(source, defaultName),
      language: "glsl",
      version: getShaderVersion(source)
    };
  }
  function getShaderName(shader, defaultName = "unnamed") {
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
  }
  function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words && words.length >= 2 && words[0] === "#version") {
      const v = parseInt(words[1], 10);
      if (Number.isFinite(v)) {
        version = v;
      }
    }
    return version;
  }

  // src/adapter/resources/shader.ts
  var _Shader = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    compilationStatus = "pending";
    constructor(device, props) {
      super(device, {
        id: getShaderIdFromProps(props),
        ...props
      }, _Shader.defaultProps);
      this.stage = this.props.stage;
      this.source = this.props.source;
    }
    getCompilationInfoSync() {
      return null;
    }
    async debugShader() {
      switch (this.props.debug) {
        case "never":
          return;
        case "errors":
          if (this.compilationStatus === "success") {
            return;
          }
          break;
        case "warnings":
        case "always":
          break;
      }
      const messages = await this.getCompilationInfo();
      if (this.props.debug === "warnings" && messages?.length === 0) {
        return;
      }
      this._displayShaderLog(messages);
    }
    _displayShaderLog(messages) {
      if (typeof document === "undefined" || !document?.createElement) {
        return;
      }
      const shaderName = getShaderInfo(this.source).name;
      const shaderTitle = `${this.stage} ${shaderName}`;
      const htmlLog = formatCompilerLog(messages, this.source, {
        showSourceCode: "all",
        html: true
      });
      const button = document.createElement("Button");
      button.innerHTML = `
<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />
<code style="user-select:text;"><pre>
${htmlLog}
</pre></code>`;
      button.style.top = "10px";
      button.style.left = "10px";
      button.style.position = "absolute";
      button.style.zIndex = "9999";
      button.style.width = "100%";
      button.style.textAlign = "left";
      document.body.appendChild(button);
      const errors = document.getElementsByClassName("luma-compiler-log-error");
      if (errors[0]?.scrollIntoView) {
        errors[0].scrollIntoView();
      }
      button.onclick = () => {
        const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;
        navigator.clipboard.writeText(dataURI);
      };
    }
  };
  var Shader = _Shader;
  __publicField(Shader, "defaultProps", {
    ...Resource.defaultProps,
    language: "auto",
    stage: "vertex",
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debug: "errors"
  });
  function getShaderIdFromProps(props) {
    return getShaderInfo(props.source).name || props.id || uid(`unnamed ${props.stage}-shader`);
  }

  // src/adapter/resources/sampler.ts
  var _Sampler = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Sampler";
    }
    constructor(device, props) {
      super(device, props, _Sampler.defaultProps);
    }
  };
  var Sampler = _Sampler;
  __publicField(Sampler, "defaultProps", {
    ...Resource.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "nearest",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    compare: "less-equal",
    maxAnisotropy: 1
  });

  // src/adapter/resources/framebuffer.ts
  var _Framebuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    colorAttachments = [];
    depthStencilAttachment = null;
    constructor(device, props = {}) {
      super(device, props, _Framebuffer.defaultProps);
      this.width = this.props.width;
      this.height = this.props.height;
    }
    resize(size) {
      let updateSize = !size;
      if (size) {
        const [width, height] = Array.isArray(size) ? size : [size.width, size.height];
        updateSize = updateSize || height !== this.height || width !== this.width;
        this.width = width;
        this.height = height;
      }
      if (updateSize) {
        log.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();
        this.resizeAttachments(this.width, this.height);
      }
    }
    autoCreateAttachmentTextures() {
      this.colorAttachments = this.props.colorAttachments.map((attachment) => {
        if (typeof attachment === "string") {
          const texture = this.createColorTexture(attachment);
          this.attachResource(texture);
          return texture;
        }
        return attachment;
      });
      if (this.props.depthStencilAttachment) {
        if (typeof this.props.depthStencilAttachment === "string") {
          const texture = this.createDepthStencilTexture(this.props.depthStencilAttachment);
          this.attachResource(texture);
          this.depthStencilAttachment = texture;
        } else {
          this.depthStencilAttachment = this.props.depthStencilAttachment;
        }
      }
    }
    createColorTexture(format) {
      return this.device.createTexture({
        id: "color-attachment",
        usage: Texture.RENDER_ATTACHMENT,
        format,
        width: this.width,
        height: this.height
      });
    }
    createDepthStencilTexture(format) {
      return this.device.createTexture({
        id: "depth-stencil-attachment",
        usage: Texture.RENDER_ATTACHMENT,
        format,
        width: this.width,
        height: this.height
      });
    }
    resizeAttachments(width, height) {
      for (let i = 0; i < this.colorAttachments.length; ++i) {
        if (this.colorAttachments[i]) {
          const resizedTexture = this.device._createTexture({
            ...this.colorAttachments[i].props,
            width,
            height
          });
          this.destroyAttachedResource(this.colorAttachments[i]);
          this.colorAttachments[i] = resizedTexture;
          this.attachResource(resizedTexture);
        }
      }
      if (this.depthStencilAttachment) {
        const resizedTexture = this.device._createTexture({
          ...this.depthStencilAttachment.props,
          width,
          height
        });
        this.destroyAttachedResource(this.depthStencilAttachment);
        this.depthStencilAttachment = resizedTexture;
        this.attachResource(resizedTexture);
      }
    }
  };
  var Framebuffer = _Framebuffer;
  __publicField(Framebuffer, "defaultProps", {
    ...Resource.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    depthStencilAttachment: null
  });

  // src/adapter/resources/render-pipeline.ts
  var _RenderPipeline = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPipeline";
    }
    hash = "";
    constructor(device, props) {
      super(device, props, _RenderPipeline.defaultProps);
      this.shaderLayout = this.props.shaderLayout;
      this.bufferLayout = this.props.bufferLayout || [];
    }
  };
  var RenderPipeline = _RenderPipeline;
  __publicField(RenderPipeline, "defaultProps", {
    ...Resource.defaultProps,
    vs: null,
    vsEntryPoint: "",
    vsConstants: {},
    fs: null,
    fsEntryPoint: "",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    vertexCount: 0,
    instanceCount: 0,
    bindings: {},
    uniforms: {}
  });

  // src/adapter/resources/compute-pipeline.ts
  var _ComputePipeline = class extends Resource {
    get [Symbol.toStringTag]() {
      return "ComputePipeline";
    }
    hash = "";
    constructor(device, props) {
      super(device, props, _ComputePipeline.defaultProps);
    }
  };
  var ComputePipeline = _ComputePipeline;
  __publicField(ComputePipeline, "defaultProps", {
    ...Resource.defaultProps,
    cs: void 0,
    csEntryPoint: void 0,
    csConstants: {},
    shaderLayout: []
  });

  // src/adapter/resources/render-pass.ts
  var _RenderPass = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPass";
    }
    constructor(device, props) {
      super(device, props, _RenderPass.defaultProps);
    }
  };
  var RenderPass = _RenderPass;
  __publicField(RenderPass, "defaultProps", {
    ...Resource.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: [0, 0, 0, 0],
    clearDepth: 1,
    clearStencil: 0,
    depthReadOnly: false,
    stencilReadOnly: false,
    discard: false
  });

  // src/adapter/resources/compute-pass.ts
  var ComputePass = class extends Resource {
    get [Symbol.toStringTag]() {
      return "ComputePass";
    }
    constructor(device, props) {
      super(device, props, Resource.defaultProps);
    }
  };
  __publicField(ComputePass, "defaultProps", {
    ...Resource.defaultProps
  });

  // src/adapter/resources/command-encoder.ts
  var _CommandEncoder = class extends Resource {
    get [Symbol.toStringTag]() {
      return "CommandEncoder";
    }
    constructor(device, props) {
      super(device, props, _CommandEncoder.defaultProps);
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
  };
  var CommandEncoder = _CommandEncoder;
  __publicField(CommandEncoder, "defaultProps", {
    ...Resource.defaultProps,
    measureExecutionTime: void 0
  });

  // src/adapter/resources/command-buffer.ts
  var _CommandBuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "CommandBuffer";
    }
    constructor(device, props) {
      super(device, props, _CommandBuffer.defaultProps);
    }
  };
  var CommandBuffer = _CommandBuffer;
  __publicField(CommandBuffer, "defaultProps", {
    ...Resource.defaultProps
  });

  // src/adapter/type-utils/decode-attribute-type.ts
  function decodeShaderAttributeType(attributeType) {
    const [dataType, components] = TYPE_INFO[attributeType];
    const integer = dataType === "i32" || dataType === "u32";
    const signed = dataType !== "u32";
    const byteLength = TYPE_SIZES[dataType] * components;
    const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
    return {
      dataType,
      components,
      defaultVertexFormat,
      byteLength,
      integer,
      signed
    };
  }
  function getCompatibleVertexFormat(dataType, components) {
    let vertexType;
    switch (dataType) {
      case "f32":
        vertexType = "float32";
        break;
      case "i32":
        vertexType = "sint32";
        break;
      case "u32":
        vertexType = "uint32";
        break;
      case "f16":
        return components <= 2 ? "float16x2" : "float16x4";
    }
    if (components === 1) {
      return vertexType;
    }
    return `${vertexType}x${components}`;
  }
  var TYPE_INFO = {
    f32: ["f32", 1],
    "vec2<f32>": ["f32", 2],
    "vec3<f32>": ["f32", 3],
    "vec4<f32>": ["f32", 4],
    f16: ["f16", 1],
    "vec2<f16>": ["f16", 2],
    "vec3<f16>": ["f16", 3],
    "vec4<f16>": ["f16", 4],
    i32: ["i32", 1],
    "vec2<i32>": ["i32", 2],
    "vec3<i32>": ["i32", 3],
    "vec4<i32>": ["i32", 4],
    u32: ["u32", 1],
    "vec2<u32>": ["u32", 2],
    "vec3<u32>": ["u32", 3],
    "vec4<u32>": ["u32", 4]
  };
  var TYPE_SIZES = {
    f32: 4,
    f16: 2,
    i32: 4,
    u32: 4
  };

  // src/adapter/type-utils/decode-data-type.ts
  function decodeVertexType(type) {
    const dataType = TYPE_MAP[type];
    const bytes = getDataTypeBytes(dataType);
    const normalized = type.includes("norm");
    const integer = !normalized && !type.startsWith("float");
    const signed = type.startsWith("s");
    return {
      dataType: TYPE_MAP[type],
      byteLength: bytes,
      integer,
      signed,
      normalized
    };
  }
  function getDataTypeBytes(type) {
    const bytes = TYPE_SIZES2[type];
    return bytes;
  }
  var TYPE_MAP = {
    uint8: "uint8",
    sint8: "sint8",
    unorm8: "uint8",
    snorm8: "sint8",
    uint16: "uint16",
    sint16: "sint16",
    unorm16: "uint16",
    snorm16: "sint16",
    float16: "float16",
    float32: "float32",
    uint32: "uint32",
    sint32: "sint32"
  };
  var TYPE_SIZES2 = {
    uint8: 1,
    sint8: 1,
    uint16: 2,
    sint16: 2,
    float16: 2,
    float32: 4,
    uint32: 4,
    sint32: 4
  };

  // src/adapter/type-utils/decode-vertex-format.ts
  function decodeVertexFormat(format) {
    let webglOnly;
    if (format.endsWith("-webgl")) {
      format.replace("-webgl", "");
      webglOnly = true;
    }
    const [type_, count] = format.split("x");
    const type = type_;
    const components = count ? parseInt(count) : 1;
    const decodedType = decodeVertexType(type);
    const result = {
      type,
      components,
      byteLength: decodedType.byteLength * components,
      integer: decodedType.integer,
      signed: decodedType.signed,
      normalized: decodedType.normalized
    };
    if (webglOnly) {
      result.webglOnly = true;
    }
    return result;
  }

  // src/adapter/attribute-utils/get-attribute-from-layouts.ts
  function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
    const attributeInfos = {};
    for (const attribute of shaderLayout.attributes) {
      attributeInfos[attribute.name] = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
    }
    return attributeInfos;
  }
  function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {
    const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
    const locationInfos = new Array(maxVertexAttributes).fill(null);
    for (const attributeInfo of Object.values(attributeInfos)) {
      locationInfos[attributeInfo.location] = attributeInfo;
    }
    return locationInfos;
  }
  function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name2) {
    const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name2);
    const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name2);
    if (!shaderDeclaration) {
      return null;
    }
    const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);
    const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;
    const vertexFormatInfo = decodeVertexFormat(vertexFormat);
    return {
      attributeName: bufferMapping?.attributeName || shaderDeclaration.name,
      bufferName: bufferMapping?.bufferName || shaderDeclaration.name,
      location: shaderDeclaration.location,
      shaderType: shaderDeclaration.type,
      shaderDataType: attributeTypeInfo.dataType,
      shaderComponents: attributeTypeInfo.components,
      vertexFormat,
      bufferDataType: vertexFormatInfo.type,
      bufferComponents: vertexFormatInfo.components,
      normalized: vertexFormatInfo.normalized,
      integer: attributeTypeInfo.integer,
      stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode,
      byteOffset: bufferMapping?.byteOffset || 0,
      byteStride: bufferMapping?.byteStride || 0
    };
  }
  function getAttributeFromShaderLayout(shaderLayout, name2) {
    const attribute = shaderLayout.attributes.find((attr) => attr.name === name2);
    if (!attribute) {
      log.warn(`shader layout attribute "${name2}" not present in shader`);
    }
    return attribute || null;
  }
  function getAttributeFromBufferLayout(bufferLayouts, name2) {
    checkBufferLayouts(bufferLayouts);
    let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name2);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name2);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    log.warn(`layout for attribute "${name2}" not present in buffer layout`);
    return null;
  }
  function checkBufferLayouts(bufferLayouts) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
        log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
      }
    }
  }
  function getAttributeFromShortHand(bufferLayouts, name2) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.format && bufferLayout.name === name2) {
        return {
          attributeName: bufferLayout.name,
          bufferName: name2,
          stepMode: bufferLayout.stepMode,
          vertexFormat: bufferLayout.format,
          byteOffset: 0,
          byteStride: bufferLayout.byteStride || 0
        };
      }
    }
    return null;
  }
  function getAttributeFromAttributesList(bufferLayouts, name2) {
    for (const bufferLayout of bufferLayouts) {
      let byteStride = bufferLayout.byteStride;
      if (typeof bufferLayout.byteStride !== "number") {
        for (const attributeMapping2 of bufferLayout.attributes || []) {
          const info = decodeVertexFormat(attributeMapping2.format);
          byteStride += info.byteLength;
        }
      }
      const attributeMapping = bufferLayout.attributes?.find((mapping) => mapping.attribute === name2);
      if (attributeMapping) {
        return {
          attributeName: attributeMapping.attribute,
          bufferName: bufferLayout.name,
          stepMode: bufferLayout.stepMode,
          vertexFormat: attributeMapping.format,
          byteOffset: attributeMapping.byteOffset,
          byteStride
        };
      }
    }
    return null;
  }
  function mergeShaderLayout(baseLayout, overrideLayout) {
    const mergedLayout = {
      ...baseLayout,
      attributes: baseLayout.attributes.map((attribute) => ({
        ...attribute
      }))
    };
    for (const attribute of overrideLayout?.attributes || []) {
      const baseAttribute = mergedLayout.attributes.find((attr) => attr.name === attribute.name);
      if (!baseAttribute) {
        log.warn(`shader layout attribute ${attribute.name} not present in shader`);
      } else {
        baseAttribute.type = attribute.type || baseAttribute.type;
        baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
      }
    }
    return mergedLayout;
  }

  // src/adapter/resources/vertex-array.ts
  var _VertexArray = class extends Resource {
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    indexBuffer = null;
    constructor(device, props) {
      super(device, props, _VertexArray.defaultProps);
      this.maxVertexAttributes = device.limits.maxVertexAttributes;
      this.attributes = new Array(this.maxVertexAttributes).fill(null);
      this.attributeInfos = getAttributeInfosByLocation(props.renderPipeline.shaderLayout, props.renderPipeline.bufferLayout, this.maxVertexAttributes);
    }
  };
  var VertexArray = _VertexArray;
  __publicField(VertexArray, "defaultProps", {
    ...Resource.defaultProps,
    renderPipeline: null
  });

  // src/adapter/resources/transform-feedback.ts
  var _TransformFeedback = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    constructor(device, props) {
      super(device, props, _TransformFeedback.defaultProps);
    }
  };
  var TransformFeedback = _TransformFeedback;
  __publicField(TransformFeedback, "defaultProps", {
    ...Resource.defaultProps,
    layout: void 0,
    buffers: {}
  });

  // src/adapter/type-utils/decode-shader-types.ts
  var UNIFORM_FORMATS = {
    "f32": {
      type: "f32",
      components: 1
    },
    "i32": {
      type: "i32",
      components: 1
    },
    "u32": {
      type: "u32",
      components: 1
    },
    "vec2<f32>": {
      type: "f32",
      components: 2
    },
    "vec3<f32>": {
      type: "f32",
      components: 3
    },
    "vec4<f32>": {
      type: "f32",
      components: 4
    },
    "vec2<i32>": {
      type: "i32",
      components: 2
    },
    "vec3<i32>": {
      type: "i32",
      components: 3
    },
    "vec4<i32>": {
      type: "i32",
      components: 4
    },
    "vec2<u32>": {
      type: "u32",
      components: 2
    },
    "vec3<u32>": {
      type: "u32",
      components: 3
    },
    "vec4<u32>": {
      type: "u32",
      components: 4
    },
    "mat2x2<f32>": {
      type: "f32",
      components: 4
    },
    "mat2x3<f32>": {
      type: "f32",
      components: 6
    },
    "mat2x4<f32>": {
      type: "f32",
      components: 8
    },
    "mat3x2<f32>": {
      type: "f32",
      components: 6
    },
    "mat3x3<f32>": {
      type: "f32",
      components: 9
    },
    "mat3x4<f32>": {
      type: "f32",
      components: 12
    },
    "mat4x2<f32>": {
      type: "f32",
      components: 8
    },
    "mat4x3<f32>": {
      type: "f32",
      components: 12
    },
    "mat4x4<f32>": {
      type: "f32",
      components: 16
    }
  };
  function decodeShaderUniformType(format) {
    const decoded = UNIFORM_FORMATS[format];
    assert2(format);
    return decoded;
  }
  function alignTo(size, count) {
    switch (count) {
      case 1:
        return size;
      case 2:
        return size + size % 2;
      default:
        return size + (4 - size % 4) % 4;
    }
  }

  // src/utils/array-utils-flat.ts
  var arrayBuffer;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type, length) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
    return new Type(scratchArrayBuffer, 0, length);
  }
  function fillArray(options) {
    const {
      target,
      source,
      start = 0,
      count = 1
    } = options;
    const length = source.length;
    const total = count * length;
    let copied = 0;
    for (let i = start; copied < length; copied++) {
      target[i++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return options.target;
  }

  // src/lib/uniforms/uniform-buffer-layout.ts
  var minBufferSize = 1024;
  var UniformBufferLayout = class {
    layout = {};
    constructor(uniformTypes) {
      let size = 0;
      for (const [key, uniformType] of Object.entries(uniformTypes)) {
        const typeAndComponents = decodeShaderUniformType(uniformType);
        const {
          type,
          components: count
        } = typeAndComponents;
        size = alignTo(size, count);
        const offset = size;
        size += count;
        this.layout[key] = {
          type,
          size: count,
          offset
        };
      }
      size += (4 - size % 4) % 4;
      const actualByteLength = size * 4;
      this.byteLength = Math.max(actualByteLength, minBufferSize);
    }
    getData(uniformValues) {
      const bufferSize = Math.max(this.byteLength, minBufferSize);
      const arrayBuffer2 = getScratchArrayBuffer(bufferSize);
      const typedArrays = {
        i32: new Int32Array(arrayBuffer2),
        u32: new Uint32Array(arrayBuffer2),
        f32: new Float32Array(arrayBuffer2),
        f16: new Uint16Array(arrayBuffer2)
      };
      for (const [name2, value] of Object.entries(uniformValues)) {
        const uniformLayout = this.layout[name2];
        if (!uniformLayout) {
          log.warn(`Supplied uniform value ${name2} not present in uniform block layout`)();
          continue;
        }
        const {
          type,
          size,
          offset
        } = uniformLayout;
        const typedArray = typedArrays[type];
        if (size === 1) {
          if (typeof value !== "number" && typeof value !== "boolean") {
            log.warn(`Supplied value for single component uniform ${name2} is not a number: ${value}`)();
            continue;
          }
          typedArray[offset] = Number(value);
        } else {
          const numericArray = isNumberArray(value);
          if (!numericArray) {
            log.warn(`Supplied value for multi component / array uniform ${name2} is not a numeric array: ${value}`)();
            continue;
          }
          typedArray.set(numericArray, offset);
        }
      }
      return new Uint8Array(arrayBuffer2);
    }
    has(name2) {
      return Boolean(this.layout[name2]);
    }
    get(name2) {
      const layout = this.layout[name2];
      return layout;
    }
  };

  // src/utils/array-equal.ts
  function arrayEqual(a, b, limit = 16) {
    if (a !== b) {
      return false;
    }
    const arrayA = isNumberArray(a);
    if (!arrayA) {
      return false;
    }
    const arrayB = isNumberArray(b);
    if (arrayB && arrayA.length === arrayB.length) {
      for (let i = 0; i < arrayA.length; ++i) {
        if (arrayB[i] !== arrayA[i]) {
          return false;
        }
      }
    }
    return true;
  }
  function arrayCopy(a) {
    const numberArray = isNumberArray(a);
    if (numberArray) {
      return numberArray.slice();
    }
    return a;
  }

  // src/lib/uniforms/uniform-block.ts
  var UniformBlock = class {
    uniforms = {};
    modifiedUniforms = {};
    modified = true;
    bindingLayout = {};
    needsRedraw = "initialized";
    constructor(props) {
      this.name = props?.name;
      if (props?.name && props?.shaderLayout) {
        const binding = props?.shaderLayout.bindings?.find((binding2) => binding2.type === "uniform" && binding2.name === props?.name);
        if (!binding) {
          throw new Error(props?.name);
        }
        const uniformBlock = binding;
        for (const uniform of uniformBlock.uniforms || []) {
          this.bindingLayout[uniform.name] = uniform;
        }
      }
    }
    setUniforms(uniforms) {
      for (const [key, value] of Object.entries(uniforms)) {
        this._setUniform(key, value);
        if (!this.needsRedraw) {
          this.setNeedsRedraw(`${this.name}.${key}=${value}`);
        }
      }
    }
    setNeedsRedraw(reason) {
      this.needsRedraw = this.needsRedraw || reason;
    }
    getAllUniforms() {
      this.modifiedUniforms = {};
      this.needsRedraw = false;
      return this.uniforms || {};
    }
    _setUniform(key, value) {
      if (arrayEqual(this.uniforms[key], value)) {
        return;
      }
      this.uniforms[key] = arrayCopy(value);
      this.modifiedUniforms[key] = true;
      this.modified = true;
    }
  };

  // src/lib/uniforms/uniform-store.ts
  var UniformStore = class {
    uniformBlocks = /* @__PURE__ */ new Map();
    uniformBufferLayouts = /* @__PURE__ */ new Map();
    uniformBuffers = /* @__PURE__ */ new Map();
    constructor(blocks) {
      for (const [bufferName, block] of Object.entries(blocks)) {
        const uniformBufferName = bufferName;
        const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});
        this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
        const uniformBlock = new UniformBlock({
          name: bufferName
        });
        uniformBlock.setUniforms(block.defaultUniforms || {});
        this.uniformBlocks.set(uniformBufferName, uniformBlock);
      }
    }
    destroy() {
      for (const uniformBuffer of Object.values(this.uniformBuffers)) {
        uniformBuffer.destroy();
      }
    }
    setUniforms(uniforms) {
      for (const [blockName, uniformValues] of Object.entries(uniforms)) {
        this.uniformBlocks.get(blockName).setUniforms(uniformValues);
      }
      this.updateUniformBuffers();
    }
    getUniformBufferByteLength(uniformBufferName) {
      return this.uniformBufferLayouts.get(uniformBufferName).byteLength;
    }
    getUniformBufferData(uniformBufferName) {
      const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();
      return this.uniformBufferLayouts.get(uniformBufferName).getData(uniformValues);
    }
    createUniformBuffer(device, uniformBufferName, uniforms) {
      if (uniforms) {
        this.setUniforms(uniforms);
      }
      const byteLength = this.getUniformBufferByteLength(uniformBufferName);
      const uniformBuffer = device.createBuffer({
        usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
        byteLength
      });
      const uniformBufferData = this.getUniformBufferData(uniformBufferName);
      uniformBuffer.write(uniformBufferData);
      return uniformBuffer;
    }
    getManagedUniformBuffer(device, uniformBufferName) {
      if (!this.uniformBuffers.get(uniformBufferName)) {
        const byteLength = this.getUniformBufferByteLength(uniformBufferName);
        const uniformBuffer = device.createBuffer({
          usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
          byteLength
        });
        this.uniformBuffers.set(uniformBufferName, uniformBuffer);
      }
      return this.uniformBuffers.get(uniformBufferName);
    }
    updateUniformBuffers() {
      let reason = false;
      for (const uniformBufferName of this.uniformBlocks.keys()) {
        const bufferReason = this.updateUniformBuffer(uniformBufferName);
        reason ||= bufferReason;
      }
      if (reason) {
        log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
      }
      return reason;
    }
    updateUniformBuffer(uniformBufferName) {
      const uniformBlock = this.uniformBlocks.get(uniformBufferName);
      const uniformBuffer = this.uniformBuffers.get(uniformBufferName);
      let reason = false;
      if (uniformBuffer && uniformBlock.needsRedraw) {
        reason ||= uniformBlock.needsRedraw;
        const uniformBufferData = this.getUniformBufferData(uniformBufferName);
        const uniformBuffer2 = this.uniformBuffers.get(uniformBufferName);
        uniformBuffer2.write(uniformBufferData);
        const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();
        log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
      }
      return reason;
    }
  };

  // src/adapter/type-utils/decode-texture-format.ts
  var REGEX = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
  function decodeTextureFormat(format) {
    const matches = REGEX.exec(format);
    if (matches) {
      const [, format2, length, type, srgb, suffix] = matches;
      if (format2) {
        const dataType = `${type}${length}`;
        const decodedType = decodeVertexType(dataType);
        return {
          format: format2,
          components: format2.length,
          srgb: srgb === "-srgb",
          unsized: suffix === "-unsized",
          webgl: suffix === "-webgl",
          ...decodedType
        };
      }
    }
    return decodeNonStandardFormat(format);
  }
  var EXCEPTIONS = {
    "rgba4unorm-webgl": {
      format: "rgba",
      bpp: 2
    },
    "rgb565unorm-webgl": {
      format: "rgb",
      bpp: 2
    },
    "rgb5a1unorm-webgl": {
      format: "rgba",
      bbp: 2
    },
    "rgb9e5ufloat": {
      format: "rgb",
      bbp: 4
    },
    "rg11b10ufloat": {
      format: "rgb",
      bbp: 4
    },
    "rgb10a2unorm": {
      format: "rgba",
      bbp: 4
    },
    "rgb10a2unorm-webgl": {
      format: "rgba",
      bbp: 4
    },
    "stencil8": {
      components: 1,
      bpp: 1,
      a: "stencil"
    },
    "depth16unorm": {
      components: 1,
      bpp: 2,
      a: "depth"
    },
    "depth24plus": {
      components: 1,
      bpp: 3,
      a: "depth"
    },
    "depth32float": {
      components: 1,
      bpp: 4,
      a: "depth"
    },
    "depth24plus-stencil8": {
      components: 2,
      bpp: 4,
      a: "depth-stencil"
    },
    "depth24unorm-stencil8": {
      components: 2,
      bpp: 4,
      a: "depth-stencil"
    },
    "depth32float-stencil8": {
      components: 2,
      bpp: 4,
      a: "depth-stencil"
    }
  };
  function decodeNonStandardFormat(format) {
    const data = EXCEPTIONS[format];
    if (!data) {
      throw new Error(`Unknown format ${format}`);
    }
    return {
      format: data.format || "",
      components: data.components || data.format?.length || 1,
      byteLength: data.bpp || 1,
      srgb: false,
      unsized: false
    };
  }

  // src/adapter/type-utils/vertex-format-from-attribute.ts
  function getDataTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return "float32";
      case Uint16Array:
        return "uint16";
      case Uint32Array:
        return "uint32";
      case Uint8Array:
      case Uint8ClampedArray:
        return "uint8";
      case Int8Array:
        return "sint8";
      case Int16Array:
        return "sint16";
      case Int32Array:
        return "sint32";
      default:
        throw new Error(type.constructor.name);
    }
  }
  function getTypedArrayFromDataType(dataType) {
    switch (dataType) {
      case "float32":
        return Float32Array;
      case "uint32":
        return Uint32Array;
      case "sint32":
        return Int32Array;
      case "uint16":
      case "unorm16":
        return Uint16Array;
      case "sint16":
      case "snorm16":
        return Int16Array;
      case "uint8":
      case "unorm8":
        return Uint8Array;
      case "sint8":
      case "snorm8":
        return Int8Array;
      default:
        throw new Error(dataType);
    }
  }
  function getVertexFormatFromAttribute(typedArray, size, normalized) {
    if (!size || size > 4) {
      throw new Error(`size ${size}`);
    }
    const components = size;
    let dataType = getDataTypeFromTypedArray(typedArray);
    if (dataType === "uint8" || dataType === "sint8") {
      if (components === 1 || components === 3) {
        throw new Error(`size: ${size}`);
      }
      if (normalized) {
        dataType = dataType.replace("int", "norm");
      }
      return `${dataType}x${components}`;
    }
    if (dataType === "uint16" || dataType === "sint16") {
      if (components === 1 || components === 3) {
        throw new Error(`size: ${size}`);
      }
      if (normalized) {
        dataType = dataType.replace("int", "norm");
      }
      return `${dataType}x${components}`;
    }
    if (components === 1) {
      return dataType;
    }
    return `${dataType}x${components}`;
  }

  // src/utils/cast.ts
  function cast(value) {
    return value;
  }

  // src/lib/uniforms/uniform.ts
  function isUniformValue(value) {
    return isNumberArray(value) !== null || typeof value === "number" || typeof value === "boolean";
  }
  function splitUniformsAndBindings(uniforms) {
    const result = {
      bindings: {},
      uniforms: {}
    };
    Object.keys(uniforms).forEach((name2) => {
      const uniform = uniforms[name2];
      if (isUniformValue(uniform)) {
        result.uniforms[name2] = uniform;
      } else {
        result.bindings[name2] = uniform;
      }
    });
    return result;
  }

  // src/utils/format-value.ts
  function formatArrayValue(v, opts = {}) {
    const {
      maxElts = 16,
      size = 1
    } = opts;
    let string = "[";
    for (let i = 0; i < v.length && i < maxElts; ++i) {
      if (i > 0) {
        string += `,${i % size === 0 ? " " : ""}`;
      }
      string += formatValue(v[i], opts);
    }
    const terminator = v.length > maxElts ? "..." : "]";
    return `${string}${terminator}`;
  }
  function formatValue(v, opts = {}) {
    const EPSILON = 1e-16;
    const {
      isInteger = false
    } = opts;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
      return formatArrayValue(v, opts);
    }
    if (typeof v !== "number") {
      return String(v);
    }
    if (Math.abs(v) < EPSILON) {
      return isInteger ? "0" : "0.";
    }
    if (isInteger) {
      return v.toFixed(0);
    }
    if (Math.abs(v) > 100 && Math.abs(v) < 1e4) {
      return v.toFixed(0);
    }
    const string = v.toPrecision(2);
    const decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
  }

  // src/utils/stub-methods.ts
  function stubRemovedMethods(instance, className, version, methodNames) {
    const upgradeMessage = `See luma.gl ${version} Upgrade Guide at https://luma.gl/docs/upgrade-guide`;
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName) => {
      if (prototype.methodName) {
        return;
      }
      prototype[methodName] = () => {
        log.removed(`Calling removed method ${className}.${methodName}: `, upgradeMessage)();
        throw new Error(methodName);
      };
    });
  }

  // src/utils/check-props.ts
  function checkProps(className, props, propChecks) {
    const {
      removedProps = {},
      deprecatedProps = {},
      replacedProps = {}
    } = propChecks;
    for (const propName in removedProps) {
      if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? `${className}.${removedProps[propName]}` : "N/A";
        log.removed(`${className}.${propName}`, replacement)();
      }
    }
    for (const propName in deprecatedProps) {
      if (propName in props) {
        const replacementProp = deprecatedProps[propName];
        log.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
      }
    }
    let newProps = null;
    for (const [propName, replacementProp] of Object.entries(replacedProps)) {
      if (propName in props) {
        log.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName];
        delete newProps[propName];
      }
    }
    return newProps || props;
  }

  // src/utils/load-file.ts
  var pathPrefix = "";
  function setPathPrefix(prefix) {
    pathPrefix = prefix;
  }
  async function loadFile(url, options) {
    url = url.startsWith("http") ? url : pathPrefix + url;
    const dataType = options?.dataType || "text";
    const response = await fetch(url, options);
    return await response[dataType]();
  }
  async function loadImageBitmap(url, opts) {
    const image = new Image();
    image.crossOrigin = opts?.crossOrigin || "anonymous";
    image.src = url.startsWith("http") ? url : pathPrefix + url;
    await image.decode();
    return await createImageBitmap(image);
  }
  async function loadImage(url, opts) {
    return new Promise((resolve, reject) => {
      try {
        const image = new Image();
        image.onload = () => resolve(image);
        image.onerror = () => reject(new Error(`Could not load image ${url}.`));
        image.crossOrigin = opts?.crossOrigin || "anonymous";
        image.src = url.startsWith("http") ? url : pathPrefix + url;
      } catch (error) {
        reject(error);
      }
    });
  }
  async function loadScript(scriptUrl, scriptId) {
    const head = document.getElementsByTagName("head")[0];
    if (!head) {
      throw new Error("loadScript");
    }
    const script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    return new Promise((resolve, reject) => {
      script.onload = resolve;
      script.onerror = (error) => reject(new Error(`Unable to load script '${scriptUrl}': ${error}`));
      head.appendChild(script);
    });
  }

  // src/utils/random.ts
  function makeRandomNumberGenerator() {
    let s = 1;
    let c = 1;
    return () => {
      s = Math.sin(c * 17.23);
      c = Math.cos(s * 27.92);
      return fract(Math.abs(s * c) * 1432.71);
    };
  }
  function fract(n) {
    return n - Math.floor(n);
  }
  var random = makeRandomNumberGenerator();

  // src/utils/deep-equal.ts
  function deepEqual(a, b, depth) {
    if (a === b) {
      return true;
    }
    if (!depth || !a || !b) {
      return false;
    }
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b[i], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b)) {
      return false;
    }
    if (typeof a === "object" && typeof b === "object") {
      const aKeys = Object.keys(a);
      const bKeys = Object.keys(b);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual(a[key], b[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // src/utils/request-animation-frame.ts
  function requestAnimationFrame(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
  }
  function cancelAnimationFrame(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
  }

  // src/index.ts
  var glsl = (x) => `${x}`;
  return __toCommonJS(src_exports);
})();
      return __exports__;
      });
